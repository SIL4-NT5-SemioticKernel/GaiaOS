/*! \mainpage NT4 User Manual

	The goal of the system to give users a system they can download and play with, no in between, assuming a good binary, otherwise it is compile then use. On windows a CMake build script is included so they can compile and play in one click. When they have it set up they can start playing with the batch file interface on Windows.On Linux you are assumed to be savvy enough to figure out the compilation, use, and interfacing. The engine envisioned as a "redstone component" in operation, I / O and interface meant to be used in a network of components, in this case scripts. It is obviously more complex than a simple redstone repeater, but the idea of encapsulation in such a manner remains.

	\section overview Overview
	- The system operates as a server, it runs continuously in a loop until shutdown
	- It has several files, input.ssv, config.ssv, control_panel.ssv, control_panel_flag.ssv, control_panel_complete, and output.ssv
	- All I / O is done through these space separated volumes for simplicity
	- The ML engine has your typical public interface for C++ OOP classes
	- This interface of the ML is then "piped" to and from these text files.The user may store a command followed by the arguments and the system will compile this into a function call to the ML engine.
	- The interface contains an "interpreter" that allows for "running" the config and control_panel files as sequential system calls to the ML engine, we'll call this interpreter eval()
	- The reason for this is for integration into shell scripts, and to be able to easily prototype networks, workflows, and configurations using the live shell engine, and then when ready you go implement the design by transliterating the code from text to C++.
	- This system is the highest abstraction of the engine, expected to be the lowest barrier of entry so it is presented as the 'face' of the engine, though the C++ pure interface has advantages to those who can C++.

	
*/


/** \addtogroup NT4_Namespace
 *  @{
 */

 /** \namespace NT4
	 \brief This is the namespace which encapsulates the NT4 Neural-Net Engine and the interfaces.
	 
 */



 //This is used to easily handle the conversions between types without losing data.
 //There is likely a better way but this is quick n easy and can be changed later.
union u_Data
{
	uint64_t U;
	double D;
	void* V;
};

//Used to output characters safely.
void opchr(char p_Char)
{
	if (int(p_Char) == 0)
	{
		std::cout << " ";
		return;
	}

	if (int(p_Char) == 7 || int(p_Char) == 8 || int(p_Char) == 9 || int(p_Char) == 10 || int(p_Char) == 13 || int(p_Char) == 255)
	{
		std::cout << "?";
	}
	else
	{
		std::cout << p_Char;
	}

}




std::string get_Padded(int p_Digits, int p_Num)
{
	std::string tmp_Return;
	int tmp_Digits = 1;
	int tmp_Pad = 0;

	int tmp_Num = p_Num;
	//---std::cout << "\n #." << tmp_Num << ".#";

	while (tmp_Num /= 10)
	{
		tmp_Digits++;
		//---std::cout << "\n ?." << tmp_Digits << ".?";
	}

	tmp_Pad = p_Digits - tmp_Digits;
	//---std::cout << "\n _." << tmp_Pad << "._";

	for (int cou_D = 0; cou_D < tmp_Pad; cou_D++)
	{
		tmp_Return += "0";
		//---std::cout << "\n {" << tmp_Return << "}";
	}

	tmp_Return += std::to_string(p_Num);

	//---std::cout << "\n [" << tmp_Return << "]";

	return tmp_Return;
}



//The NeuroTox 4 library.
namespace NT4
{

	//Used in the CAN & the Node Network for backprop.
	#include "NT4/c_IO.h"

	#include "NT4/c_Linked_List_Handler.h"

	#include "NT4/c_Node.h"

	#include "NT4/c_Trace.h"

	#include "NT4/c_Fractal_Tree.h"

	#include "NT4/c_Lookup_Tree.h"

	#include "NT4/c_Node_Network.h"

	#include "NT4/c_Charging_Array.h" 
	//#include "NT4/c_Backpropagation_Station
	// 
	//Both the Charging_Array & Backpropagation_Station have to have members to handle each type of CAN structure.
	#include "NT4/c_CAN.h"
	#include "NT4/c_CAN_Many_To_One.h"
	#include "NT4/c_CAN_1D_Pyramid.h"
	#include "NT4/c_CAN_2D_Pyramid.h"
	#include "NT4/c_CAN_3D_Pyramid.h"
	
	#include "NT4/c_Construct.h"
	#include "NT4/c_Construct_API.h"
	#include "NT4/c_Construct_Text_Server.h"

	#include "NT4/c_Time_Series_Generator.h"
	//#include "NT4/c_GPT.h"
}
/** @}*/






//This class serves as the user interface for the actuator I/O
class c_IO_Set
{
public:

    //Data is stored as an array of uint64_t
    uint64_t* Data;

    //The depth of the data.
    int Depth;

    c_IO_Set()
    {
        Data = NULL;

        Depth = 0;
    }

    void set_Depth(int p_Depth)
    {
        //If Data is NULL then everything else should be as well.
        if (Data != NULL)
        {
            delete[] Data;
            Data = NULL;
        }

        Depth = p_Depth;

        if (Depth == 0) { Data = NULL; return; }

        Data = new uint64_t[Depth];

        wipe_Data();
    }


    //Reset it if need be.
    void reset()
    {
        if (Data != NULL)
        {
            delete[] Data;
            Data = NULL;
            Depth = 0;
        }
    }

    //This shifts the output from current to 0.
    void wipe_Data()
    {
        for (int cou_Index = 0; cou_Index < Depth; cou_Index++)
        {
            Data[cou_Index] = 0;
        }
    }

    //Accepts an input and updates the correct index with it
    void set_Value(uint64_t p_Value, int p_Index = -1) //p_Index comes after since it may be 0
    {
        if (p_Index == -1)
        {
            p_Index = Depth - 1;
        }

        //First get the concrete value.
        Data[p_Index] = p_Value;
    }

    //Accepts an array, resets the data, then reads the array into the data then sets the depth.
    void set_Array_Value(uint64_t* p_Data_Array, int p_Depth)
    {
        reset();

        //Initialize the wiped input array and copy the data to it from the arguments.
        Depth = p_Depth;
        Data = new uint64_t[Depth];
        for (int cou_Index = 0; cou_Index < Depth; cou_Index++)
        {
            Data[cou_Index] = p_Data_Array[cou_Index];
        }
    }

    //Returns the value.
    uint64_t get_Value(int p_Index = -1)
    {
        if (p_Index == -1)
        {
            p_Index = Depth - 1;
        }

        return Data[p_Index];
    }

    //This shifts the output from current to 0.
    void shift_Data()
    {
        //Shift each array one index towards [0].
        for (int cou_Index = 0; cou_Index < (Depth - 1); cou_Index++)
        {
            Data[cou_Index] = Data[cou_Index + 1];
        }

        //Set the current to 0.0 in preparation for input.
        Data[Depth - 1] = 0;
    }

    //Outputs the data
    void output()
    {
        for (int cou_Index = 0; cou_Index < Depth; cou_Index++)
        {
            std::cout << "\n[" << cou_Index << "] Data: " << Data[cou_Index];
        }
    }
};





//This class serves as the user interface for the actuator I/O
class c_2D_IO_Set
{
public:

    //Data is stored as an array of uint64_t
    uint64_t** Data;

    //The depth of the data.
    //[0] == x
    //[1] == y
    //[] Those are arbitrarily chosen but if most follow them it should be easy to share work.
    int Depth[2];

    c_2D_IO_Set()
    {
        Data = NULL;

        Depth[0] = 0;
        Depth[1] = 0;
    }

    void set_Depth(int p_X_Depth, int p_Y_Depth)
    {
        reset();

        Depth[0] = p_X_Depth;
        Depth[1] = p_Y_Depth;

        Data = new uint64_t*[Depth[0]];

        for (int cou_X = 0; cou_X < Depth[0]; cou_X++)
        {
            Data[cou_X] = new uint64_t [Depth[1]];

            for (int cou_Y = 0; cou_Y < Depth[1]; cou_Y++)
            {
                Data[cou_X][cou_Y] = 0;
            }
        }
    }


    //Reset it if need be.
    void reset()
    {
        //If Data is NULL then everything else should be as well.
        //If Data is not NULL then there should be tiers.
        if (Data != NULL)
        {
            for (int cou_X = 0; cou_X < Depth[0]; cou_X++)
            {
                if (Data[cou_X] != NULL)
                {
                    delete[] Data[cou_X];
                    Data[cou_X] = NULL;
                }
            }

            delete[] Data;
            Data = NULL;
        }
        Depth[0] = 0;
        Depth[1] = 0;
    }

    //This shifts the output from current to 0.
    void wipe_Data()
    {
        for (int cou_X = 0; cou_X < Depth[0]; cou_X++)
        {
            for (int cou_Y = 0; cou_Y < Depth[1]; cou_Y++)
            {
                Data[cou_X][cou_Y] = 0;
            }
        }

    }

    //Accepts an input and updates the correct index with it
    void set_Value(uint64_t p_Value, int p_X, int p_Y) //p_Index comes after since it may be 0
    {
        //First get the concrete value.
        Data[p_X][p_Y] = p_Value;
    }

    //Accepts an array, resets the data, then reads the array into the data then sets the depth.
    void set_Array_Value(uint64_t** p_Data_Array, int p_X_Depth, int p_Y_Depth)
    {
        reset();

        set_Depth(p_X_Depth, p_Y_Depth);

        //Initialize the wiped input array and copy the data to it from the arguments.
        for (int cou_X=0;cou_X<Depth[0];cou_X++)
        {
            for (int cou_Y = 0; cou_Y < Depth[1]; cou_Y++)
            {
                Data[cou_X][cou_Y] = p_Data_Array[cou_X][cou_Y];
            }
        }
    }

    //Returns the value.
    uint64_t get_Value(int p_X, int p_Y)
    {
        return Data[p_X][p_Y];
    }

    //This shifts the output from current to 0 for Chrono.
    //We only shift the X-axis no matter the dimension. A line inches along, an image scrolls, a cube slides, etc.
    void shift_Data()
    {
        //Shift each array one index towards [0].
        for (int cou_X = 0; cou_X < (Depth[0] - 1); cou_X++)
        {
            for (int cou_Y = 0; cou_Y < Depth[1]; cou_Y++)
            {
                Data[cou_X][cou_Y] = Data[cou_X + 1][cou_Y];
            }
        }
        for (int cou_Y = 0; cou_Y < Depth[1]; cou_Y++)
        {
            Data[Depth[0] - 1][cou_Y] = 0;
        }
    }

    //Outputs the data
    void output()
    {
        for (int cou_X = 0; cou_X < Depth[0]; cou_X++)
        {
            std::cout << "\n";
            for (int cou_Y = 0; cou_Y < Depth[1]; cou_Y++)
            {
                std::cout << " [" << cou_X << "][" << cou_Y << "]: " << Data[cou_X][cou_Y];
            }
        }
    }
};










//This class serves as the user interface for the actuator I/O
class c_3D_IO_Set
{
public:

    //Data is stored as an array of uint64_t
    uint64_t*** Data;

    //The depth of the data.
    //[0] == x
    //[1] == y
    //[2] == z
    //[] Those are arbitrarily chosen but if most follow them it should be easy to share work.
    int Depth[3];

    c_3D_IO_Set()
    {
        Data = NULL;

        Depth[0] = 0;
        Depth[1] = 0;
        Depth[2] = 0;
    }

    void set_Depth(int p_X_Depth, int p_Y_Depth, int p_Z_Depth)
    {
        reset();

        Depth[0] = p_X_Depth;
        Depth[1] = p_Y_Depth;
        Depth[2] = p_Z_Depth;

        Data = new uint64_t ** [Depth[0]];

        for (int cou_X = 0; cou_X < Depth[0]; cou_X++)
        {
            Data[cou_X] = new uint64_t * [Depth[1]];

            for (int cou_Y = 0; cou_Y < Depth[1]; cou_Y++)
            {
                Data[cou_X][cou_Y] = new uint64_t [Depth[2]];

                for (int cou_Z = 0; cou_Z < Depth[2]; cou_Z++)
                {
                    Data[cou_X][cou_Y][cou_Z] = 0;
                }
            }
        }
    }


    //Reset it if need be.
    void reset()
    {
        //If Data is NULL then everything else should be as well.
        //If Data is not NULL then there should be tiers.
        if (Data != NULL)
        {
            for (int cou_X = 0; cou_X < Depth[0]; cou_X++)
            {
                if (Data[cou_X] != NULL)
                {
                    for (int cou_Y = 0; cou_Y < Depth[1]; cou_Y++)
                    {
                        if (Data[cou_X][cou_Y] != NULL)
                        {
                            delete[] Data[cou_X][cou_Y];
                            Data[cou_X][cou_Y] = NULL;
                        }
                    }
                    delete[] Data[cou_X];
                    Data[cou_X] = NULL;
                }
            }

            delete[] Data;
            Data = NULL;
        }
        Depth[0] = 0;
        Depth[1] = 0;
        Depth[2] = 0;
    }

    //This shifts the output from current to 0.
    void wipe_Data()
    {
        for (int cou_X = 0; cou_X < Depth[0]; cou_X++)
        {
            for (int cou_Y = 0; cou_Y < Depth[1]; cou_Y++)
            {
                for (int cou_Z = 0; cou_Z < Depth[2]; cou_Z++)
                {
                    Data[cou_X][cou_Y][cou_Z] = 0;
                }
            }
        }

    }

    //Accepts an input and updates the correct index with it
    void set_Value(uint64_t p_Value, int p_X, int p_Y, int p_Z)
    {
        //First get the concrete value.
        Data[p_X][p_Y][p_Z] = p_Value;
    }

    //Accepts an array, resets the data, then reads the array into the data then sets the depth.
    void set_Array_Value(uint64_t*** p_Data_Array, int p_X_Depth, int p_Y_Depth, int p_Z_Depth)
    {
        reset();

        set_Depth(p_X_Depth, p_Y_Depth, p_Z_Depth);

        //Initialize the wiped input array and copy the data to it from the arguments.
        for (int cou_X = 0; cou_X < Depth[0]; cou_X++)
        {
            for (int cou_Y = 0; cou_Y < Depth[1]; cou_Y++)
            {
                for (int cou_Z = 0; cou_Z < Depth[1]; cou_Z++)
                {
                    Data[cou_X][cou_Y][cou_Z] = p_Data_Array[cou_X][cou_Y][cou_Z];
                }
            }
        }
    }

    //Returns the value.
    uint64_t get_Value(int p_X, int p_Y, int p_Z)
    {
        return Data[p_X][p_Y][p_Z];
    }

    //This shifts the output from current to 0 for Chrono.
    //We only shift the X-axis no matter the dimension. A line inches along, an image scrolls, a cube slides, etc.
    void shift_Data()
    {
        //Shift each array one index towards [0].
        for (int cou_X = 0; cou_X < (Depth[0] - 1); cou_X++)
        {
            for (int cou_Y = 0; cou_Y < Depth[1]; cou_Y++)
            {
                for (int cou_Z = 0; cou_Z < Depth[2]; cou_Z++)
                {
                    Data[cou_X][cou_Y][cou_Z] = Data[cou_X + 1][cou_Y][cou_Z];
                }
            }
        }
        for (int cou_Y = 0; cou_Y < Depth[1]; cou_Y++)
        {
            for (int cou_Z = 0; cou_Z < Depth[2]; cou_Z++)
            {
                Data[Depth[0] - 1][cou_Y][cou_Z] = 0;
            }
        }
    }

    //Outputs the data
    void output()
    {
        for (int cou_X = 0; cou_X < Depth[0]; cou_X++)
        {
            std::cout << "\n";
            for (int cou_Y = 0; cou_Y < Depth[1]; cou_Y++)
            {
                std::cout << "\n";
                for (int cou_Z = 0; cou_Z < Depth[2]; cou_Z++)
                {
                    std::cout << " [" << cou_X << "][" << cou_Y << "][" << cou_Z << "]: " << Data[cou_X][cou_Y][cou_Z];
                }
            }
        }
    }
};
//This is the linked list for the buffer.
class c_Linked_List
{
public:

    //The next node in the chain.
    c_Linked_List* Next;
    c_Linked_List* Previous;
    uint64_t Quanta;

    c_Linked_List()
    {
        Next = NULL;
        Previous = NULL;
        Quanta = 0;
    }

    ~c_Linked_List()
    {
        Quanta = 0;
        //delete Next; Handled by the handler.
    }

    //Outputs the linked list.
    //-- !WARNING! RECURSIVE FUNCTION ON LINKED LIST! CALLING THIS WILL CAUSE STACK CORRUPTION ERROR WITH ENOUGH NODES!
    void output_LL()
    {
        //*std::cout << " [";
        std::cout << " $" << Quanta << "]  ";
        if (Next != NULL) { Next->output_LL(); }
    }
};

//This handles the linked list creation and deletion so that recursive destruction does not crash the stack.
class c_Linked_List_Handler
{
public:

    //The nodes in the linked list.
    c_Linked_List* Root;
    c_Linked_List** Current_LL;
    int Depth;

    c_Linked_List_Handler()
    {
        Root = NULL;
        Current_LL = &Root;
        Depth = 0;
    }

    ~c_Linked_List_Handler()
    {
        reset();
    }

    //Init
    void init()
    {
        Root = NULL;
        Current_LL = &Root;
        Depth = 0;
    }

    //Adds a node with the quanta of data passed.
    c_Linked_List* new_LL(uint64_t p_Quanta)
    {
        c_Linked_List* tmp_LL = NULL;

        *Current_LL = new c_Linked_List;

        (*Current_LL)->Quanta = p_Quanta;

        tmp_LL = *Current_LL;

        (*Current_LL)->Previous = tmp_LL;

        Current_LL = &(*Current_LL)->Next;

        Depth++;

        return tmp_LL;
    }

    //Resets the linked list.
    void reset()
    {
        c_Linked_List* tmp_LL = Root;
        Root = NULL;
        c_Linked_List* tmp_LL_Next = NULL;

        while (tmp_LL != NULL)
        {
            tmp_LL_Next = tmp_LL->Next;
            tmp_LL->Next = NULL;
            tmp_LL->Previous = NULL;
            delete tmp_LL;
            tmp_LL = NULL;
            tmp_LL = tmp_LL_Next;
        }

        if (Root != NULL) { delete Root; }
        Root = NULL;
        Current_LL = &Root;

        Depth = 0;
    }

    //Outputs the linked list.
    void output()
    {
        c_Linked_List* tmp_LL = Root;

        c_Linked_List* tmp_LL_Next = NULL;

        std::cout << "\n Output Linked List:";

        std::cout << " Depth: " << Depth;
        while (tmp_LL != NULL)
        {
            tmp_LL_Next = tmp_LL->Next;

            //Hmm, might change the tmp_LL->NID to a different name so it isn't NID->NID
            std::cout << "\n   -";
            
            std::cout << tmp_LL->Quanta;

            std::cout << "\n";


            tmp_LL = tmp_LL_Next;
        }
    }
};//The state is stored as uint64_t so you will need to typecast to appropriate datatype.

//Quick n dirty to output the double for the node states
union u_Tmp
{
    double D;
    uint64_t U;
};

class c_Node
{
public:

    //The Node ID, used because the raw address may change upon saving/loading and external hooks need a solid grasp.
    uint64_t NID;

    //The next node in the network.
    c_Node* Next;

    //Axons and the counters. Axons[0][] are the ones connected to the first leg, used in finding UTN
    //Axons are organized by the dendritic index they are connected to, if they connect to leg [0] then they are an axon on hillock [0].
    c_Node*** Axons;
    int* Axon_Count;
    int Axon_Hillock_Count;

    //Dendrites, lower connections, leg order is of highest importance.
    //Each one has a weight, this is used in the pyramidal node networks and others with many layers to address the double legged node problem.
    c_Node** Dendrites;
    float* Dendrite_Weights;
    int Dendrite_Count;

    //The reinforcement counter.
    //A filter function will be built into the c_Neural_Network that applies:
    // exponential growth to reduce new trace impact, one offs and flukes get filtered
    // Sigmoid curve for the top end to prevent extreme bias in highly reinforced nodes.
    float RC;

    //The quanta bound to the node.
    uint64_t State;

    //This tracks the node type.
    //(0: NULL), (1: State), (2: Branch), (3: Treetop), (4: State Treetop)
    short int Type;

    float Charge;

    int Tier;
    int Index;

    c_Node()
    {
        NID = 0;

        //The next node.
        Next = NULL;

        //Axons and their counters.

        Axons = NULL;
        Axon_Count = 0;
        Axon_Hillock_Count = 0;

        //Dendrites.
        Dendrites = NULL;
        Dendrite_Weights = NULL;
        Dendrite_Count = 0;

        Tier = 0;
        Index = 0;

        //Reinforcement Counters.
        RC = 1.0;

        //The nodes state.
        State = 0;

        //The type is 0 to start with.
        Type = 0;

        Charge = 0.0;
    }

    //(0: State), (1: Branch), (2: Treetop), (3: State/Treetop)
    void set_Type(int p_Type)
    {
        Type = p_Type;
    }

    void resize_Axon_Hillocks(int p_Count)
    {
        c_Node*** tmp_Axons;
        int* tmp_Axon_Count;
        tmp_Axons = new c_Node ** [Axon_Hillock_Count];
        tmp_Axon_Count = new int [Axon_Hillock_Count];

        for (int cou_A = 0; cou_A < Axon_Hillock_Count; cou_A++)
        {
            tmp_Axons[cou_A] = Axons[cou_A];
            Axons[cou_A] = NULL;

            tmp_Axon_Count[cou_A] = Axon_Count[cou_A];
        }

        delete[] Axons;
        Axons = NULL;

        delete[] Axon_Count;
        Axon_Count = NULL;

        Axons = new c_Node ** [p_Count];
        Axon_Count = new int [p_Count];

        for (int cou_A = 0; cou_A < Axon_Hillock_Count; cou_A++)
        {
            Axons[cou_A] = tmp_Axons[cou_A];
            tmp_Axons[cou_A] = NULL;

            Axon_Count[cou_A] = tmp_Axon_Count[cou_A];
        }

        delete[] tmp_Axons;
        tmp_Axons = NULL;

        delete[] tmp_Axon_Count;
        tmp_Axon_Count = NULL;

        for (int cou_A = Axon_Hillock_Count; cou_A < p_Count; cou_A++)
        {
            Axons[cou_A] = NULL;
            Axon_Count[cou_A] = 0;
        }

        Axon_Hillock_Count = p_Count;
    }

    //Adds an axon to the axon list at the given index, if the index doesn't exist then exist it with resize_Axon_Hillocks()
    void add_Axon_Index(c_Node* p_Axon, int p_Index)
    {
        if (p_Index >= Axon_Hillock_Count) { resize_Axon_Hillocks(p_Index + 1); }

        c_Node** tmp_Axons;
        tmp_Axons = new c_Node * [Axon_Count[p_Index]];
        for (int cou_A = 0; cou_A < Axon_Count[p_Index]; cou_A++)
        {
            tmp_Axons[cou_A] = Axons[p_Index][cou_A];
            Axons[p_Index][cou_A] = NULL;
        }

        delete[] Axons[p_Index];
        Axons[p_Index] = NULL;

        Axons[p_Index] = new c_Node * [Axon_Count[p_Index] + 1];

        for (int cou_A = 0; cou_A < Axon_Count[p_Index]; cou_A++)
        {
            Axons[p_Index][cou_A] = tmp_Axons[cou_A];
            tmp_Axons[cou_A] = NULL;
        }
        delete[] tmp_Axons;
        tmp_Axons = NULL;

        Axons[p_Index][Axon_Count[p_Index]] = p_Axon;
        Axon_Count[p_Index]++;
    }

    //This checks for double legged nodes and adjusts the weights so the network doesn't favor repeating patterns.
    //The double legged charging issue isn't limited to 2 legs, but that is the nomenclature that developed before the higher dimensional networks were explored.
    void rectify_Double_Legged_Nodes()
    {
        float tmp_Count = 0;

        //Step through each leg, comparing to the other legs, and then taking dividing the weight by the number of same legs, 3 same legs = 1/3 for each of the three resulting in 3 with .3333 you see?
        for (int cou_D = 0; cou_D < Dendrite_Count - 1; cou_D++)
        {
            tmp_Count = 1;

            if (Dendrite_Weights[cou_D] != 1.0) { continue; }

            for (int cou_XD = (cou_D + 1); cou_XD < Dendrite_Count; cou_XD++)
            {
                if (Dendrites[cou_D] == Dendrites[cou_XD]) { tmp_Count++; }
            }

            if (tmp_Count > 1)
            {
                Dendrite_Weights[cou_D] = 1 / tmp_Count;

                for (int cou_XD = (cou_D + 1); cou_XD < Dendrite_Count; cou_XD++)
                {
                    if (Dendrites[cou_D] == Dendrites[cou_XD]) { Dendrite_Weights[cou_XD] = 1 / tmp_Count; }
                }
            }
        }
    }

    //Sets the dendrites of the node.
    //This assumes the node has no dendrites yet, if it does you be dangling and jangling
    //It checks to see if any legs match, if they do their charges are cut proportionatly. 
    void set_Dendrites(c_Node** p_Dendrites, int p_Count)
    {
        Dendrites = new c_Node * [p_Count];
        Dendrite_Weights = new float[p_Count];

        for (int cou_D = 0; cou_D < p_Count; cou_D++)
        {
            Dendrites[cou_D] = p_Dendrites[cou_D];

            Dendrite_Weights[cou_D] = 1.0;
        }

        Dendrite_Count = p_Count;
    }

    //Searches the axons to see if an upper tier connection exists.
    //This is always called from the first leg, that is why we separate _F from normal.
    c_Node* does_Upper_Tier_Connection_Exist(c_Node** p_Nodes, int p_Count)
    {
        if (Axon_Hillock_Count > 0)
        {
            //std::cout << "\n Axon_Count[0]: " << Axon_Count[0];

            //Check the axons on the right side for the 
            for (int cou_A = 0; cou_A < Axon_Count[0]; cou_A++)
            {
                //std::cout << "\n   Axon_F[" << cou_A << "] " << Axons[0][cou_A];
                if (Axons[0][cou_A]->does_Lower_Connection_Exist(p_Nodes, p_Count))
                {
                    //std::cout << "\n >>>>>>>>>>>>>Foundit: " << Axons[0][cou_A];
                    return Axons[0][cou_A];
                }
            }
        }
        return NULL;
    }

    //Checks if the given node matches a dendrite on the right leg.
    bool does_Lower_Connection_Exist(c_Node ** p_Nodes, int p_Count)
    {
        if (Dendrite_Count != p_Count) { return 0; }

        //Check the lower connections to see if they match.
        for (int cou_C = 1; cou_C < p_Count; cou_C++)
        {
            if (Dendrites[cou_C] != p_Nodes[cou_C]) { return 0; }
        }
        return 1;
    }

    //Binds a node to a quanta of data, the state of the input.
    void bind_State(uint64_t p_State)
    {
        State = p_State;
    }

    //Initiates a backpropagation that outputs the pattern represented by this node.
    //p_Datatype: 0: String, 1: uint64_t
    void bp_O(int p_Datatype = 0)
    {
        //---std::cout << "<=- NID " << NID << " Pat [ ";
        //If a left leg exists then initiate a backpropagation along it, then along the right side.
        if (Dendrite_Count != 0)
        {
            if (Dendrites[0] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[0]->Type != 2) && (Dendrites[0]->Type != 3))
                {
                    Dendrites[0]->bp_F(p_Datatype);
                }
                //If the dendritically connected node is a treetop then call the _O on it.
                if ((Dendrites[0]->Type == 2) || (Dendrites[0]->Type == 3))
                {
                    Dendrites[0]->bp_O();
                }
            }

            for (int cou_D = 1; cou_D < Dendrite_Count; cou_D++)
            {
                if (Dendrites[cou_D] != NULL)
                {
                    //If not a treetop then call bp_M()
                    if ((Dendrites[cou_D]->Type != 2) && (Dendrites[cou_D]->Type != 3))
                    {
                        Dendrites[cou_D]->bp_M(p_Datatype);
                        continue;
                    }

                    //If the dendritically connected node is a treetop then call the _O on it.
                    if ((Dendrites[cou_D]->Type == 2) || (Dendrites[cou_D]->Type == 3))
                    {
                        Dendrites[cou_D]->bp_O(p_Datatype);
                    }
                }
            }
        }
        else
        {
            //Output the state
            //std::cout << " <" << NID << " :: " << State << "> ";

            //u_Tmp tmp_State; tmp_State.U = State;
            //std::cout << " [ " << tmp_State.D << ", " << State << " ] ";
            if (p_Datatype == 0) { std::cout << char(State); }
            if (p_Datatype == 1) { std::cout << State; }
            u_Data tmp_Bit; tmp_Bit.U = State;
            if (p_Datatype == 2) { std::cout << tmp_Bit.D; }
        }
        //---std::cout << " ] -=>";
    }

    //bp_Output the left node.
    void bp_F(int p_Datatype)
    {
        //If a left leg exists then initiate a backpropagation along it, then along the right side.
        if (Dendrite_Count != 0)
        {
            if (Dendrites[0] != NULL) { Dendrites[0]->bp_F(p_Datatype); }
            for (int cou_D = 1; cou_D < Dendrite_Count; cou_D++)
            {
                if (Dendrites[cou_D] != NULL) 
                {
                    //If the dendritically connected node is a treetop then call the _O on it.
                    if ((Dendrites[cou_D]->Type == 2) || (Dendrites[cou_D]->Type == 3))
                    {
                        Dendrites[cou_D]->bp_O(p_Datatype);
                    }
                    else
                    {
                        Dendrites[cou_D]->bp_M(p_Datatype);
                    }
                }

            }
        }
        else
        {
            //Output the state
            //std::cout << " <" << NID << " :: " << State << "> ";
            //u_Tmp tmp_State; tmp_State.U = State;
            //std::cout << " [ " << tmp_State.D << ", " << State << " ] ";
            if (p_Datatype == 0) { std::cout << char(State); }
            if (p_Datatype == 1) { std::cout << State; }
            u_Data tmp_Bit; tmp_Bit.U = State;
            if (p_Datatype == 2) { std::cout << tmp_Bit.D; }
        }
    }

    //bp_Output the other nodes, M stands for many.
    void bp_M(int p_Datatype)
    {
        //If a left leg exists then initiate a backpropagation along it, then along the right side.
        if (Dendrite_Count != 0)
        {
            for (int cou_D = 1; cou_D < Dendrite_Count; cou_D++)
            {
                if (Dendrites[cou_D] != NULL)
                {
                    //If the dendritically connected node is a treetop then call the _O on it.
                    if ((Dendrites[cou_D]->Type == 2) || (Dendrites[cou_D]->Type == 3))
                    {
                        Dendrites[cou_D]->bp_O(p_Datatype);
                    }
                    else
                    {
                        Dendrites[cou_D]->bp_M(p_Datatype);
                    }
                }
            }
        }
        else
        {
            //Output the state
            //std::cout << " <" << NID << " :: " << State << "> ";
            //u_Tmp tmp_State; tmp_State.U = State;
            //std::cout << " [ " << tmp_State.D << ", " << State << " ] ";
            if (p_Datatype == 0) { std::cout << char(State); }
            if (p_Datatype == 1) { std::cout << " " << State; }
            u_Data tmp_Bit; tmp_Bit.U = State;
            if (p_Datatype == 2) { std::cout << tmp_Bit.D; }
        }
    }

    


    //Initiates a backpropagation that 
    void bp_Trace_O(c_Linked_List_Handler * p_LL)
    {
        //If a left leg exists then initiate a backpropagation along it, then along the right side.
        if (Dendrite_Count != 0)
        {
            //---std::cout << "*";
            if (Dendrites[0] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[0]->Type != 2) && (Dendrites[0]->Type != 3))
                {
                    Dendrites[0]->bp_Trace_F(p_LL);
                }

                //If the dendritically connected node is a treetop then call the _O on it.
                if ((Dendrites[0]->Type == 2) || (Dendrites[0]->Type == 3))
                {
                    Dendrites[0]->bp_Trace_O(p_LL);
                }
            }

            for (int cou_D = 1; cou_D < Dendrite_Count; cou_D++)
            {
                if (Dendrites[cou_D] != NULL)
                {
                    //If not a treetop then call bp_M()
                    if ((Dendrites[cou_D]->Type != 2) && (Dendrites[cou_D]->Type != 3))
                    {
                        Dendrites[cou_D]->bp_Trace_M(p_LL);
                        continue;
                    }

                    //If the dendritically connected node is a treetop then call the bp_O on it.
                    if ((Dendrites[cou_D]->Type == 2) || (Dendrites[cou_D]->Type == 3))
                    {
                        Dendrites[cou_D]->bp_Trace_O(p_LL);
                    }
                }
            }
        }
        else
        {
            //Output the state
            std::cout << char(State);
            p_LL->new_LL(State);
        }
    }

    //bp_Output the left node.
    void bp_Trace_F(c_Linked_List_Handler* p_LL)
    {
        //If a left leg exists then initiate a backpropagation along it, then along the right side.
        if (Dendrite_Count != 0)
        {
            if (Dendrites[0] != NULL) { Dendrites[0]->bp_Trace_F(p_LL); }
            for (int cou_D = 1; cou_D < Dendrite_Count; cou_D++)
            {
                if (Dendrites[cou_D] != NULL) 
                {
                    Dendrites[cou_D]->bp_Trace_M(p_LL);
                }
            }
        }
        else
        {
            //Output the state
            //---std::cout << " <" << NID << " :: " << State << "> ";
            p_LL->new_LL(State);
        }
    }

    //bp_Output the other nodes, M stands for many.
    void bp_Trace_M(c_Linked_List_Handler* p_LL)
    {
        //If a left leg exists then initiate a backpropagation along it, then along the right side.
        if (Dendrite_Count != 0)
        {
            for (int cou_D = 1; cou_D < Dendrite_Count; cou_D++)
            {
                if (Dendrites[cou_D] != NULL)
                {
                    Dendrites[cou_D]->bp_Trace_M(p_LL);
                }
            }
        }
        else
        {
            //Output the state
            //---std::cout << " <" << NID << " :: " << State << "> ";
            p_LL->new_LL(State);
        }
    }


    //Initiates a backpropagation that 
    //If this is the first node then it starts at 0,0. Each step down the tree it tracks the direction and adjust the x,y going down according to a pre-determined matrix applied to it.
    //Get the legs for the node, the 2x2
    // 
    //tmp_Nodes[0] = Scaffold[cou_T - 1][cou_X][cou_Y][cou_Z];
    //tmp_Nodes[1] = Scaffold[cou_T - 1][cou_X + 1][cou_Y][cou_Z];
    //tmp_Nodes[2] = Scaffold[cou_T - 1][cou_X][cou_Y + 1][cou_Z];
    //tmp_Nodes[3] = Scaffold[cou_T - 1][cou_X + 1][cou_Y + 1][cou_Z];

    //tmp_Nodes[4] = Scaffold[cou_T - 1][cou_X][cou_Y][cou_Z + 1];
    //tmp_Nodes[5] = Scaffold[cou_T - 1][cou_X + 1][cou_Y][cou_Z + 1];
    //tmp_Nodes[6] = Scaffold[cou_T - 1][cou_X][cou_Y + 1][cou_Z + 1];
    //tmp_Nodes[7] = Scaffold[cou_T - 1][cou_X + 1][cou_Y + 1][cou_Z + 1];
    void bp_3D_Trace_O(c_Linked_List_Handler * p_LL, c_Linked_List_Handler * p_LL_X, c_Linked_List_Handler * p_LL_Y, c_Linked_List_Handler * p_LL_Z, uint64_t p_X = 0, uint64_t p_Y = 0, uint64_t p_Z = 0)
    {
        //---std::cout << "\n bp_3D_Trace_O <=- " << NID << " " << p_X << " " << p_Y << " " << p_Z;
        //If a left leg exists then initiate a backpropagation along it, then along the right side.
        if (Dendrite_Count != 0)
        {
            //---std::cout << "*";
            if (Dendrites[0] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[0]->Type != 2) && (Dendrites[0]->Type != 3))
                {
                    Dendrites[0]->bp_3D_Trace_F(p_LL, p_LL_X, p_LL_Y, p_LL_Z, p_X, p_Y, p_Z);
                }
            }
            bp_3D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_LL_Z, p_X, p_Y, p_Z);
        }
        else
        {
            //Output the state
            //---std::cout << " <" << NID << " :: " << State << "> ";
            p_LL->new_LL(State);
            p_LL_X->new_LL(p_X);
            p_LL_Y->new_LL(p_Y);
            p_LL_Z->new_LL(p_Z);
        }
        //---std::cout << " -=>";
    }

    //bp_Output the left node.
    void bp_3D_Trace_F(c_Linked_List_Handler* p_LL, c_Linked_List_Handler* p_LL_X, c_Linked_List_Handler* p_LL_Y, c_Linked_List_Handler* p_LL_Z, uint64_t p_X = 0, uint64_t p_Y = 0, uint64_t p_Z = 0)
    {

        //---std::cerr << "\n bp_3D_Trace_F <=- " << NID << " " << p_X << " " << p_Y << " " << p_Z;

        //If a left leg exists then initiate a backpropagation along it, then along the right side.
        //tmp_Nodes[0] = Scaffold[cou_T - 1][cou_X][cou_Y][cou_Z]; //1
        if (Dendrite_Count != 0)
        {
            //---std::cout << "*";
            if (Dendrites[0] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[0]->Type != 2) && (Dendrites[0]->Type != 3))
                {
                    Dendrites[0]->bp_3D_Trace_F(p_LL, p_LL_X, p_LL_Y, p_LL_Z, p_X, p_Y, p_Z);
                }
            }
            bp_3D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_LL_Z, p_X, p_Y, p_Z);
        }
        else
        {
            //Output the state
            //---std::cout << " <" << NID << " :: " << State << "> ";
            p_LL->new_LL(State);
            p_LL_X->new_LL(p_X);
            p_LL_Y->new_LL(p_Y);
            p_LL_Z->new_LL(p_Z);
        }
        //---std::cout << " -=>";
    }

    //bp_Output the other nodes, M stands for many.
    void bp_3D_Trace_M(c_Linked_List_Handler* p_LL, c_Linked_List_Handler* p_LL_X, c_Linked_List_Handler* p_LL_Y, c_Linked_List_Handler* p_LL_Z, uint64_t p_X = 0, uint64_t p_Y = 0, uint64_t p_Z = 0)
    {
        //---std::cout << "\n bp_3D_Trace_M <=- " << NID << " " << p_X << " " << p_Y << " " << p_Z;

        if (Dendrite_Count != 0)
        {
            //I'm doing these by hand so hopefully it is more approachable to newbs, if not we can always refactor with a nicer way, this looks like shit, but it is readable.


            //Scaffold[cou_T - 1][cou_X + 1][cou_Y][cou_Z];
            if (Dendrite_Count > 1)
            {
                if (Dendrites[1] != NULL)
                {
                    if ((Dendrites[1]->Type != 2) && (Dendrites[1]->Type != 3))
                    {
                        Dendrites[1]->bp_3D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_LL_Z, p_X + 1, p_Y, p_Z);
                    }
                }
            }

            //Scaffold[cou_T - 1][cou_X + 1][cou_Y][cou_Z];
            if (Dendrite_Count > 2)
            {
                if (Dendrites[2] != NULL)
                {
                    if ((Dendrites[2]->Type != 2) && (Dendrites[2]->Type != 3))
                    {
                        Dendrites[2]->bp_3D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_LL_Z, p_X, p_Y + 1, p_Z);
                    }
                }
            }


            //Scaffold[cou_T - 1][cou_X + 1][cou_Y + 1][cou_Z];
            if (Dendrite_Count > 3)
            {
                if (Dendrites[3] != NULL)
                {
                    if ((Dendrites[3]->Type != 2) && (Dendrites[3]->Type != 3))
                    {
                        Dendrites[3]->bp_3D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_LL_Z, p_X + 1, p_Y + 1, p_Z);
                    }
                }
            }

            //Scaffold[cou_T - 1][cou_X][cou_Y][cou_Z + 1];
            if (Dendrite_Count > 4)
            {
                if (Dendrites[4] != NULL)
                {
                    if ((Dendrites[4]->Type != 2) && (Dendrites[4]->Type != 3))
                    {
                        Dendrites[4]->bp_3D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_LL_Z, p_X, p_Y, p_Z + 1);
                    }
                }
            }

            //Scaffold[cou_T - 1][cou_X + 1][cou_Y][cou_Z + 1];
            if (Dendrite_Count > 5)
            {
                if (Dendrites[5] != NULL)
                {
                    if ((Dendrites[5]->Type != 2) && (Dendrites[5]->Type != 3))
                    {
                        Dendrites[5]->bp_3D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_LL_Z, p_X + 1, p_Y, p_Z + 1);
                    }
                }
            }

            //Scaffold[cou_T - 1][cou_X][cou_Y + 1][cou_Z + 1];
            if (Dendrite_Count > 6)
            {
                if (Dendrites[6] != NULL)
                {
                    if ((Dendrites[6]->Type != 2) && (Dendrites[6]->Type != 3))
                    {
                        Dendrites[6]->bp_3D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_LL_Z, p_X, p_Y + 1, p_Z + 1);
                    }
                }
            }

            //Scaffold[cou_T - 1][cou_X + 1][cou_Y + 1][cou_Z + 1];
            if (Dendrite_Count > 7)
            {
                if (Dendrites[7] != NULL)
                {
                    if ((Dendrites[7]->Type != 2) && (Dendrites[7]->Type != 3))
                    {
                        Dendrites[7]->bp_3D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_LL_Z, p_X + 1, p_Y + 1, p_Z + 1);
                    }

                }
            }
        }
        else
        {
            //Output the state
            //---std::cout << " <" << NID << " :: " << State << "> ";
            p_LL->new_LL(State);
            p_LL_X->new_LL(p_X);
            p_LL_Y->new_LL(p_Y);
            p_LL_Z->new_LL(p_Z);
        }
    }


    //Initiates a backpropagation that 
    //If this is the first node then it starts at 0,0. Each step down the tree it tracks the direction and adjust the x,y going down according to a pre-determined matrix applied to it.
    //Get the legs for the node, the 2x2
    //tmp_Nodes[0] = Scaffold[cou_T - 1][cou_X][cou_Y]; //1
    //tmp_Nodes[1] = Scaffold[cou_T - 1][cou_X][cou_Y + 1]; //2
    //tmp_Nodes[2] = Scaffold[cou_T - 1][cou_X + 1][cou_Y]; //3
    //tmp_Nodes[3] = Scaffold[cou_T - 1][cou_X + 1][cou_Y + 1]; //4
    void bp_2D_Trace_O(c_Linked_List_Handler * p_LL, c_Linked_List_Handler * p_LL_X, c_Linked_List_Handler * p_LL_Y, uint64_t p_X = 0, uint64_t p_Y = 0)
    {
        //---std::cout << "\n bp_2D_Trace_O <=- " << NID << " " << p_X << " " << p_Y;
        //If a left leg exists then initiate a backpropagation along it, then along the right side.
        if (Dendrite_Count != 0)
        {
            //---std::cout << "*";
            if (Dendrites[0] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[0]->Type != 2) && (Dendrites[0]->Type != 3))
                {
                    Dendrites[0]->bp_2D_Trace_F(p_LL, p_LL_X, p_LL_Y, p_X, p_Y);
                }

                //If the dendritically connected node is a treetop then call the _O on it.
                if ((Dendrites[0]->Type == 2) || (Dendrites[0]->Type == 3))
                {
                    Dendrites[0]->bp_2D_Trace_O(p_LL, p_LL_X, p_LL_Y, p_X, p_Y);
                }
            }

            //---std::cout << "*";
            if (Dendrites[1] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[1]->Type != 2) && (Dendrites[1]->Type != 3))
                {
                    Dendrites[1]->bp_2D_Trace_F(p_LL, p_LL_X, p_LL_Y, p_X, p_Y + 1);
                }

                //If the dendritically connected node is a treetop then call the _O on it.
                if ((Dendrites[1]->Type == 2) || (Dendrites[1]->Type == 3))
                {
                    Dendrites[1]->bp_2D_Trace_O(p_LL, p_LL_X, p_LL_Y, p_X, p_Y + 1);
                }
            }

            //---std::cout << "*";
            if (Dendrites[2] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[2]->Type != 2) && (Dendrites[2]->Type != 3))
                {
                    Dendrites[2]->bp_2D_Trace_F(p_LL, p_LL_X, p_LL_Y, p_X + 1, p_Y);
                }

                //If the dendritically connected node is a treetop then call the _O on it.
                if ((Dendrites[2]->Type == 2) || (Dendrites[2]->Type == 3))
                {
                    Dendrites[2]->bp_2D_Trace_O(p_LL, p_LL_X, p_LL_Y, p_X + 1, p_Y);
                }
            }
            //---std::cout << "*";
            if (Dendrites[3] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[3]->Type != 2) && (Dendrites[3]->Type != 3))
                {
                    Dendrites[3]->bp_2D_Trace_F(p_LL, p_LL_X, p_LL_Y, p_X + 1, p_Y + 1);
                }

                //If the dendritically connected node is a treetop then call the _O on it.
                if ((Dendrites[3]->Type == 2) || (Dendrites[3]->Type == 3))
                {
                    Dendrites[3]->bp_2D_Trace_O(p_LL, p_LL_X, p_LL_Y, p_X + 1, p_Y + 1);
                }
            }

        }
        else
        {
            //Output the state
            //---std::cout << " <" << NID << " :: " << State << "> ";
            p_LL->new_LL(State);
            p_LL_X->new_LL(p_X);
            p_LL_Y->new_LL(p_Y);
        }
        //---std::cout << " -=>";
    }

    //bp_Output the left node.
    void bp_2D_Trace_F(c_Linked_List_Handler* p_LL, c_Linked_List_Handler* p_LL_X, c_Linked_List_Handler* p_LL_Y, uint64_t p_X = 0, uint64_t p_Y = 0)
    {

        //---std::cout << "\n bp_2D_Trace_F <=- " << NID << " " << p_X << " " << p_Y;

        //If a left leg exists then initiate a backpropagation along it, then along the right side.
        if (Dendrite_Count != 0)
        {
            //---std::cout << "*";
            if (Dendrites[0] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[0]->Type != 2) && (Dendrites[0]->Type != 3))
                {
                    Dendrites[0]->bp_2D_Trace_F(p_LL, p_LL_X, p_LL_Y, p_X, p_Y);
                }
            }

            //---std::cout << "*";
            if (Dendrites[1] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[1]->Type != 2) && (Dendrites[1]->Type != 3))
                {
                    Dendrites[1]->bp_2D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_X, p_Y + 1);
                }
            }

            //---std::cout << "*";
            if (Dendrites[2] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[2]->Type != 2) && (Dendrites[2]->Type != 3))
                {
                    Dendrites[2]->bp_2D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_X + 1, p_Y);
                }
            }
            //---std::cout << "*";
            if (Dendrites[3] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[3]->Type != 2) && (Dendrites[3]->Type != 3))
                {
                    Dendrites[3]->bp_2D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_X + 1, p_Y + 1);
                }
            }

        }
        else
        {
            //Output the state
            //---std::cout << " <" << NID << " :: " << State << "> ";
            p_LL->new_LL(State);
            p_LL_X->new_LL(p_X);
            p_LL_Y->new_LL(p_Y);
        }
    }

    //bp_Output the other nodes, M stands for many.
    void bp_2D_Trace_M(c_Linked_List_Handler* p_LL, c_Linked_List_Handler* p_LL_X, c_Linked_List_Handler* p_LL_Y, uint64_t p_X = 0, uint64_t p_Y = 0)
    {
        //---std::cout << "\n bp_2D_Trace_M <=- " << NID << " " << p_X << " " << p_Y;

        //If a left leg exists then initiate a backpropagation along it, then along the right side.
        if (Dendrite_Count != 0)
        {
            //---std::cout << "*";
            if (Dendrites[1] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[1]->Type != 2) && (Dendrites[1]->Type != 3))
                {
                    Dendrites[1]->bp_2D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_X, p_Y + 1);
                }
            }

            //---std::cout << "*";
            if (Dendrites[2] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[2]->Type != 2) && (Dendrites[2]->Type != 3))
                {
                    Dendrites[2]->bp_2D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_X + 1, p_Y);
                }
            }
            //---std::cout << "*";
            if (Dendrites[3] != NULL)
            {
                //If not a treetop then call _F
                if ((Dendrites[3]->Type != 2) && (Dendrites[3]->Type != 3))
                {
                    Dendrites[3]->bp_2D_Trace_M(p_LL, p_LL_X, p_LL_Y, p_X + 1, p_Y + 1);
                }
            }
        }
        else
        {
            //Output the state
            //---std::cout << " <" << NID << " :: " << State << "> ";
            p_LL->new_LL(State);
            p_LL_X->new_LL(p_X);
            p_LL_Y->new_LL(p_Y);
        }
    }


    void output_Node_Raw()
    {
        std::cout << "\n Node_ID (NID): " << NID << " ";
        std::cout << " RC: " << RC;
        std::cout << " Type: " << Type;
        std::cout << " State { " << State << " }";
        std::cout << " --- Dendrites: ";
        for (int cou_D = 0; cou_D < Dendrite_Count; cou_D++)
        {
            std::cout << " [" << cou_D << "] " << Dendrites[cou_D]->NID << " Weight: " << Dendrite_Weights[cou_D] << " | ";
        }
        std::cout << " --- Axon_Hillock_Count: " << Axon_Hillock_Count;
        for (int cou_H = 0; cou_H < Axon_Hillock_Count; cou_H++)
        {
            std::cout << " Axons[" << cou_H << "] <" << Axon_Count[cou_H] << ">: ";
            for (int cou_A = 0; cou_A < Axon_Count[cou_H]; cou_A++)
            {
                std::cout << " [" << cou_A << "] " << Axons[cou_H][cou_A]->NID;
            }
        }
    }

    void output_Node_Char()
    {
        std::cout << static_cast<char>(uint64_t(this) & 0xFF);
    }
};


//This class serves as the user interface for the actuator I/O
class c_Trace
{
public:

    //Data is stored as an array of uint64_t
    std::vector<uint64_t> Pattern;
    float Charge;
    float RC;
    c_Node* Treetop;

    c_Trace()
    {
        reset();
    }

    ~c_Trace()
    {
        reset();
    }

    void set_Depth(int p_Depth)
    {
        //If Data is NULL then everything else should be as well.
        //This assumes that if Pattern is not NULL then it is properly setup as an array.
        wipe_Data();

        Pattern.resize(p_Depth);
    }

    //This leaves the depth of the pattern alone, useful if you can define one array and reuse it without having to redeclare and resize the array.
    //Used after set_Depth to intialize the new array.
    void wipe_Data()
    {
        Pattern.clear();
        Charge = 0.0;
        RC = 0.0;
        Treetop = NULL;
    }


    //Reset it if need be.
    void reset()
    {
        Pattern.clear();

        Charge = 0.0;
        RC = 0.0;
        Treetop = NULL;
    }

    //Accepts an input and updates the correct index with it
    void set_Pattern_Index(uint64_t p_Value, int p_Index = -1) //p_Index comes after since it may be 0
    {
        if (p_Index == -1)
        {
            p_Index = int(Pattern.size()) - 1;
        }

        //First get the concrete value.
        Pattern[p_Index] = p_Value;
    }

    //Sets the Charge
    void set_Charge(float p_Charge)
    {
        Charge = p_Charge;
    }

    //Sets the RC
    void set_RC(float p_RC)
    {
        RC = p_RC;
    }

    //Sets the Charge
    void set_Treetop(c_Node * p_Treetop)
    {
        Treetop = p_Treetop;
    }

    //Accepts an array, resets the data, then reads the array into the data then sets the depth.
    void set_Pattern_Array(uint64_t* p_Pattern_Array, int p_Depth)
    {
        reset();

        //Initialize the wiped input array and copy the data to it from the arguments.
        set_Depth(p_Depth);

        for (int cou_Index = 0; cou_Index < Pattern.size(); cou_Index++)
        {
            Pattern[cou_Index] = p_Pattern_Array[cou_Index];
        }
    }

    //Returns the value.
    uint64_t get_Pattern_Index(int p_Index = -1)
    {
        if (Pattern.size() == 0) { return 0; }
        if (p_Index >= Pattern.size()) { return 0; }
        if (p_Index == -1)
        {
            p_Index = int(Pattern.size()) - 1;
        }

        return Pattern[p_Index];
    }    
    
    //Returns the pattern as a string.
    std::string get_Pattern()
    {
        std::string tmp_Return_String = "";

        for (int cou_C = 0; cou_C < Pattern.size(); cou_C++)
        {
            tmp_Return_String += char(Pattern[cou_C]);
        }

        return tmp_Return_String;
    }
    
    //Returns the pattern as a string.
    std::vector<uint64_t> get_Pattern_uint()
    {
        return Pattern;
    }
    
    //Returns the pattern as a string.
    uint64_t get_Primitive_uint(int p_Primitive)
    {
        return Pattern[p_Primitive];
    }
    
    //Returns the pattern as a string.
    int get_Output_Pattern_Size()
    {
        return int(Pattern.size());
    }

    float get_Charge()
    {
        return Charge;
    }

    uint64_t get_Treetop_NID()
    {
        if (Treetop == NULL) { return 0; }
        return Treetop->NID;
    }

    float get_RC()
    {
        return RC;
    }

    c_Node * get_Treetop()
    {
        return Treetop;
    }

    //This shifts the output from current to 0.
    void shift_Data()
    {
        //Shift each array one index towards [0].
        for (uint64_t cou_Index = 0; cou_Index < (Pattern.size() - 1); cou_Index++)
        {
            Pattern[cou_Index] = Pattern[cou_Index + 1];
        }

        //Set the current to 0.0 in preparation for input.
        Pattern[Pattern.size() - 1] = 0;
    }

    //Outputs the data
    void output(int p_Type)
    {
        u_Data tmp_Dat;
        tmp_Dat.U = 0;
        uint64_t tmp_Tt_NID = 0;
        if (Treetop != NULL) { tmp_Tt_NID = Treetop->NID; }
        std::cout << " --  Charge: " << Charge << " RC: " << RC << " Treetop: " << tmp_Tt_NID << " Pattern: ";
        
        for (int cou_Index = 0; cou_Index < Pattern.size(); cou_Index++)
        {
            if (p_Type == 0){ std::cout << " " << char(Pattern[cou_Index]); }
            if (p_Type == 1){ std::cout << " " << Pattern[cou_Index]; }
            if (p_Type == 2) { tmp_Dat.U = Pattern[cou_Index]; std::cout << " " << tmp_Dat.D; }
            if (p_Type == 3) { std::cout << " " << int(Pattern[cou_Index]); }
        }
    }
};
















//This class serves as the user interface for the actuator I/O
class c_2D_Trace
{
public:

    //Data is stored as an array of uint64_t
    uint64_t** Pattern;
    float Charge;
    float RC;
    c_Node* Treetop;

    //The depth of the data.
    int Depth_X;
    int Depth_Y;

    c_2D_Trace()
    {
        Pattern = NULL;
        Depth_X = 0;
        Depth_Y = 0;
        reset();
    }

    void set_Depth(int p_Depth_X, int p_Depth_Y)
    {
        //If Data is NULL then everything else should be as well.
        //This assumes that if Pattern is not NULL then it is properly setup as an array.
        if (Pattern != NULL)
        {
            for (int cou_X = 0; cou_X < Depth_X; cou_X++)
            {
                delete[] Pattern[cou_X];
                Pattern[cou_X] = NULL;
            }

            delete[] Pattern;
            Pattern = NULL;
        }

        Depth_X = p_Depth_X;
        Depth_Y = p_Depth_Y;

        Pattern = new uint64_t * [Depth_X];

        for (int cou_X = 0; cou_X < Depth_X; cou_X++)
        {
            //It pains me not to wipe the data here, but we do it in wipe_Data
            Pattern[cou_X] = new uint64_t[Depth_Y];
        }

        wipe_Data();
    }

    //This leaves the depth of the pattern alone, useful if you can define one array and reuse it without having to redeclare and resize the array.
    //Used after set_Depth to intialize the new array.
    void wipe_Data()
    {
        for (int cou_X = 0; cou_X < Depth_X; cou_X++)
        {
            for (int cou_Y = 0; cou_Y < Depth_Y; cou_Y++)
            {
                Pattern[cou_X][cou_Y] = 0;
            }
        }

        Charge = 0.0;
        RC = 0.0;
        Treetop = NULL;
    }


    //Reset it if need be.
    void reset()
    {
        if (Pattern != NULL)
        {
            for (int cou_X = 0; cou_X < Depth_X; cou_X++)
            {
                if (Pattern[cou_X] != NULL)
                {
                    delete[] Pattern[cou_X];
                    Pattern[cou_X] = NULL;
                }
            }
            delete[] Pattern;
            Pattern = NULL;
        }

        Charge = 0.0;
        RC = 0.0;
        Treetop = NULL;

        Depth_X = 0;
        Depth_Y = 0;
    }

    //Accepts an input and updates the correct index with it
    void set_Pattern_Index(uint64_t p_Value, int p_X, int p_Y)
    {
        Pattern[p_X][p_Y] = p_Value;
    }

    //Sets the Charge
    void set_Charge(float p_Charge)
    {
        Charge = p_Charge;
    }

    //Sets the RC
    void set_RC(float p_RC)
    {
        RC = p_RC;
    }

    //Sets the associated node.
    void set_Treetop(c_Node* p_Treetop)
    {
        Treetop = p_Treetop;
    }

    //Accepts an array, resets the data, then reads the array into the data then sets the depth.
    void set_Pattern_Array(uint64_t** p_Pattern_Array, int p_Depth_X, int p_Depth_Y)
    {
        reset();

        //Initialize the wiped input array and copy the data to it from the arguments.
        set_Depth(p_Depth_X, p_Depth_Y);

        for (int cou_X = 0; cou_X < Depth_X; cou_X++)
        {
            for (int cou_Y = 0; cou_Y < Depth_Y; cou_Y++)
            {
                Pattern[cou_X][cou_Y] = p_Pattern_Array[cou_X][cou_Y];
            }
        }
    }

    //Returns the value.
    uint64_t get_Pattern_Index(int p_X, int p_Y)
    {
        return Pattern[p_X][p_Y];
    }

    float get_Charge()
    {
        return Charge;
    }

    float get_RC()
    {
        return RC;
    }

    c_Node* get_Treetop()
    {
        return Treetop;
    }

    //This shifts the output from current to 0.
    void shift_Data()
    {
        //Shift each array one index towards [0] on the x axis.
        for (int cou_X = 0; cou_X < (Depth_X - 1); cou_X++)
        {
            for (int cou_Y = 0; cou_Y < Depth_Y; cou_Y++)
            {
                Pattern[cou_X][cou_Y] = Pattern[cou_X + 1][cou_Y];
            }
        }

        //Set the current to 0.0 in preparation for input.
        for (int cou_Y = 0; cou_Y < Depth_Y; cou_Y++)
        {
            Pattern[Depth_X - 1][cou_Y] = 0;
        }
    }

    //Outputs the data
    void output(int p_Type)
    {
        uint64_t tmp_Tt_NID = 0;
        if (Treetop != NULL) { tmp_Tt_NID = Treetop->NID; }
        std::cout << " --  Charge: " << Charge << " RC: " << RC << " Treetop: " << tmp_Tt_NID << " Pattern: ";

        for (int cou_X = 0; cou_X < Depth_X; cou_X++)
        {
            std::cout << "\n";
            for (int cou_Y = 0; cou_Y < Depth_Y; cou_Y++)
            {
                if (p_Type == 0) { std::cout << " " << char(Pattern[cou_X][cou_Y]); }
                if (p_Type == 1) { std::cout << " " << Pattern[cou_X][cou_Y]; }
            }
        }
    }
};























//This class serves as the user interface for the actuator I/O
class c_3D_Trace
{
public:

    //Data is stored as an array of uint64_t
    uint64_t*** Pattern;
    float Charge;
    float RC;
    c_Node* Treetop;

    //The depth of the data.
    int Depth_X;
    int Depth_Y;
    int Depth_Z;

    c_3D_Trace()
    {
        Pattern = NULL;
        Depth_X = 0;
        Depth_Y = 0;
        Depth_Z = 0;
        reset();
    }

    void set_Depth(int p_Depth_X, int p_Depth_Y, int p_Depth_Z)
    {
        //If Data is NULL then everything else should be as well.
        //This assumes that if Pattern is not NULL then it is properly setup as an array.
        if (Pattern != NULL)
        {
            for (int cou_X = 0; cou_X < Depth_X; cou_X++)
            {
                for (int cou_Y = 0; cou_Y < Depth_Y; cou_Y++)
                {
                    delete[] Pattern[cou_X][cou_Y];
                    Pattern[cou_X][cou_Y] = NULL;
                }
                delete[] Pattern[cou_X];
                Pattern[cou_X] = NULL;
            }
            delete[] Pattern;
            Pattern = NULL;
        }

        Depth_X = p_Depth_X;
        Depth_Y = p_Depth_Y;
        Depth_Z = p_Depth_Z;

        Pattern = new uint64_t ** [Depth_X];

        for (int cou_X = 0; cou_X < Depth_X; cou_X++)
        {
            Pattern[cou_X] = new uint64_t*[Depth_Y];

            for (int cou_Y = 0; cou_Y < Depth_Y; cou_Y++)
            {
                //It pains me not to wipe the data here, but we do it in wipe_Data
                Pattern[cou_X][cou_Y] = new uint64_t[Depth_Z];
            }
        }

        wipe_Data();
    }

    //This leaves the depth of the pattern alone, useful if you can define one array and reuse it without having to redeclare and resize the array.
    //Used after set_Depth to intialize the new array.
    void wipe_Data()
    {
        for (int cou_X = 0; cou_X < Depth_X; cou_X++)
        {
            for (int cou_Y = 0; cou_Y < Depth_Y; cou_Y++)
            {
                for (int cou_Z = 0; cou_Z < Depth_Z; cou_Z++)
                {
                    Pattern[cou_X][cou_Y][cou_Z] = 0;
                }
            }
        }

        Charge = 0.0;
        RC = 0.0;
        Treetop = NULL;
    }


    //Reset it if need be.
    void reset()
    {
        wipe_Data();

        if (Pattern != NULL)
        {
            for (int cou_X = 0; cou_X < Depth_X; cou_X++)
            {
                if (Pattern[cou_X] != NULL)
                {
                    for (int cou_Y = 0; cou_Y < Depth_Y; cou_Y++)
                    {
                        if (Pattern[cou_X][cou_Y] != NULL)
                        {
                            delete[] Pattern[cou_X][cou_Y];
                            Pattern[cou_X][cou_Y] = NULL;
                        }
                    }
                    delete[] Pattern[cou_X];
                    Pattern[cou_X] = NULL;
                }
            }
            delete[] Pattern;
            Pattern = NULL;
        }


        Charge = 0.0;
        RC = 0.0;
        Treetop = NULL;

        Depth_X = 0;
        Depth_Y = 0;
        Depth_Z = 0;
    }

    //Accepts an input and updates the correct index with it
    void set_Pattern_Index(uint64_t p_Value, int p_X, int p_Y, int p_Z)
    {
        Pattern[p_X][p_Y][p_Z] = p_Value;
    }

    //Sets the Charge
    void set_Charge(float p_Charge)
    {
        Charge = p_Charge;
    }

    //Sets the RC
    void set_RC(float p_RC)
    {
        RC = p_RC;
    }

    //Sets the associated node.
    void set_Treetop(c_Node* p_Treetop)
    {
        Treetop = p_Treetop;
    }

    //Accepts an array, resets the data, then reads the array into the data then sets the depth.
    void set_Pattern_Array(uint64_t*** p_Pattern_Array, int p_Depth_X, int p_Depth_Y, int p_Depth_Z)
    {
        reset();

        //Initialize the wiped input array and copy the data to it from the arguments.
        set_Depth(p_Depth_X, p_Depth_Y, p_Depth_Z);

        for (int cou_X = 0; cou_X < Depth_X; cou_X++)
        {
            for (int cou_Y = 0; cou_Y < Depth_Y; cou_Y++)
            {
                for (int cou_Z = 0; cou_Z < Depth_Z; cou_Z++)
                {
                    Pattern[cou_X][cou_Y][cou_Z] = p_Pattern_Array[cou_X][cou_Y][cou_Z];
                }
            }
        }
    }

    //Returns the value.
    uint64_t get_Pattern_Index(int p_X, int p_Y, int p_Z)
    {
        return Pattern[p_X][p_Y][p_Z];
    }

    float get_Charge()
    {
        return Charge;
    }

    float get_RC()
    {
        return RC;
    }

    c_Node* get_Treetop()
    {
        return Treetop;
    }

    //This shifts the output from current to 0.
    void shift_Data()
    {
        //Shift each array one index towards [0] on the x axis.
        for (int cou_X = 0; cou_X < (Depth_X - 1); cou_X++)
        {
            for (int cou_Y = 0; cou_Y < Depth_Y; cou_Y++)
            {
                for (int cou_Z = 0; cou_Z < Depth_Z; cou_Z++)
                {
                    Pattern[cou_X][cou_Y][cou_Z] = Pattern[cou_X + 1][cou_Y][cou_Z];
                }
            }
        }

        //Set the current to 0.0 in preparation for input.
        for (int cou_Y = 0; cou_Y < Depth_Y; cou_Y++)
        {
            for (int cou_Z = 0; cou_Z < Depth_Z; cou_Z++)
            {
                Pattern[Depth_X - 1][cou_Y][cou_Z] = 0;
            }
        }
    }

    //Outputs the data
    void output(int p_Type)
    {
        uint64_t tmp_Tt_NID = 0;
        if (Treetop != NULL) { tmp_Tt_NID = Treetop->NID; }
        std::cout << " --  Charge: " << Charge << " RC: " << RC << " Treetop: " << tmp_Tt_NID << " Pattern: ";

        for (int cou_X = 0; cou_X < Depth_X; cou_X++)
        {
            std::cout << "\n";
            for (int cou_Y = 0; cou_Y < Depth_Y; cou_Y++)
            {
                std::cout << "\n";
                for (int cou_Z = 0; cou_Z < Depth_Z; cou_Z++)
                {
                    if (p_Type == 0) { std::cout << " " << char(Pattern[cou_X][cou_Y][cou_Z]); }
                    if (p_Type == 1) { std::cout << " " << Pattern[cou_X][cou_Y][cou_Z]; }
                }
            }
        }
    }
};


/*
		When I was building the networks I ran into the problem of searching them for existing state nodes. A state
	node is the node that associates an input with a node. State nodes allows for storing information in the networks and
	subsequently retrieving information from them. With the higher networks that used node IDs (NAdd)s from the lower
	constructs this became an issue because the number of unique nodes input into the network could get into the millions.
		In building a network you have to first take an input and search the network to see if that state was already
	associated with a node. Originally this was done with binary trees. The millions of unique inputs into these binary
	trees caused long search times. When it came to reading the nodes in there was another issue with the NAdds being
	sequential leading to extremely long branches in the binary tree that stored almost all of the nodes. This led to
	stack corruption with recusive searches.
		The first thing done was changing the recursive searches to an iterative one. This solved the issue of stack
	corruption but did nothing to solve the long search times. So then an optimization function was created which
	redistributed the nodes evenly along the branches. This function helped but did not fix the issue as the optimization
	had to be done frequently and was costly in and of itself.
		In the end I used a trinary tree combined with bit shifting the query. This allowed for a tree that has branches
	with fixed lengths. With the branches not getting excessive it does not run into the problem of stack corruptions
	even with millions of entries.
*/


//This class forms the basic node on which the fractal tree is built.
class c_Fractal_Node
{
	friend class c_Fractal_Tree;
private:

	//Legs of the node.
	c_Fractal_Node* Right;
	c_Fractal_Node* Center;
	c_Fractal_Node* Left;

public:

	//This stores the state||node ID
	uint64_t Data;

	//Pointer to the actual node.
	c_Node* NAdd;

	c_Fractal_Node()
	{
		Right = NULL;
		Center = NULL;
		Left = NULL;
		Data = 0;
		NAdd = NULL;
	}

	~c_Fractal_Node()
	{
		NAdd = NULL;
		if (Right != NULL) { delete Right; Right = NULL; }
		if (Center != NULL) { delete Center; Center = NULL; }
		if (Left != NULL) { delete Left; Left = NULL; }
	}

};

//The fractal state tree is a trinary tree that uses a bitshifted input to dtermine which nodes to assign.
class c_Fractal_Tree
{
private:


public:

	//The root node.
	c_Fractal_Node* Root;

	//the current node that will allow referencing outside of the search function.
	c_Fractal_Node** Current;

	//the flag that set when a node is found already set
	bool flg_Foundit;

	//Holds the bitshifted data to compare to the nodes data.
	uint64_t tmp_Data;

	//This is used for saving and loading, tracks the number of nodes in the tree so the system knows how many nodes to expect during loading.
	int State_Count;

	c_Fractal_Tree()
	{
		Root = NULL;
		Current = NULL;
		flg_Foundit = false;

		State_Count = 0;

		tmp_Data = 0;
	}

	~c_Fractal_Tree()
	{
		if (Root != NULL) { delete Root; Root = NULL; }
	}
	
	//Resets the tree.
	void reset()
	{
		if (Root != NULL) { delete Root; Root = NULL; }
	}

	//Search for a state.
	void search(uint64_t p_Data)
	{
		//Set the flag to indicate that the data was not found.
		flg_Foundit = false;

		tmp_Data = 0;

		//The data is 64 bits deep. So start the shift at 63.
		query_Node(Root, p_Data, 63);
	}

	//Queries a node. 
	//p_Node is the node to check against the query value.
	//p_Data is the data that is checked against.
	//p_Shift is the number of bits to extract for comparison.
	int query_Node(c_Fractal_Node*& p_Node, uint64_t p_Data, int p_Shift)
	{
		//Shift the data to get the temporary value.
		tmp_Data = p_Data >> p_Shift;

		//If the passed node is NULL create it.
		if (p_Node == NULL)
		{
			p_Node = new c_Fractal_Node;
			p_Node->Right = NULL;
			p_Node->Center = NULL;
			p_Node->Left = NULL;
			p_Node->NAdd = NULL;

			if (p_Shift >= 1)
			{
				//If the query is not at the end set the data to tmp_Data rather than p_Data.
				p_Node->Data = tmp_Data;
			}
			else
			{
				//If the query has reached the end set the data to the full query data.
				p_Node->Data = p_Data;

				//Set the current node to the newly created node.
				Current = &p_Node;

				//The node was not found, one had to be created.
				flg_Foundit = false;

				//We have registered a new leaf.
				State_Count++;

				//Return as we are done here.
				return 0;
			}
		}

		//If the current data matches the tmp data then another depth is explored.
		if (p_Node->Data == tmp_Data && p_Shift >= 1)
		{
			if (p_Shift == 1) { query_Node(p_Node->Center, p_Data, 0); return 0; }
			query_Node(p_Node->Center, p_Data, (p_Shift - 2));
			return 0;
		}

		//If the node data matches the given data exactly the node has been found.
		//Set Current to the current node.
		//Set the flg_Foundit to true as the node was found without creating it.
		if (p_Node->Data == p_Data)
		{
			Current = &p_Node;
			if (p_Node->NAdd != NULL) { flg_Foundit = true; }
			return 0;
		}

		//If the tmp_Data is less than the nodes data then look on the left leg.
		if (tmp_Data < p_Node->Data)
		{
			query_Node(p_Node->Left, p_Data, p_Shift);
			return 0;
		}

		//If the tmp_Data is more than the nodes data then look on the right leg.
		if (tmp_Data > p_Node->Data)
		{
			query_Node(p_Node->Right, p_Data, p_Shift);
			return 0;
		}
		return 0;
	}

	//Outputs the tree starting at the root node.
	void output_Tree()
	{
		output_Node(Root, 0);
	}

	//Outputs a given node. p_Tab determines an offset during output.
	void output_Node(c_Fractal_Node * &p_Node, int p_Tab)
	{
		if (p_Node == NULL) { return; }
		output_Node(p_Node->Left, (p_Tab));
		std::cout << "\n";
		for (int cou_Index = 0; cou_Index < p_Tab; cou_Index++)
		{
			std::cout << "  ";
		}
		std::cout << (p_Node->Data) << "->";
		if (p_Node->NAdd != NULL) 
		{ 
			std::cout << p_Node->NAdd; 
			std::cout << "\n";
			(p_Node->NAdd)->output_Node_Raw();
		}
		else { std::cout << "NULL"; }
		output_Node(p_Node->Center, (p_Tab + 1));
		output_Node(p_Node->Right, (p_Tab));
	}

	//Outputs the tree with the backpropagation from the nodes starting at the root node.
	void output_Tree_BP()
	{
		std::cout << "\n\t Fractal Tree Backpropagation Station";
		output_Node_BP(Root);
	}

	//Outputs a given node and backpropagates the node it is linked to.
	void output_Node_BP(c_Fractal_Node * &p_Node)
	{
		if (p_Node == NULL) { return; }
		output_Node_BP(p_Node->Left);
		if ((p_Node->NAdd) != NULL) { std::cout << "\n\t" << (p_Node->Data) << "->" << (p_Node->NAdd); (p_Node->NAdd)->bp_O(); }
		output_Node_BP(p_Node->Center);
		output_Node_BP(p_Node->Right);
	}

	//Retrieves the NAdd from a given node.
	c_Node* get_Node_NAdd(c_Fractal_Node * &p_Node)
	{
		if (p_Node != NULL)
		{
			return p_Node->NAdd;
		}
		else {
			return NULL;
		}
	}

	//Sets a node NAdd.
	void set_Node_NAdd(c_Fractal_Node * &p_Node, c_Node * p_NAdd)
	{
		if (p_Node != NULL)
		{
			p_Node->NAdd = p_NAdd;
		}
	}

	//Sets the current nodes NAdd.
	c_Node* set_Current_Node_NAdd(c_Node * p_NAdd)
	{
		set_Node_NAdd(*Current, p_NAdd);
		return p_NAdd;
	}

	//Gets the current nodes NAdd.
	c_Node* get_Current_Node_NAdd()
	{
		return get_Node_NAdd(*Current);
	}

	//Saves the tree as a list of nodes and the state associated.
	void save_Tree(std::ofstream* p_SF)
	{
		*p_SF << "\n" << State_Count;
		save_Tree_Node(Root, p_SF);
	}

	//Outputs a given node and backpropagates the node it is linked to.
	void save_Tree_Node(c_Fractal_Node * &p_Node, std::ofstream* p_SF)
	{
		if (p_Node == NULL) { return; }
		save_Tree_Node(p_Node->Left, p_SF);
		
		if ((p_Node->NAdd) != NULL) 
		{ 
			*p_SF << "\n " << (p_Node->NAdd)->NID << " " << (p_Node->NAdd)->State;
		}

		save_Tree_Node(p_Node->Center, p_SF);
		save_Tree_Node(p_Node->Right, p_SF);
	}

};
//This class forms the basic node on which the lookup tree is built. It's a basic binary tree.
class c_Lookup_Node
{
	friend class c_Lookup_Tree;
private:


public:

	//Legs of the node.
	c_Lookup_Node* Right;
	c_Lookup_Node* Left;

	//Node is also an LL
	c_Lookup_Node* Next;

	//The name bang tang in sophistic slang mang.
	std::string Name;

	//This stores the data, a uint64_t
	uint64_t Data;

	c_Lookup_Node()
	{
		Right = NULL;
		Left = NULL;

		Data = 0;
		
		Name = "NAMELESS & BLAMELESS";
	}

	~c_Lookup_Node()
	{
		Next = NULL;
		if (Right != NULL) { delete Right; Right = NULL; }
		if (Left != NULL) { delete Left; Left = NULL; }
	}

};

//The fractal state tree is a trinary tree that uses a bitshifted input to dtermine which nodes to assign.
class c_Lookup_Tree
{
private:


public:

	//The root node.
	c_Lookup_Node* Root;

	//the current node that will allow referencing outside of the search function.
	c_Lookup_Node** Current;

	//The current LL node.
	c_Lookup_Node** Current_LL;

	//the flag that set when a node is found already set
	bool flg_Foundit;

	c_Lookup_Tree()
	{
		Root = NULL;
		Current = NULL;
		Current_LL = &Root;
		flg_Foundit = false;
	}

	~c_Lookup_Tree()
	{
		if (Root != NULL) { delete Root; Root = NULL; }
	}
	
	//Resets the tree.
	void reset()
	{
		if (Root != NULL) { delete Root; Root = NULL; }
	}

	//Search for a state.
	void search(std::string p_Name)
	{
		//Set the flag to indicate that the data was not found.
		flg_Foundit = false;

		//The data is 64 bits deep. So start the shift at 63.
		query_Node(Root, p_Name);
	}

	//Queries a node. 
	//p_Node is the node to check against the query value.
	int query_Node(c_Lookup_Node*& p_Node, std::string p_Name)
	{
		//If the passed node is NULL create it.
		if (p_Node == NULL)
		{
			p_Node = new c_Lookup_Node;
			p_Node->Right = NULL;
			p_Node->Left = NULL;
			p_Node->Next = NULL;
			p_Node->Name = p_Name;

			if (Current_LL != NULL)
			{
				(*Current_LL)->Next = p_Node;
				Current_LL = &p_Node;
			}
			else
			{
				Current_LL = &p_Node;
			}

			//Set the current node to the newly created node.
			Current = &p_Node;

			//The node was not found, one had to be created.
			flg_Foundit = false;

			//Return as we are done here.
			return 0;
		}

		//If the node data matches the given data exactly the node has been found.
		//Set Current to the current node.
		//Set the flg_Foundit to true as the node was found without creating it.
		if (p_Node->Name == p_Name)
		{
			Current = &p_Node;
			flg_Foundit = true;
			return 1;
		}

		//If the tmp_Data is less than the nodes data then look on the left leg.
		if (p_Node->Name < p_Name)
		{
			query_Node(p_Node->Left, p_Name);
			return 0;
		}

		//If the tmp_Data is more than the nodes data then look on the right leg.
		if (p_Node->Name > p_Name)
		{
			query_Node(p_Node->Right, p_Name);
			return 0;
		}
		return 0;
	}

	//Outputs the tree starting at the root node.
	void output_Tree()
	{
		output_Node(Root, 0);
	}

	//Outputs a given node. p_Tab determines an offset during output.
	void output_Node(c_Lookup_Node * &p_Node, int p_Tab)
	{
		if (p_Node == NULL) { return; }
		output_Node(p_Node->Left, (p_Tab + 1));
		std::cout << "\n";
		for (int cou_Index = 0; cou_Index < p_Tab; cou_Index++)
		{
			std::cout << "  ";
		}
		std::cout << "Name: " << (p_Node->Name);
		std::cout << " - Data: ";
		std::cout << (p_Node->Data);
		output_Node(p_Node->Right, (p_Tab + 2));
	}

	//Retrieves the NAdd from a given node.
	uint64_t get_Data(c_Lookup_Node * &p_Node)
	{
		if (p_Node != NULL)
		{
			return p_Node->Data;
		}
		else 
		{
			return NULL;
		}
	}

	//Sets the current node data to the given data.
	void set_Data(c_Lookup_Node*& p_Node, uint64_t p_Data)
	{
		if (p_Node != NULL)
		{
			p_Node->Data = p_Data;
		}
		else
		{
			std::cerr << "\n\n   !(o,O)?   Error when setting node data in lookup tree. No current node, flg_Foundit false, passed node NULL.";
		}
	}

	//Sets the current nodes NAdd.
	void set_Current_Data(uint64_t p_Data)
	{
		set_Data(*Current, p_Data);
	}

	//Gets the current nodes NAdd.
	uint64_t get_Current_Data()
	{
		return get_Data(*Current);
	}
};

class c_Node_Network
{
public:

	//This is what holds all the nodes. It allows us to search by NID.
	//A node is created then added here. 
	c_Fractal_Tree Nodes;

	//This is the root node of the linked list, the linked list being the node soup.
	c_Node* Root;

	//Tracks the current node in the linked list, the last one in line for creation and appending of new nodes.
	c_Node** Current_Node;

	//We use this to assign Node IDs (NIDs) and then to iteratively delete the allocated nodes by querying the tree and deleting them.
	//It's slow to do it that way but we won't be killing the network except at shutdown.
	uint64_t Node_Count;

	//The current widest row in the network on last evaluation.
	int Fat_Tier;

	//This holds the state trees for each construct.
	//Even if two constructs have the same state input you may want to keep them separate, so you need multiple state trees.
	//The state tree does not create new nodes, it only tracks them.
	c_Fractal_Tree** State_Nodes;
	int State_Node_Tree_Count;

	//On creation a default construct at index 0 is registered.
	c_Node_Network()
	{
		Node_Count = 0;
		State_Node_Tree_Count = 1;
		State_Nodes = new c_Fractal_Tree * [1];
		State_Nodes[0] = new c_Fractal_Tree;

		Root = NULL;
		Current_Node = &Root;

		//When loading nodes remember that this one is created in the constructor so it will need skipped during the loading/saving phase.
		new_Node();
		Root->set_Type(0);
		Root->bind_State(0);
		Fat_Tier = 0;
	}


	~c_Node_Network()
	{
		std::cout << "\n ~c_Node_Network " << (Node_Count) << " " << this << ".........."; std::cout.flush();
		//delete Root;

		c_Node* tmp_LL = Root;
		Root = NULL;
		c_Node* tmp_LL_Next = NULL;

		while (tmp_LL != NULL)
		{
			tmp_LL_Next = tmp_LL->Next;
			tmp_LL->Next = NULL;
			delete tmp_LL;
			tmp_LL = NULL;
			tmp_LL = tmp_LL_Next;
		}

		delete Root;
		Root = NULL;

		std::cout << "\n ~~~c_Node_Network " << Node_Count << " " << this << ".........."; std::cout.flush();
	}

	int register_New_Construct()
	{
		c_Fractal_Tree** tmp_State_Nodes;

		tmp_State_Nodes = new c_Fractal_Tree * [State_Node_Tree_Count];

		for (int cou_Index = 0; cou_Index < State_Node_Tree_Count; cou_Index++)
		{
			tmp_State_Nodes[cou_Index] = State_Nodes[cou_Index];
			State_Nodes[cou_Index] = NULL;
		}

		if (State_Nodes != NULL) { delete[] State_Nodes; }

		State_Node_Tree_Count++;

		State_Nodes = new c_Fractal_Tree * [State_Node_Tree_Count];

		for (int cou_Index = 0; cou_Index < State_Node_Tree_Count; cou_Index++)
		{
			State_Nodes[cou_Index] = NULL;
		}

		for (int cou_Index = 0; cou_Index < (State_Node_Tree_Count - 1); cou_Index++)
		{
			State_Nodes[cou_Index] = tmp_State_Nodes[cou_Index];
			tmp_State_Nodes[cou_Index] = NULL;
		}

		if (tmp_State_Nodes != NULL) { delete[] tmp_State_Nodes; }
		tmp_State_Nodes = NULL;

		State_Nodes[State_Node_Tree_Count - 1] = new c_Fractal_Tree;

		return (State_Node_Tree_Count - 1);
	}

	//Creates a new node and adds it to the fractal tree.
	//Each node is stored as a link in a linked list.
	c_Node* new_Node()
	{
		//Create the node.
		*Current_Node = new c_Node;

		//Sets the new nodes ID.
		(*Current_Node)->NID = Node_Count;

		//Queries the node tree with the current NID to get the fractal node ready.
		Nodes.search(Node_Count);

		//Increment the node tracker.
		Node_Count++;

		//Sets the node in the node tree.
		Nodes.set_Current_Node_NAdd(*Current_Node);

		//Set the Current node to the next one in the chain.
		Current_Node = &(*Current_Node)->Next;

		//Return the created state node using the state tree as Current_Node is changed.
		return Nodes.get_Current_Node_NAdd();
	}

	//Creates a new node, then adds it to the state tree.
	//Assumes the construct is already registered so the index is valid.
	c_Node* new_State_Node(int p_Construct, uint64_t p_State)
	{
		c_Node* tmp_State_Node = new_Node();

		//Enter the state into the tree. The NNet node still needs linked to the pointer in the fractal node.
		State_Nodes[p_Construct]->search(p_State);

		//Assign the newly minted node in the fractal state tree.
		State_Nodes[p_Construct]->set_Current_Node_NAdd(tmp_State_Node);

		tmp_State_Node->State = p_State;

		tmp_State_Node->set_Type(0);

		return tmp_State_Node;
	}

	//This is used during loading when you have the node to bind to the state.
	void assign_State_Node(int p_State_Tree, c_Node * p_Node, uint64_t p_State)
	{
		//Enter the state into the tree. The NNet node still needs linked to the pointer in the fractal node.
		State_Nodes[p_State_Tree]->search(p_State);

		//Assign the newly minted node in the fractal state tree.
		State_Nodes[p_State_Tree]->set_Current_Node_NAdd(p_Node);

		p_Node->State = p_State;

		p_Node->set_Type(0);
	}

	//Creates a connection between nodes.
	//p_To forms dendritic connections to p_From, and on p_From you have the axonic connections.
	void create_Connections(c_Node* p_To, c_Node** p_From, int p_Count)
	{
		p_To->set_Dendrites(p_From, p_Count);

		for (int cou_Index = 0; cou_Index < p_Count; cou_Index++)
		{
			p_From[cou_Index]->add_Axon_Index(p_To, cou_Index);
		}
	}

	//Checks if an upper tier node exists.
	c_Node* does_Upper_Tier_Connection_Exist(c_Node** p_Legs, int p_Count)
	{
		//Search all the _F Axonic processes for the first leg, if found query the node to see if the leg permutations match.
		if (p_Legs[0] != NULL)
		{
			return p_Legs[0]->does_Upper_Tier_Connection_Exist(p_Legs, p_Count);
		}
		return NULL;
	}

	//Gets an upper tier node based on the given legs.
	c_Node* get_Upper_Tier_Node(c_Node** p_Legs, int p_Count, int p_Type, int p_Tier = 0)
	{
		if (p_Legs == NULL) { return NULL; }
		if (p_Count == 0) { return NULL; }

		c_Node* tmp_Node = NULL;

		//See if the node exists yet.
		tmp_Node = does_Upper_Tier_Connection_Exist(p_Legs, p_Count);

		/*
		std::cout << "\n DUTCE: " << tmp_Node;
		for (int cou_Leg = 0; cou_Leg < p_Count; cou_Leg++)
		{
			std::cout << "\n    [" << cou_Leg << "] " << p_Legs[cou_Leg];
		}
		*/

		//If the node doesn't exist then we create it, and then create the connection.
		if (tmp_Node == NULL)
		{
			//std::cout << "\n  New Node";

			tmp_Node = new_Node();

			create_Connections(tmp_Node, p_Legs, p_Count);

			tmp_Node->set_Type(p_Type);

			tmp_Node->Tier = p_Tier;
		}

		//std::cout << "\n  End: " << tmp_Node;
		return tmp_Node;
	}

	//If a state node exists in the given construct index then return it.
	//Otherwise return NULL.
	//This assumes the [Index] is valid
	c_Node* does_State_Node_Exist(int p_Index, uint64_t p_Data)
	{
		//Search the state tree give.
		State_Nodes[p_Index]->search(p_Data);
		if (State_Nodes[p_Index]->flg_Foundit)
		{
			return State_Nodes[p_Index]->get_Current_Node_NAdd();
		}
		return NULL;
	}

	//Checks to see if a node in the given assembly is bound to the given state, if not the node is created.
	c_Node* get_State_Node(int p_Index, uint64_t p_Data)
	{
		//See if the state node exists yet.
		c_Node* tmp_Node = does_State_Node_Exist(p_Index, p_Data);
		if (tmp_Node != NULL)
		{
			//If we found it then we return it.
			return tmp_Node;
		}

		//Create the new node and return it, new_State_Node handles the binding.
		return new_State_Node(p_Index, p_Data);
	}


	//Queries the node tree with the current NID to get the fractal node ready.
	c_Node* get_Node_Ref_By_NID(uint64_t p_NID)
	{

		//Queries the node tree with the given NID.
		Nodes.search(p_NID);

		if (Nodes.flg_Foundit)
		{
			return Nodes.get_Current_Node_NAdd();
		}
		return NULL;
	}

	//Gets the current fat row.
	int get_Fat_Tier()
	{
		return Fat_Tier;
	}

	//Sets the fat row.
	void set_Fat_Tier(int p_Fat_Tier)
	{
		Fat_Tier = p_Fat_Tier;
	}

	//Iterates through every node and outputs their bp_O()
	void output_BP(int p_Datatype = 0)
	{
		c_Node* tmp_Node;
		tmp_Node = Root;
		uint64_t tmp_Count = 0;
		while (tmp_Node != NULL)
		{
			std::cout << "\n<" << tmp_Count << ">";
			tmp_Node->bp_O(p_Datatype);

			tmp_Node = tmp_Node->Next;
			tmp_Count++;
		}
	}

	//Iterates through every node and outputs their bp_O()
	void output_Raw()
	{
		c_Node* tmp_Node;
		tmp_Node = Root;

		while (tmp_Node != NULL)
		{
			tmp_Node->output_Node_Raw();

			tmp_Node = tmp_Node->Next;
		}
	}

	//Finds given NID and outputs the bp_O()
	void output_BP_NID(uint64_t p_NID)
	{
		if (p_NID == 0)
		{
			std::cerr << "\n --== ERROR | Node[" << p_NID << "] is NULL node ==--";
			return;
		}

		c_Node* tmp_Node = NULL;
		tmp_Node = get_Node_Ref_By_NID(p_NID);
		if (tmp_Node != NULL)
		{
			std::cout << "\nNID: " << tmp_Node->NID << " ";
			std::cout << "Type: " << int(tmp_Node->Type) << " ";
			std::cout << "Symbol: ";
			tmp_Node->bp_O();
		}
		else
		{
			std::cerr << "\n --== ERROR | Node[" << p_NID << "] not found. ==--";
		}
	}

	//Finds given NID and outputs the bp_O()
	void output_Symbol_uint(uint64_t p_NID)
	{
		if (p_NID == 0)
		{
			std::cerr << "\n --== ERROR | Node[" << p_NID << "] is NULL node ==--";
			return;
		}

		c_Node* tmp_Node = NULL;
		tmp_Node = get_Node_Ref_By_NID(p_NID);
		if (tmp_Node != NULL)
		{
			std::cout << "\nNID: " << tmp_Node->NID << " ";
			std::cout << "Type: " << int(tmp_Node->Type) << " ";
			std::cout << "Symbol: ";
			tmp_Node->bp_O(1);
		}
		else
		{
			std::cerr << "\n --== ERROR | Node[" << p_NID << "] not found. ==--";
		}
	}


};
//These classes handle the charging buffers and charging array.



//This is the linked list for the buffer.
class c_Charging_Linked_List
{
public:

    //The next node in the chain.
    c_Charging_Linked_List* Next;
    c_Charging_Linked_List* Previous;
    float Charge;
    c_Node* NID;

    c_Charging_Linked_List()
    {
        Next = NULL;
        Previous = NULL;
        Charge = 0;
        NID = NULL;
    }

    ~c_Charging_Linked_List()
    {
        Charge = 0;
        NID = NULL;
        //delete Next; Handled by the handler.
    }

    //Outputs the linked list.
    //-- !WARNING! RECURSIVE FUNCTION ON LINKED LIST! CALLING THIS WILL CAUSE STACK CORRUPTION ERROR WITH ENOUGH NODES!
    void output_LL()
    {
        std::cout << "\n [";
        if (NID != NULL) { NID->bp_O(1); }
        std::cout << " $" << Charge << "]  ";
        if (Next != NULL) { Next->output_LL(); }
    }
};

//This handles the linked list creation and deletion so that recursive destruction does not crash the stack.
class c_Charging_Linked_List_Handler
{
public:

    //The nodes in the linked list.
    c_Charging_Linked_List* Root;
    c_Charging_Linked_List** Current_LL;
    int Depth;

    c_Charging_Linked_List_Handler()
    {
        Root = NULL;
        Current_LL = &Root;
        Depth = 0;
    }

    ~c_Charging_Linked_List_Handler()
    {
        reset();
    }

    //Init
    void init()
    {
        Root = NULL;
        Current_LL = &Root;
        Depth = 0;
    }

    //Adds a node.
    c_Charging_Linked_List* new_LL(c_Node* p_NID, float p_Charge)
    {
        c_Charging_Linked_List* tmp_LL = NULL;

        *Current_LL = new c_Charging_Linked_List;

        (*Current_LL)->Charge = p_Charge;
        (*Current_LL)->NID = p_NID;

        tmp_LL = *Current_LL;

        (*Current_LL)->Previous = tmp_LL;

        Current_LL = &(*Current_LL)->Next;

        Depth++;

        return tmp_LL;
    }

    //Resets the linked list.
    void reset()
    {
        c_Charging_Linked_List* tmp_LL = Root;
        Root = NULL;
        c_Charging_Linked_List* tmp_LL_Next = NULL;

        while (tmp_LL != NULL)
        {
            tmp_LL_Next = tmp_LL->Next;
            tmp_LL->Next = NULL;
            tmp_LL->Previous = NULL;
            delete tmp_LL;
            tmp_LL = NULL;
            tmp_LL = tmp_LL_Next;
        }

        if (Root != NULL) { delete Root; }
        Root = NULL;
        Current_LL = &Root;

        Depth = 0;
    }

    //Outputs the linked list.
    void output()
    {
        c_Charging_Linked_List* tmp_LL = Root;
        
        c_Charging_Linked_List* tmp_LL_Next = NULL;

        std::cout << "\n ----Charging_Linked_List:";
        while (tmp_LL != NULL)
        {
            tmp_LL_Next = tmp_LL->Next;

            //Hmm, might change the tmp_LL->NID to a different name so it isn't NID->NID
            std::cout << "\n   -";
            
            std::cout << tmp_LL->NID->NID;

            std::cout << "\n";

            tmp_LL->NID->bp_O();

            tmp_LL = tmp_LL_Next;
        }
    }
};


class c_Charging_Buffer_Node
{
    friend class c_Charging_Buffer_Tree;
private:

    c_Charging_Buffer_Node* Right;
    c_Charging_Buffer_Node* Center;
    c_Charging_Buffer_Node* Left;

public:

    uint64_t Data;

    c_Charging_Linked_List* LL; 

    c_Charging_Buffer_Node()
    {
        Right = NULL;
        Center = NULL;
        Left = NULL;
        LL = NULL;
        Data = 0;
    }

    ~c_Charging_Buffer_Node()
    {
        LL = NULL;
        delete Right; Right = NULL;
        delete Center; Center = NULL;
        delete Left; Left = NULL;
    }

};

class c_Charging_Buffer_Tree
{
private:


public:
    c_Charging_Buffer_Node* Root;
    c_Charging_Buffer_Node** Current;//the current node that will allow referencing outside of the search function
    bool flg_Foundit;//the flag that set when a node is found already set

    //For handling the current search.
    uint64_t tmp_Data;
    uint64_t tmp_SData;

    c_Charging_Buffer_Tree()
    {
        Root = NULL;
        Current = NULL;
        flg_Foundit = false;

        tmp_Data = 0;
        tmp_SData = 0;
    }

    ~c_Charging_Buffer_Tree()
    {
        delete Root;
    }

    void init()
    {
        Root = NULL;
        Current = NULL;
        flg_Foundit = false;
    }

    //Now returning whether or not the node was found as the foundit flag does not work with multiple threads.
    //This returns the node at the end of the chain, whether it was found or not does not matter the 
    //buffer node is returned and has to be checked for values.
    c_Charging_Buffer_Node* search(c_Node* p_Data)
    {
        flg_Foundit = false;

        if (p_Data == NULL) { Current = NULL; return NULL; }

        uint64_t tmp_SSData;
        tmp_SSData = uint64_t(p_Data);



        //--std::cout << "\n\n SEARCHING ->" << tmp_SData.U;
        //system("PAUSE > NULL");
        return query_Node(Root, tmp_SSData, 31);
    }

    c_Charging_Buffer_Node* query_Node(c_Charging_Buffer_Node*& p_Node, uint64_t p_Data, int p_Shift)
    {
        //These are used because we have to be carefull not to leave Mutex locked with a return.
        c_Charging_Buffer_Node* tmp_Return = NULL;
        bool flg_Done = false;

        uint64_t tmp_DData;
        tmp_DData = p_Data;
        tmp_DData = tmp_DData >> p_Shift;
        //--std::cout << "\n\n\n tmp_DData.U = " << tmp_DData.U << " p_Shift = " << p_Shift;


        //--std::cout << "\n\n\t __QN__ tmp_DData.U->" << tmp_DData.U << " p_Data.U->" << p_Data.U;

        if (p_Node == NULL)
        {
            //--std::cout << "\n\t   Node is NULL";
            p_Node = new c_Charging_Buffer_Node;
            p_Node->Right = NULL;
            p_Node->Center = NULL;
            p_Node->Left = NULL;
            if (p_Shift > 1)
            {
                //--std::cout << "\n\t   tmp_DData.U > 1";
                p_Node->Data = tmp_DData;
            }
            else
            {
                //--std::cout << "\n\t   tmp_DData.U !> 1";
                p_Node->Data = p_Data;
                Current = &p_Node;
                flg_Foundit = false;
                tmp_Return = p_Node;
                flg_Done = true;
                //return 0;
            }
        }

        //If the node was not found then return NULL;
        if (flg_Done) { return tmp_Return; }

        //If the current data matches the tmp data then another depth is explored.
        if (p_Node->Data == tmp_DData && p_Shift > 0)
        {
            //--std::cout << "\n\t   p_Node->Data.U (" << p_Node->Data.U << ") == tmp_DData.U (" << tmp_DData.U << ")";

            //--std::cout << "\t tmp_DData.U = " << tmp_DData.U;

            return query_Node(p_Node->Center, p_Data, (p_Shift - 1));
        }

        //If the node data matches the given data exactly the node has been found.
        //This is not locked because even if the Current & flg_Foundit are overwritten they will not be
        //used by the threads, but will work with the standard single thread.
        if (p_Node->Data == p_Data)
        {
            //--std::cout << "\n\t    p_Node->Data.NR(" << p_Node->Data.NR << ") == p_Data.NR(" << p_Data.NR << ")";
            Current = &p_Node;
            flg_Foundit = true;
            tmp_Return = p_Node;
            flg_Done = true;
            //return 1;
        }

        //If the node was found then return tmp_Return;
        if (flg_Done) { return tmp_Return; }

        if (tmp_DData < p_Node->Data)
        {
            //--std::cout << "\n\t    tmp_DData.U (" << tmp_DData.U << ") < p_Node->Data.U(" << p_Node->Data.U << ")";
            return query_Node(p_Node->Left, p_Data, p_Shift);
        }
        if (tmp_DData > p_Node->Data)
        {
            //--std::cout << "\n\t    tmp_DData.U (" << tmp_DData.U << ") > p_Node->Data.U(" << p_Node->Data.U << ")";
            return query_Node(p_Node->Right, p_Data, p_Shift);
        }
        return tmp_Return;
    }

    void output_Tree()
    {
        output_Node(Root, 0);
    }

    void output_Node(c_Charging_Buffer_Node*& p_Node, int p_Tab)
    {
        if (p_Node == NULL) { return; }
        output_Node(p_Node->Left, (p_Tab));
        //---std::cout << "\n";
        for (int cou_Index = 0; cou_Index < p_Tab; cou_Index++)
        {
            //---std::cout << "  ";
        }
        //---std::cout << p_Node->Data;
        if (p_Node->LL != NULL) { std::cout << "->" << p_Node->LL->NID->NID; }
        output_Node(p_Node->Center, (p_Tab + 1));
        output_Node(p_Node->Right, (p_Tab));
    }

    c_Charging_Linked_List* get_Node_LL(c_Charging_Buffer_Node*& p_Node)
    {
        if (p_Node != NULL) {
            return p_Node->LL;
        }
        else {
            return NULL;
        }
    }

    void set_Node_LL(c_Charging_Buffer_Node*& p_Node, c_Charging_Linked_List* p_LL)
    {
        if (p_Node != NULL)
        {
            p_Node->LL = p_LL;
        }
    }

    c_Charging_Linked_List* set_Current_Node_LL(c_Charging_Linked_List* p_LL)
    {
        set_Node_LL(*Current, p_LL);
        return p_LL;
    }

    c_Charging_Linked_List* get_Current_Node_LL()
    {
        return get_Node_LL(*Current);
    }


    //Resets the tree.
    void reset()
    {
        delete Root;
        Root = NULL;

        Current = NULL;
        flg_Foundit = false;
    }

};



//The class that houses the charging buffer tree and the LL.
class c_Charging_Buffer
{
private:

public:

    //The search tree.
    c_Charging_Buffer_Tree Tree;

    //The linked lists.
    c_Charging_Linked_List_Handler Current_Charge;

    c_Charging_Linked_List_Handler Output;

    c_Charging_Linked_List_Handler Treetops;

    //The treetop tree. What a stupid name.
    c_Charging_Buffer_Tree Treetop_Tree;

    //Flags
    bool flg_Not_Done;

    int Input_Position;

    //Settings & trackers for the settings.
    float Base_Charge;
    float Current_Highest_Charge;
    float Previous_Highest_Charge;
    float Treetops_Highest_Charge;

    float Modifier_Charge;
    float Action_Potential_Threshold;
    float RC_Limiter;

    c_Charging_Buffer()
    {
        flg_Not_Done = 0;
        Input_Position = 0;

        Current_Highest_Charge = 0;
        Treetops_Highest_Charge = 0.0;
        Base_Charge = 10.00;
        Previous_Highest_Charge = Base_Charge;
        Modifier_Charge = 1.0f;
        Action_Potential_Threshold = 0.0f;
        RC_Limiter = Base_Charge;
    }

    ~c_Charging_Buffer()
    {
        Current_Charge.reset();
        Output.reset();
        Treetops.reset();
        Treetop_Tree.reset();
    }

    void reset()
    {
        Current_Charge.reset();
        Output.reset();

        //reset_Treetops();

        flg_Not_Done = 0;
        Input_Position = 0;
    }

    void reset_Treetops()
    {
        Treetops.reset();
        Treetop_Tree.reset();
        Treetops_Highest_Charge = 0.0;
    }

    //Hyperparameters
    void set_Base_Charge(float p_Base_Charge)
    {
        Base_Charge = p_Base_Charge;
    }

    void set_Modifier_Charge(float p_Modifier_Charge)
    {
        Modifier_Charge = p_Modifier_Charge;
    }

    void set_Action_Potential_Threshold(float p_Action_Potential_Threshold)
    {
        Action_Potential_Threshold = p_Action_Potential_Threshold;
    }

    void set_RC_Limiter(float p_RC_Limiter)
    {
        RC_Limiter = p_RC_Limiter;
    }

    float get_Base_Charge()
    {
        return Base_Charge;
    }

    float get_Modifier_Charge()
    {
        return Modifier_Charge;
    }

    float get_Action_Potential_Threshold()
    {
        return Action_Potential_Threshold;
    }

    float get_RC_Limiter()
    {
        return RC_Limiter;
    }

    float get_Treetops_Highest_Charge()
    {
        return Treetops_Highest_Charge;
    }

    //=====--            --=====//
    //==--     CHARGING     --==//
    //=====--            --=====//


    //--  CHARGING FOR ORIGINAL ALGO, USED FOR MSC WHERE ALL PATTERNS ARE TO BE FOUND

    //Charges the outputs back into the charging buffer.
    // //Reinstated the leg charging at this level, this is for charging nodes based on their position, so a state tier node at position 2 charges only axon hillock 2
    // 
    // -The Following doesn't apply as the method was moved to CAN level leg firing order arrays. Left these comments as the CAN method limits each node to one charging type per charge so it may be reinstated in the future.
    // --By keeping the leg charging localized to the parameter we can allow different charging methods to be used on the same node during the same run. I don't know why yet, but this preserves that functionality.
    // --The leg charging determines the hillock to charge by iterating through it.
    //void charge_Outputs(int * p_Flg_Leg_Charging, int p_Flg_Leg_Charging_Count)
    void charge_Outputs()
    {
        c_Charging_Linked_List* tmp_LL = Output.Root;

        Previous_Highest_Charge = Current_Highest_Charge;
        Current_Highest_Charge = 0;

        float tmp_Charge = 0;
        float tmp_Charge_Percentage = 0.0f;
        float tmp_RC = 0.0f;

        while (tmp_LL != NULL)
        {
            tmp_Charge = 0.0;
            tmp_Charge_Percentage = 0.0;

            if (tmp_LL->NID == NULL) { tmp_LL = tmp_LL->Next; continue; }

            //---std::cout << "\n tmp_Charge_Percentage " << tmp_Charge_Percentage << " = ((tmp_LL->Charge " << tmp_LL->Charge << "  * Modifier_Charge " << Modifier_Charge << " ) / Previous_Highest_Charge " << Previous_Highest_Charge << " );";
            /*
            if (tmp_RC > RC_Limiter) { tmp_RC = RC_Limiter; }
            tmp_RC = tmp_LL->NID->RC * (1 - (tmp_LL->NID->RC / RC_Limiter));
            if (tmp_RC < 0) { tmp_RC = 0; }

            tmp_Charge_Percentage = (((tmp_LL->Charge + tmp_RC) * Modifier_Charge) / Previous_Highest_Charge);
            */
            tmp_Charge_Percentage = (((tmp_LL->Charge) * Modifier_Charge) / Previous_Highest_Charge);
            
            //---std::cout << "\n --- tmp_Charge_Percentage " << tmp_Charge_Percentage << " = ((tmp_LL->Charge " << tmp_LL->Charge << "  * Modifier_Charge " << Modifier_Charge << " ) / Previous_Highest_Charge " << Previous_Highest_Charge << " );";
            tmp_Charge = float(tmp_Charge_Percentage * Base_Charge);

            tmp_LL->NID->Charge = tmp_Charge;

            if (tmp_Charge < (Base_Charge * Action_Potential_Threshold)) { tmp_LL = tmp_LL->Next; continue; }

            //We use leg index selection instead of L/R
            for (int cou_H = 0; cou_H < tmp_LL->NID->Axon_Hillock_Count; cou_H++)
            {
                for (int cou_A = 0; cou_A < tmp_LL->NID->Axon_Count[cou_H]; cou_A++)
                {
                    //submit(tmp_LL->NID->Axons[cou_H][cou_A], tmp_Charge);

                    //---std::cout << "\n NID " << tmp_LL->NID->NID << " Axons[ " << cou_H << " ][ " << cou_A << " ]->Dendrite_Weights[ " << cou_A << " ] " << tmp_LL->NID->Axons[cou_H][cou_A]->Dendrite_Weights[cou_H];

                    //This is for the float legged node charging, may separate out in the future as not all nodes need to do this.
                    submit(tmp_LL->NID->Axons[cou_H][cou_A], (tmp_Charge * tmp_LL->NID->Axons[cou_H][cou_A]->Dendrite_Weights[cou_H]));
                }
            }

            if (tmp_LL->NID->Axon_Hillock_Count == 0)
            {
                submit_Treetop((tmp_LL->NID), (tmp_Charge));

            }

            tmp_LL = tmp_LL->Next;
        }
    }

    //=====--                   --=====//
    //==--     SUBMISSION NODE     --==//
    //=====--                   --=====//

    //Accepts a submission of nodes to charge, charges the given leg. Used mainly for Chrono.
    //Use this then gather and begin charging loop.
    void charge_Given_Leg(c_Node* p_Node, float p_Charge = 10.00, int p_Leg = 0)
    {
        p_Node->Charge = p_Charge;

        //Search for the submitted node, if found add the charge.
        if (p_Leg < p_Node->Axon_Hillock_Count)
        {
            //This shouldn't run if the axon count is 0, meaning if the Axons[p_Leg] == NULL it will be fine.
            for (int cou_A = 0; cou_A < p_Node->Axon_Count[p_Leg]; cou_A++)
            {
                submit(p_Node->Axons[p_Leg][cou_A], p_Charge);
                //---std::cout << "\n ~[" << p_Leg << "][" << cou_A << "]~  A->" << p_Node->Axons[p_Leg][cou_A];
                //---p_Node->Axons[p_Leg][cou_A]->bp_O();
            }
        }
        else
        {
            //---std::cerr << "\n \\(o.O)--  Error: p_Leg (" << p_Leg << ") Exceeds p_Node::Axon_Hillock_Count...";
            //---p_Node->output_Node_Raw();
            //---std::cout << " Pattern: ";
            //---p_Node->bp_O();
        }
    }

    //Accepts a submission of nodes to charge, charges the given legs. Used mainly for Chrono.
    //Use this then gather and begin charging loop.
    //It is assumed p_Leg is the same depth as the input.
    void charge_Given_Legs(c_Node* p_Node, int p_Leg_Count, int* p_Leg, float p_Charge = 10.00)
    {
        if (p_Node != NULL)
        {
            int tmp_Top = p_Node->Axon_Hillock_Count;
            if (tmp_Top > p_Leg_Count) { tmp_Top = p_Leg_Count; }

            for (int cou_H = 0; cou_H < tmp_Top; cou_H++)
            {
                if (p_Leg[cou_H])
                {
                    //This shouldn't run if the axon count is 0, meaning if the Axons[p_Leg] == NULL it will be fine.
                    for (int cou_A = 0; cou_A < p_Node->Axon_Count[cou_H]; cou_A++)
                    {
                        submit(p_Node->Axons[cou_H][cou_A], p_Charge);
                        //---std::cout << "\n ~[" << cou_H << "][" << cou_A << "]~  A->" << p_Node->Axons[cou_H][cou_A];
                        //---p_Node->Axons[cou_H][cou_A]->bp_O();
                    }
                }
            }
        }
    }

    //=====--              --=====//
    //==--     SUBMISSION     --==//
    //=====--              --=====//

    //Accepts a submission of nodes to charge, used for CAN.
    void submit(c_Node* p_Node, float p_Charge = 10.00)
    {
        if (p_Node == NULL) { std::cerr << "\n (o.O) Error! p_Node is NULL to submit!"; }

        //Search for the submitted node, if found add the charge.
        Tree.search(p_Node);

        if (Tree.flg_Foundit)
        {
            (Tree.get_Current_Node_LL())->Charge += p_Charge;
            if ((Tree.get_Current_Node_LL())->Charge > Current_Highest_Charge) { Current_Highest_Charge = (Tree.get_Current_Node_LL())->Charge; }
        }

        if (!Tree.flg_Foundit && p_Node != NULL)
        {
            if (p_Charge > Current_Highest_Charge) { Current_Highest_Charge = p_Charge; }

            Tree.set_Current_Node_LL(Current_Charge.new_LL(p_Node, p_Charge));
        }
    }
    
    void submit_Treetop(c_Node* p_Node, float p_Charge)
    {
        if (p_Node == NULL) { std::cerr << "\n (O.O) Error! p_Node is NULL to submit_Treetop!"; }

        //---std::cout << "\n [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]  ~~~ submit_Treetop " << p_Node << " p_Charge " << p_Charge;

        //Search for the submitted node, if found add the charge.
        Treetop_Tree.search(p_Node);

        if (Treetop_Tree.flg_Foundit)
        {
            (Treetop_Tree.get_Current_Node_LL())->Charge += p_Charge;
        }

        if (!Treetop_Tree.flg_Foundit && p_Node != NULL)
        {
            Treetop_Tree.set_Current_Node_LL(Treetops.new_LL(p_Node, p_Charge));
        }

        if ((Treetop_Tree.get_Current_Node_LL())->Charge > Treetops_Highest_Charge)
        { 
            Treetops_Highest_Charge = (Treetop_Tree.get_Current_Node_LL())->Charge; 
        }

        //---std::cout << "   ~~~ flg_foundit " << Treetop_Tree.flg_Foundit << " Treetops.charge " << (Treetop_Tree.get_Current_Node_LL())->Charge;
    }

    //=====--             --=====//
    //==--     GATHERING     --==//
    //=====--             --=====//

    //For gathering the Opp
    //>Target Tier - 1
    //>charge
    //>gather
    //>flush(Target_Tier)

    //Gathers the output nodes and resets the tree for the next iteration.
    void gather()
    {
        //Delete the old Output.
        Output.reset();

        //Reassign the linked lists.
        Output.Root = Current_Charge.Root;
        Output.Depth = Current_Charge.Depth;

        Current_Charge.Root = NULL;
        Current_Charge.reset();

        //Delete the tree.
        Tree.reset();

        //Sets the done flag if Output == NULL.
        flg_Not_Done = 1;
        if ((Output.Root == NULL)) { flg_Not_Done = 0; }
    }

    //Charges the outputs back into the charging buffer.
    float gather_Treetopss()
    {
        std::cout << "\n\n\n\n\n\n gather_Treetops()";
        c_Charging_Linked_List* tmp_LL = Treetops.Root;
        c_Charging_Linked_List_Handler tmp_Treetops_LLH;;
        tmp_Treetops_LLH.Root = Treetops.Root;

        float tmp_Current_Highest_Charge = 0;

        float tmp_Charge = 0;

        //Find the current highest charge.
        while (tmp_LL != NULL)
        {
            if (tmp_LL->NID == NULL) { tmp_LL = tmp_LL->Next; continue; }

            if (tmp_Current_Highest_Charge < tmp_LL->Charge) { tmp_Current_Highest_Charge = tmp_LL->Charge; }

            tmp_LL = tmp_LL->Next;
        }

        std::cout << "\n Treetop_Count: " << Treetops.Depth;

        Treetops.Root = NULL;
        tmp_LL = tmp_Treetops_LLH.Root;

        while (tmp_LL != NULL)
        {
            if (tmp_LL->NID == NULL) { tmp_LL = tmp_LL->Next; continue; }

            std::cout << "\n  ------------ [" << tmp_LL->NID->NID << "] " << tmp_LL->Charge;

            tmp_Charge = (((tmp_LL->Charge * Modifier_Charge) / tmp_Current_Highest_Charge) * Base_Charge);

            std::cout << " ------- " << tmp_Charge;
            std::cout << " < " << (Base_Charge * Action_Potential_Threshold);
            if (tmp_Charge < (Base_Charge * Action_Potential_Threshold)) { std::cout << " XXXXXX "; tmp_LL = tmp_LL->Next; continue; }


            Treetops.new_LL(tmp_LL->NID, (tmp_Charge));

            tmp_LL = tmp_LL->Next;
        }

        tmp_Treetops_LLH.reset();
        Treetop_Tree.reset();
        Treetops.reset();

        return tmp_Current_Highest_Charge;
    }

    //=====--                       --=====//
    //==--     CLEANUP & ALLOCATION    --==//
    //=====--                       --=====//


    //Destroys the output buffers.
    void destroy_Output_Buffers()
    {
        //Delete the old Output.
        Output.reset();
    }

    //=====--          --=====//
    //==--     OUTPUT     --==//
    //=====--          --=====//

    //Outputs all of the buffers.
    void output_All_Buffers()
    {
        //system("CLS");
        std::cout << "\n Charge_LL->" << Current_Charge.Depth << " ->";
        output_Charge_LL();
        std::cout << "\n Output_LL->" << Output.Depth << " ->";
        output_Output_LL();
        std::cout << "\n Treetops->" << Treetops.Depth << " ->";
        output_Treetops();
        std::cout << "\n Treetop_Tree: \n";
        output_Treetop_Tree();
    }

    //Outputs the buffer.
    void output_Tree()
    {
        Tree.output_Tree();
    }

    //Outputs the buffer.
    void output_Treetop_Tree()
    {
        Treetop_Tree.output_Tree();
    }

    //Outputs the Current_Charge_LL.
    void output_Charge_LL()
    {
        //---std::cout << "\n\t Current_Charge_LL->";
        if (Current_Charge.Root == NULL) { std::cout << "empty..."; return; }
        Current_Charge.Root->output_LL();
        //---std::cout << " ~Fing"; std::cout.flush();
    }

    //Outputs the Output_LL.
    void output_Output_LL()
    {
        //---std::cout << "\n\t Output_LL->";
        if (Output.Root == NULL) { std::cout << "empty..."; return; }
        Output.Root->output_LL();
        //---std::cout << " ~Fing"; std::cout.flush();
    }

    //Outputs the Treetops.
    void output_Treetops()
    {
        std::cout << "\n\t Treetops_LL->";
        if (Treetops.Root == NULL) { std::cout << "empty..."; return; }
        //Treetops.Root->output_LL();
        Treetops.output();
        //---std::cout << " ~Fing"; std::cout.flush();
    }
};


//The Current Active Node Scaffold for Trace Encoding (CAN) is the scaffold we use to iteratively encode traces.
//For example, a network with an I/O depth of 5 and a single tier w/ one 5 legged node may look like this:
// Memory_Tier[1]: [0] //The top node, represents one permutation of the input tier. Multiple Memory tiers.
// The memory tiers start at [1] since the State tier is technically Memory tier [0].
// State_Tier (0): [0] [1] [2] [3] [4] //This is the tier with the states. 
// Each [] represents a pointer to a node. We iterate from bottom to top, using get_State_Node,
// and get_Upper_Tier_Node() to fill it out tier by tier.

//--Not using a polymorphic base class here, different CANs may have wildly different features.
//--Once enough are written then we can go back and write one if need be.
//Scratch that, making a base class so that when an assembly is registered a CAN can (hue hue hue) be chosen and function as the interface.

//This is the base class for a CAN. It has the input, encode, and outputs.
class c_Base_CAN //Man
{
public:

	//The reference to the node network to query for nodes.
	c_Node_Network* NNet;

	//This is the index in the c_Node_Network::State_Nodes[] array to request from.
	int State_Nodes_Index;

	//The inputs for the CAN, they are uint64_t internally, the data is not modified so as long as the correct interface is used then none will be lost.
	//uint64_t* Input;
	//int Input_Depth;
	c_IO_Set Input;
	c_2D_IO_Set Input_2D;
	c_3D_IO_Set Input_3D;
	std::vector<float> Input_Charging_Mask;

	//The output is an array of traces retrieved from charging the buffers.
	std::vector<c_Trace> Output;
	c_2D_Trace* Output_2D;
	c_3D_Trace* Output_3D;
	int Output_Depth_2D;
	int Output_Depth_3D;

	//The buffer used during charging.
	c_Charging_Buffer tmp_Buffman;

	//This hyperparameter is used for the pyramidal constructs, or those with multiple layers. The network will start charging on this tier to filter out less associated dirty sub-symbols.
	int Charging_Tier;

	//These may vary wildly depending on the CAN structure, the scaffold will be completely internal.
	//Because of this we will declare the actual scaffold in the derived classes rather than here.
	//c_Node** Scaffold[2];
	//int State_Depth; //We track this so that if the input is changed we can still properly delete the scaffold.

	//==--   Member functions   --==//

	//This is called in the CAN constructor when you write it, this initializes all shared vars.
	void init()
	{
		NNet = NULL;

		Input.reset();
		Input_2D.reset();
		Input_3D.reset();

		Output_2D = NULL;
		Output_Depth_2D = 0;
		Output_3D = NULL;
		Output_Depth_3D = 0;

		State_Nodes_Index = 0;

		//HYPERRRRRRRRRRRRRRRRRRRRRRRRRR
		Charging_Tier = 0;

		Output.clear();
	}

	//Wipe the input array.
	void reset_Input()
	{
		Input.reset();
		Input_2D.reset();
		Input_3D.reset();
	}

	void reset_Output()
	{
		Output.clear();

		if (Output_2D != NULL) { delete[] Output_2D; Output_2D = NULL; }
		Output_Depth_2D = 0;
		if (Output_3D != NULL) { delete[] Output_3D; Output_3D = NULL; }
		Output_Depth_3D = 0;

		tmp_Buffman.reset();
	}

	int get_Output_Depth()
	{
		if (get_Dimension() == 1)
		{
			return int(Output.size());
		}
		if (get_Dimension() == 2)
		{
			return Output_Depth_2D;
		}
		if (get_Dimension() == 3)
		{
			return Output_Depth_3D;
		}
		return 0;
	}

	c_Trace * get_Output(const int p_Output)
	{
		if (p_Output > Output.size()) { std::cerr << "\n\n   V(>.>)--  Error: trace * get_Output size " << Output.size() << " is less than requested output : " << p_Output; }
		return &(Output[p_Output]);
	}

	void allocate_Output(const int p_Output_Depth, const int p_Dimension)
	{
		if (p_Dimension == 1)
		{
			Output.clear();
			Output.resize(p_Output_Depth);
		}
		if (p_Dimension == 2)
		{
			if (Output_2D != NULL) { delete[] Output_2D; Output_2D = NULL; }

			Output_2D = new c_2D_Trace[p_Output_Depth];
			Output_Depth_2D = p_Output_Depth;
		}
		if (p_Dimension == 3)
		{
			if (Output_3D != NULL) { delete[] Output_3D; Output_3D = NULL; }

			Output_3D = new c_3D_Trace[p_Output_Depth];
			Output_Depth_3D = p_Output_Depth;
		}
	}

	//This encodes the p_Input data, if the nodes aren't found they are created, used for training.
	virtual void encode()=0;

	//This sets up the scaffold as encode does, but it doesn't create nodes if they aren't found, they remain NULL in the scaffold, this we call a NULLCAN
	//Used for querying the network, you input, fill the NULLCAN, charge the network, then gather the outputs.
	//Suggested for use before encoding (if using learning mode and not locked_to_initial_training_mode) otherwise it will also find the current trace as the perfect match.
	virtual void query(int p_Charging_Style = -1, int p_Leg = 0, int* p_Legs = NULL)=0;

	virtual void check_Symbol()=0;

	//This allows for passing unordered sets of nodes
	virtual void submit_Set(uint64_t* p_Input, int p_Depth)=0;

	//This returns the treetop node at a given index, for most structures this will be a single node, but for those like stiched-base networks with a treetop node count equal to the input node count then you can access them by index.
	virtual c_Node* get_Treetop(int p_Index = 0)=0;

	//This outputs the symbols each node represents. Currently only works with 1D output.
	//p_Type: 0 = char, 1 = uint64_t
	virtual void output_Scaffold_Symbols(int p_Type = 0)=0;
	
	//Calculates and returns the number of current treetops.
	int get_Output_Depth(int p_Index, int p_Dimension)
	{
		if (p_Dimension == 1) { return int(Output.size()); }
		if (p_Dimension == 2) { return Output_Depth_2D; }
		if (p_Dimension == 3) { return Output_Depth_3D; }
	}

	//Returns the dimension of the data.
	virtual int get_Dimension() = 0;
	
	//Gets a single trace from a given node. Puts it into the output.
	virtual void gather_Given_Trace(uint64_t p_NID)=0;
	
	virtual void gather_All_Traces()=0;

	//Gathers the treetops, used to be at the end of query but decoupled for complex searches.
	virtual void gather_Treetops()=0;

	virtual void backpropagate_NID_Into_Given_Index(uint64_t p_NID, int p_Index, float p_Charge) = 0;

	void set_Input_Charging_Mask(std::vector<float> p_Input_Charging_Mask)
	{
		Input_Charging_Mask = p_Input_Charging_Mask;
	}

	void chrono_Shift()
	{
		for (int cou_Index = 0; cou_Index < (Input.Depth - 1); cou_Index++)
		{
			Input.set_Value(Input.get_Value(cou_Index + 1), cou_Index);
		}
		Input.set_Value(0, (Input.Depth - 1));
	}

	void add_Chrono(uint64_t p_Chrono)
	{
		/*
		for (int cou_Index = (Input.Depth - 1); cou_Index > 0; cou_Index--)
		{
			Input.set_Value(Input.get_Value(cou_Index - 1), cou_Index);
		}*/
		for (int cou_Index = 0; cou_Index < (Input.Depth - 1); cou_Index++)
		{
			Input.set_Value(Input.get_Value(cou_Index + 1), cou_Index);
		}
		Input.set_Value(p_Chrono, (Input.Depth - 1));
	}

	//Hyperparams
	void set_Base_Charge(float p_Base_Charge)
	{
		tmp_Buffman.set_Base_Charge(p_Base_Charge);
	}

	void set_Modifier_Charge(float p_Modifier_Charge)
	{
		tmp_Buffman.set_Modifier_Charge(p_Modifier_Charge);
	}

	void set_Action_Potential_Threshold(float p_Action_Potential_Threshold)
	{
		tmp_Buffman.set_Action_Potential_Threshold(p_Action_Potential_Threshold);
		//std::cout << "\n Setting Action_Potential_Threshold to " << p_Action_Potential_Threshold;
		//std::cout << ", currently: " << tmp_Buffman.get_Action_Potential_Threshold();
	}

	void set_Charging_Tier(int p_Charging_Tier)
	{
		Charging_Tier = p_Charging_Tier;
	}

	float get_Base_Charge()
	{
		return tmp_Buffman.get_Base_Charge();
	}

	float get_Modifier_Charge()
	{
		return tmp_Buffman.get_Modifier_Charge();
	}

	float get_Action_Potential_Threshold()
	{
		return tmp_Buffman.get_Action_Potential_Threshold();
	}

	int get_Charging_Tier()
	{
		return Charging_Tier;
	}

	void output_Config()
	{
		std::cout << "\n Config:";
		std::cout << "\n - Charging_Tier: " << Charging_Tier;
		std::cout << "\n - Base_Charge: " << get_Base_Charge();
		std::cout << "\n - Modifier_Charge: " << get_Modifier_Charge();
		std::cout << "\n - Action_Potential_Threshold: " << get_Action_Potential_Threshold();
	}

	//Associate the CAN with a network from which to draw nodes.
	void set_NNet(c_Node_Network* p_NNet)
	{
		NNet = p_NNet;
	}

	//Sets the index for the state_Node_Tree in the c_Node_Network::State_Nodes[]
	void set_State_Nodes_Index(int p_Index)
	{
		std::cout << "\n State_Nodes_Index set to " << p_Index;
		State_Nodes_Index = p_Index;
	}

	//This violates every good practice I know hue hue hue
	union tmp_Union
	{
		char C;
		uint64_t U;
	};

	//Sets the input to the given uint64_t array.
	//The input array is 1D, but for more complex constructs dimensional index slicing is used.
	void set_Input(uint64_t* p_Input, int p_Input_Depth)
	{
		Input.set_Array_Value(p_Input, p_Input_Depth);
	}

	//This is used for setting the input array to reflect a sequence of characters.
	void set_Input_String(std::string p_Input)
	{
		tmp_Union * tmp_Input = NULL;
		uint64_t * tmp_Input_U = NULL;

		tmp_Input = new tmp_Union[p_Input.length()];
		tmp_Input_U = new uint64_t[p_Input.length()];

		for (int cou_Index = 0; cou_Index < p_Input.length(); cou_Index++ )
		{
			tmp_Input[cou_Index].U = 0;
			tmp_Input_U[cou_Index] = 0;
			tmp_Input[cou_Index].C = p_Input[cou_Index];
			tmp_Input_U[cou_Index] = tmp_Input[cou_Index].U;
		}

		Input.set_Array_Value(tmp_Input_U, int(p_Input.length()));

		if (tmp_Input != NULL) { delete[] tmp_Input; }
		tmp_Input = NULL;
		if (tmp_Input_U != NULL) { delete[] tmp_Input_U; }
		tmp_Input_U = NULL;
	}

	//Sets the input to the given uint64_t array.
	//The input array is 1D, but for more complex constructs dimensional index slicing is used.
	void set_2D_Input(uint64_t** p_Input, int p_X_Depth, int p_Y_Depth)
	{
		Input_2D.set_Array_Value(p_Input, p_X_Depth, p_Y_Depth);
	}

	//This is used for setting the input array to reflect a 2d set of characters.
	void set_2D_Input_String(char ** p_Input, int p_X_Depth, int p_Y_Depth)
	{
		tmp_Union** tmp_Input = NULL;
		uint64_t** tmp_Input_U = NULL;

		tmp_Input = new tmp_Union*[p_X_Depth];
		tmp_Input_U = new uint64_t*[p_X_Depth];

		for (int cou_X = 0; cou_X < p_X_Depth; cou_X++)
		{
			tmp_Input[cou_X] = new tmp_Union[p_Y_Depth];
			tmp_Input_U[cou_X] = new uint64_t[p_Y_Depth];

			for (int cou_Y = 0; cou_Y < p_Y_Depth; cou_Y++)
			{
				tmp_Input[cou_X][cou_Y].U = 0;
				tmp_Input_U[cou_X][cou_Y] = 0;
				tmp_Input[cou_X][cou_Y].C = p_Input[cou_X][cou_Y];
				tmp_Input_U[cou_X][cou_Y] = tmp_Input[cou_X][cou_Y].U;
			}

		}

		Input_2D.set_Array_Value(tmp_Input_U, p_X_Depth, p_Y_Depth);

		for (int cou_X = 0; cou_X < p_X_Depth; cou_X++)
		{
			if (tmp_Input[cou_X] != NULL) { delete[] tmp_Input[cou_X]; }
			tmp_Input[cou_X] = NULL;
			if (tmp_Input_U[cou_X] != NULL) { delete[] tmp_Input_U[cou_X]; }
			tmp_Input_U[cou_X] = NULL;
		}
		if (tmp_Input != NULL) { delete[] tmp_Input; }
		tmp_Input = NULL;
		if (tmp_Input_U != NULL) { delete[] tmp_Input_U; }
		tmp_Input_U = NULL;
	}

	//Sets the input to the given uint64_t array.
	//The input array is 1D, but for more complex constructs dimensional index slicing is used.
	void set_3D_Input(uint64_t*** p_Input, int p_X_Depth, int p_Y_Depth, int p_Z_Depth)
	{
		Input_3D.set_Array_Value(p_Input, p_X_Depth, p_Y_Depth, p_Z_Depth);
	}

	//This is used for setting the input array to reflect a 3d set of characters.
	void set_3D_Input_String(char *** p_Input, int p_X_Depth, int p_Y_Depth, int p_Z_Depth)
	{
		tmp_Union*** tmp_Input = NULL;
		uint64_t*** tmp_Input_U = NULL;

		tmp_Input = new tmp_Union**[p_X_Depth];
		tmp_Input_U = new uint64_t**[p_X_Depth];

		for (int cou_X = 0; cou_X < p_X_Depth; cou_X++)
		{
			tmp_Input[cou_X] = new tmp_Union*[p_Y_Depth];
			tmp_Input_U[cou_X] = new uint64_t*[p_Y_Depth];

			for (int cou_Y = 0; cou_Y < p_Y_Depth; cou_Y++)
			{
				tmp_Input[cou_X][cou_Y] = new tmp_Union[p_Z_Depth];
				tmp_Input_U[cou_X][cou_Y] = new uint64_t[p_Z_Depth];

				for (int cou_Z = 0; cou_Z < p_Z_Depth; cou_Z++)
				{
					tmp_Input[cou_X][cou_Y][cou_Z].U = 0;
					tmp_Input_U[cou_X][cou_Y][cou_Z] = 0;
					tmp_Input[cou_X][cou_Y][cou_Z].C = p_Input[cou_X][cou_Y][cou_Z];
					tmp_Input_U[cou_X][cou_Y][cou_Z] = tmp_Input[cou_X][cou_Y][cou_Z].U;
				}
			}
		}

		Input_3D.set_Array_Value(tmp_Input_U, p_X_Depth, p_Y_Depth, p_Z_Depth);

		for (int cou_X = 0; cou_X < p_X_Depth; cou_X++)
		{
			for (int cou_Y = 0; cou_Y < p_Y_Depth; cou_Y++)
			{
				if (tmp_Input[cou_X][cou_Y] != NULL) { delete[] tmp_Input[cou_X][cou_Y]; }
				tmp_Input[cou_X][cou_Y] = NULL;
				if (tmp_Input_U[cou_X][cou_Y] != NULL) { delete[] tmp_Input_U[cou_X][cou_Y]; }
				tmp_Input_U[cou_X][cou_Y] = NULL;
			}
			if (tmp_Input[cou_X] != NULL) { delete[] tmp_Input[cou_X]; }
			tmp_Input[cou_X] = NULL;
			if (tmp_Input_U[cou_X] != NULL) { delete[] tmp_Input_U[cou_X]; }
			tmp_Input_U[cou_X] = NULL;
		}
		if (tmp_Input != NULL) { delete[] tmp_Input; }
		tmp_Input = NULL;
		if (tmp_Input_U != NULL) { delete[] tmp_Input_U; }
		tmp_Input_U = NULL;
	}


	int get_Top(c_Linked_List_Handler* p_Pattern_N)
	{
		int tmp_Top_X = 0;

		//We can iterate through given we know how big the linked list is.
		c_Linked_List* tmp_LL_Pat_X = p_Pattern_N->Root;

		for (int cou_Index = 0; cou_Index < p_Pattern_N->Depth; cou_Index++)
		{
			if (tmp_LL_Pat_X->Quanta >= tmp_Top_X)
			{
				//+1 as we want the depth, not the furthest index.
				tmp_Top_X = int(tmp_LL_Pat_X->Quanta + 1);
			}
			tmp_LL_Pat_X = tmp_LL_Pat_X->Next;
		}

		return tmp_Top_X;
	}

	//==--   Output Functions   --==//

	//Outputs the scaffold as addresses.
	virtual void output_Scaffold()=0;

	//Outputs the input array.
	void output_Input(int p_Type = 0)
	{
		std::cout << "\n 1D:\n";
		for (int cou_Index = 0; cou_Index < Input.Depth; cou_Index++)
		{
			if (p_Type == 0) { std::cout << "\n [" << cou_Index << "] > " << char(Input.Data[cou_Index]) << " <"; }
			if (p_Type == 1) { std::cout << "\n [" << cou_Index << "] > " << Input.Data[cou_Index] << " <"; }
			if (Input_Charging_Mask.size() > cou_Index) { std::cout << " {" << Input_Charging_Mask[cou_Index] << "}"; }
		}
		std::cout << "\n 2D:\n";
		Input_2D.output();
		std::cout << "\n 3D:\n";
		Input_3D.output();
	}

	//Outputs the input array.
	//p_Type: 0 == char(), 1 == uint64_t (native), 2 == double
	void output_Output(int p_Type = 0)
	{
		std::cout << "\n 1D: " << Output.size() << " 2D: " << Output_Depth_2D << " 3D: " << Output_Depth_3D;
		for (int cou_Output = 0; cou_Output < Output.size(); cou_Output++)
		{
			std::cout << "\n  1D_Trace[" << cou_Output << "]: ";

			//std::cout << " Pat_Depth: " << Output[cou_Output].Depth;
			Output[cou_Output].output(p_Type);
			/*
			for (int cou_Index = 0; cou_Index < Output[cou_Output].Depth; cou_Index++)
			{
				//std::cout << "\n [" << cou_Index << "] ";
				std::cout << " " << Output[cou_Output].Pattern[cou_Index];
			}
			*/
		}
		for (int cou_Output = 0; cou_Output < Output_Depth_2D; cou_Output++)
		{
			std::cout << "\n  2D_Trace[" << cou_Output << "]: ";

			Output_2D[cou_Output].output(p_Type);
			/*
			for (int cou_Index = 0; cou_Index < Output[cou_Output].Depth; cou_Index++)
			{
				//std::cout << "\n [" << cou_Index << "] ";
				std::cout << " " << Output[cou_Output].Pattern[cou_Index];
			}
			*/
		}
		for (int cou_Output = 0; cou_Output < Output_Depth_3D; cou_Output++)
		{
			std::cout << "\n  3D_Trace[" << cou_Output << "]: ";

			Output_3D[cou_Output].output(p_Type);
			/*
			for (int cou_Index = 0; cou_Index < Output[cou_Output].Depth; cou_Index++)
			{
				//std::cout << "\n [" << cou_Index << "] ";
				std::cout << " " << Output[cou_Output].Pattern[cou_Index];
			}
			*/
		}
		//std::cout << "\n   --==   /Output_Traces   ==--";
	}

	virtual void output_Scaffold_Tops()=0;

	//Each address is typecast to a char to give a pseudo-unique look to each node. For monke brain.
	virtual void output_Scaffold_Char()=0;
};

//This functions to create a trace where all legs are connected to one node.
//Load up the input, hit encode(), boom you single permutation of all legs bound to that node.
//Most useful when each index in the input is a separate state space from the other indexes, sensors == good, language == shared states across words !good
class c_CAN_Many_To_One : public c_Base_CAN
{
public:

	//Each CAN node is just a pointer to a node in the network.
	//For this CAN the scaffold is 2 tiers, the bottom being the state tier, and then one node on tier[1] for the treetop/symbol node.
	//So for this CAN we don't track the number of tiers, that is always 2, and the number of nodes is equal to the input depth for the state(quanta) tier, and 1 for the treetop.
	c_Node** Scaffold[2];
	int State_Depth; //We track this so that if the input is changed we can still properly delete the scaffold.

	c_CAN_Many_To_One()
	{
		init();

		Scaffold[0] = NULL;
		Scaffold[1] = new c_Node * [1];
		Scaffold[1][0] = NULL;

		State_Depth = 0;

	}

	~c_CAN_Many_To_One()
	{
		NNet = NULL;
		reset_Scaffold();
		reset_Input();
	}

	//Resets the CAN to NULL, and deletes the state tier + treetop.
	void reset_Scaffold()
	{
		if (Scaffold[0] != NULL)
		{
			//Make sure to NULL the scaffold first.
			//DO NOT DELETE THEM, the addresses are for the node network, deleting them here will cause null pointer deletion in Node_Network.
			for (int cou_Index = 0; cou_Index < State_Depth; cou_Index++)
			{
				Scaffold[0][cou_Index] = NULL;
			}
			delete[] Scaffold[0];
			Scaffold[0] = NULL;
		}
		Scaffold[1][0] = NULL;
	}

	//This sets up the actual CAN scaffold to use.
	//It assumes the input array is filled out, the size is based upon that array.
	void setup_CAN_Scaffold()
	{
		//Take it out back and put it down.
		reset_Scaffold();

		//Sizing her up!
		State_Depth = Input.Depth;

		//Setup the lowest tier of the scaffold so that every index in the input has a correlated state tier node position on the scaffold.
		Scaffold[0] = new c_Node * [State_Depth];

		//Initialize the scaffold.
		for (int cou_Index = 0; cou_Index < State_Depth; cou_Index++)
		{
			Scaffold[0][cou_Index] = NULL;
		}
		Scaffold[1][0] = NULL;
	}

	//This fills the state tier by querying the node network.
	//p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.
	void fill_State(std::string p_How = "Encode")
	{
		if (p_How == "Encode")
		{
			for (int cou_Index = 0; cou_Index < State_Depth; cou_Index++)
			{
				//Request the state node form the node network using get_State_Node so one is created if not found.
				//We have to make sure we request the correct state tree.
				Scaffold[0][cou_Index] = NNet->get_State_Node(State_Nodes_Index, Input.Data[cou_Index]);
				Scaffold[0][cou_Index]->RC++;

				//If the node is also a treetop then set it to state/treetop.
				if ((Scaffold[0][cou_Index]->Type == 2))
				{
					Scaffold[0][cou_Index]->Type = 3;
				}
			}
		}
		if (p_How == "Query")
		{
			for (int cou_Index = 0; cou_Index < State_Depth; cou_Index++)
			{
				//Request the state node form the node network using get_State_Node so one is created if not found.
				//We have to make sure we request the correct state tree.
				Scaffold[0][cou_Index] = NNet->does_State_Node_Exist(State_Nodes_Index, Input.Data[cou_Index]);
			}
		}
	}

	//Just one node at the tippy top.
	//p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.
	void fill_Scaffold(std::string p_How = "Encode")
	{
		if (State_Depth == 0)
		{
			//std::cerr << "\n\n   /(o.O)/ Error: State_Depth is 0.";
			Scaffold[1][0] = NULL;

			return;
		}
		if (p_How == "Encode")
		{
			//We request a node that links the entire state tier together.
			Scaffold[1][0] = NNet->get_Upper_Tier_Node(Scaffold[0], State_Depth, 2, 1);
			Scaffold[1][0]->RC++;
			Scaffold[1][0]->set_Type(2);
		}
		if (p_How == "Query")
		{
			//We request a node that links the entire state tier together, but do not create them.
			Scaffold[1][0] = NNet->does_Upper_Tier_Connection_Exist(Scaffold[0], State_Depth);
		}
	}

	void check_Symbol()
	{
		//Set up the scaffold for the nodes to reside in as we build the trace.
		setup_CAN_Scaffold();

		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Query");

		//Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.
		fill_Scaffold("Query");
	}

	//Encodes a single trace, forcibly.
	void encode()
	{
		//Set up the scaffold for the nodes to reside in as we build the trace.
		setup_CAN_Scaffold();

		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Encode");

		//Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.
		fill_Scaffold("Encode");

		//output_Scaffold_Char(); 
		/*
		if (Scaffold[1][0] != NULL)
		{
			std::cout << "\nTreetop: " << Scaffold[1][0]->NID;
		}
		else
		{
			std::cout << "\nTreetop: NULL";
		}
		*/
	}

	//Style determines whether it charges with normal submission of raw, or if it does the specific leg charging for Chrono.
	//If charging buffer is defined then it will use it up to the index specified.
	void charge_Buffers(int p_Style = -1, int p_Leg = 0, int * p_Legs = NULL)
	{

		tmp_Buffman.reset();

		tmp_Buffman.Input_Position = 0;

		tmp_Buffman.charge_Outputs();

		for (int cou_Input = 0; cou_Input < Input.Depth; cou_Input++)
		{
			if (Scaffold[0][cou_Input] != NULL)
			{
				float tmp_Charge = tmp_Buffman.get_Base_Charge();

				//Check for the charging mask.
				if (Input_Charging_Mask.size() == Input.Depth)
				{
					tmp_Charge = Input_Charging_Mask[cou_Input];
				}

				if (p_Style == -1)
				{
					tmp_Buffman.submit(Scaffold[0][cou_Input], tmp_Charge);
				}
				if (p_Style == 1)
				{
					tmp_Buffman.charge_Given_Leg(Scaffold[0][cou_Input], tmp_Charge, cou_Input);
				}
				if (p_Style == 2)
				{
					//p_Leg specifies which leg to charge in this function, p_Legs[] being unused.
					tmp_Buffman.charge_Given_Leg(Scaffold[0][cou_Input], tmp_Charge, p_Leg);
				}
				if (p_Style == 3)
				{
					//p_Leg is used here as the count of elements in p_Legs[].
					tmp_Buffman.charge_Given_Legs(Scaffold[0][cou_Input], p_Leg, p_Legs, tmp_Charge);
				}
			}
		}

		tmp_Buffman.gather();

		while (tmp_Buffman.flg_Not_Done)
		{
			tmp_Buffman.charge_Outputs();

			tmp_Buffman.gather();
		}
	}

	void gather_Treetops()
	{
		//tmp_Buffman.gather_Treetops();

		float tmp_Charge = 0.0;
		float tmp_H_Charge = tmp_Buffman.get_Treetops_Highest_Charge();
		if (tmp_H_Charge == 0) { tmp_H_Charge = 1.0; }

		c_Charging_Linked_List* tmp_Current_LL = NULL;
		tmp_Current_LL = tmp_Buffman.Treetops.Root;

		Output.clear();
		Output.resize(tmp_Buffman.Treetops.Depth);

		int tmp_Current_Index = 0;

		c_Linked_List_Handler tmp_Pattern;

		c_Linked_List* tmp_LL_Pat = NULL;

		//---std::cout << "\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 0";
		while (tmp_Current_LL != NULL)
		{
			//---std::cout << "\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 1";
			tmp_Pattern.reset();

			//---std::cout << "\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 2 b";
			//Get the pattern into a linked list
			tmp_Current_LL->NID->bp_Trace_O(&tmp_Pattern);

			//Copy the pattern over
			//---std::cout << "\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 3";
			Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);

			tmp_LL_Pat = tmp_Pattern.Root;

			//---std::cout << "\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 4";
			//We can iterate through given we know how big the linked list is.
			for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
			{
				Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);
				tmp_LL_Pat = tmp_LL_Pat->Next;
			}
			
			tmp_Charge = (tmp_Current_LL->Charge / tmp_H_Charge) * get_Base_Charge();

			//---std::cout << "\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 5";
			Output[tmp_Current_Index].set_Charge(tmp_Charge);

			Output[tmp_Current_Index].set_RC(tmp_Current_LL->NID->RC);
			Output[tmp_Current_Index].set_Treetop(tmp_Current_LL->NID);

			//---std::cout << "\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 6";
			tmp_Current_LL = tmp_Current_LL->Next;
			
			tmp_Current_Index++;
		}
		tmp_Pattern.reset();
		tmp_Buffman.reset_Treetops();
	}

	void backpropagate_NID_Into_Given_Index(uint64_t p_NID, int p_Index, float p_Charge)
	{
		c_Linked_List_Handler tmp_Pattern;

		c_Linked_List* tmp_LL_Pat = NULL;

		tmp_Pattern.reset();

		c_Node* tmp_Node = NNet->get_Node_Ref_By_NID(p_NID);

		if (tmp_Node == NULL) { std::cerr << "\n\n   v(o.O)V   Error in backpropagage_NID_Into_Given_Index, Node " << p_NID << " not found!"; return; }

		//Get the pattern into a linked list
		tmp_Node->bp_Trace_O(&tmp_Pattern);

		//Copy the pattern over
		Output[p_Index].set_Depth(tmp_Pattern.Depth);

		tmp_LL_Pat = tmp_Pattern.Root;

		//We can iterate through given we know how big the linked list is.
		for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
		{
			Output[p_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);
			tmp_LL_Pat = tmp_LL_Pat->Next;
		}

		Output[p_Index].set_Charge(p_Charge);

		Output[p_Index].set_RC(tmp_Node->RC);
		Output[p_Index].set_Treetop(tmp_Node);
	}

	//Gets a single trace from a given node. Puts it into the output.
	void gather_All_Traces()
	{
		std::cout << "\n\n Gathering All Traces!!!";



		c_Node* tmp_Node = NULL;
		tmp_Node = NNet->Root;

		Output.clear();

		int tmp_Current_Index = 0;

		c_Linked_List_Handler tmp_Pattern;

		c_Linked_List* tmp_LL_Pat = NULL;

		while (tmp_Node != NULL)
		{
			//---std::cout << "\nNode (" << tmp_Node->NID << ") ";
			//---tmp_Node->bp_O();


			tmp_Pattern.reset();

			//Get the pattern into a linked list
			tmp_Node->bp_Trace_O(&tmp_Pattern);

			//---std::cout << "\n NID: " << tmp_Node->NID;
			//---std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;
			//---tmp_Pattern.output();

			//---std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;
			//Copy the pattern over
			Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);

			//---std::cout << "\n Output[" << tmp_Current_Index << "].Depth: " << Output[tmp_Current_Index].Depth;

			//---std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;

			tmp_LL_Pat = tmp_Pattern.Root;

			//We can iterate through given we know how big the linked list is.
			for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
			{
				Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);
				tmp_LL_Pat = tmp_LL_Pat->Next;
			}

			//std::cout << "\n tmp_Current_LL->NID->Current_Charge: " << tmp_Node->Current_Charge;
			//---std::cout << "\n tmp_Current_LL->NID->RC: " << tmp_Node->RC;
			//Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);
			//Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);
			Output[tmp_Current_Index].set_RC(tmp_Node->RC);
			Output[tmp_Current_Index].set_Treetop(tmp_Node);

			//---Output[tmp_Current_Index].output(0);
			//---Output[tmp_Current_Index].output(1);

			tmp_Current_Index++;

			tmp_Node = tmp_Node->Next;
		}
	}

	//Gets a single trace from a given node. Puts it into the output.
	void gather_Given_Trace(uint64_t p_NID)
	{
		std::cout << "\n\n Gathering Given Trace " << p_NID << "...";

		c_Node* tmp_Node = NULL;
		tmp_Node = NNet->get_Node_Ref_By_NID(p_NID);

		Output.clear();

		int tmp_Current_Index = 0;

		c_Linked_List_Handler tmp_Pattern;

		c_Linked_List* tmp_LL_Pat = NULL;

		tmp_Pattern.reset();

		//Get the pattern into a linked list
		tmp_Node->bp_Trace_O(&tmp_Pattern);

		std::cout << "\n NID: " << tmp_Node->NID;
		std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;
		tmp_Pattern.output();

		//Copy the pattern over
		Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);

		std::cout << "\n Output[" << tmp_Current_Index << "].Depth: " << Output[tmp_Current_Index].get_Output_Pattern_Size();

		std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;

		tmp_LL_Pat = tmp_Pattern.Root;

		//We can iterate through given we know how big the linked list is.
		for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
		{
			Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);
			tmp_LL_Pat = tmp_LL_Pat->Next;
		}

		//std::cout << "\n tmp_Node->Current_Charge: " << tmp_Node->Current_Charge;
		std::cout << "\n tmp_Node->RC: " << tmp_Node->RC;
		//Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);
		//Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);
		Output[tmp_Current_Index].set_RC(tmp_Node->RC);
		Output[tmp_Current_Index].set_Treetop(tmp_Node);

		Output[tmp_Current_Index].output(0);
		Output[tmp_Current_Index].output(1);

		tmp_Current_Index++;
	}


	//Fills out the NULLCAN, does not forcibly encode, and then charges the network.
	//Charging style determines leg charging. May move it to be a setting.
	//     -1: Charge by giving the input node the base charge, normal node charging.
	//      1: Use leg specific charging to charge every node based on its position in the input array. Node[1] would charge axons on Axon[1][n].
	//      2: Charge every input on the given p_Leg, used mainly when inputing single values to charge. Allows you to input Node[x] as the only input to the Chrono and charge it using Axon[4][n], or any axon hillock you choose.
	//		 This allows you to search forward by setting a node early in the time series and searching forwards, or setting it late in the time series and searching backwards.
	void query(int p_Charging_Style = -1, int p_Leg = 0, int * p_Legs = NULL)
	{
		//Set up the scaffold for the nodes to reside in as we build the trace.
		setup_CAN_Scaffold();

		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Query");

		//Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.
		fill_Scaffold("Query");

		charge_Buffers(p_Charging_Style, p_Leg, p_Legs);

		//Decoupling gather_Treetops so that complex queries can be done.
		//gather_Treetops();
	}

	//This allows for passing unordered sets of nodes
	void submit_Set(uint64_t* p_Input, int p_Depth)
	{
		//Firstly we gather the inputly
		set_Input(p_Input, p_Depth);

		//We only do the query on the state tier. This is because the nodes will not be in a coherent relationship to each other, only their presence is important.
		//The node adress being read in as the state means that the unordered set can be read in to the state tier because the shared memory space precludes duplicates, you just ignore any higher tiers than 0.
		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Query");

		//Then charge the buffers as normal.
		charge_Buffers();
	}

	//Gets the current treetop at the given index.
	c_Node* get_Treetop(int p_Index = -1)
	{
		//For this network the treetop is the scaffold[1][0] since all lower nodes link to this higher tier node.
		return Scaffold[1][0];
	}

	//Returns the dimension of the data.
	int get_Dimension()
	{
		return 1;
	}

	//Outputs the scaffold.
	void output_Scaffold()
	{
		std::cout << "\n <- Tier[0] ->";
		for (int cou_Index = 0; cou_Index < State_Depth; cou_Index++)
		{
			if (Scaffold[0][cou_Index] != NULL) { std::cout << " [" << Scaffold[0][cou_Index]->NID << "] "; } else { std::cout << "[NULL]"; }
		}
		std::cout << "\n <- Tier[1] ->";
		if (Scaffold[1][0] != NULL) { std::cout << " [" << Scaffold[1][0]->NID << "]"; } else { std::cout << "[NULL]"; }
	}


	//Outputs the scaffold as character representing the address.
	void output_Scaffold_Char()
	{
		std::cout << "\n";
		std::cout << "[";
		for (int cou_Index = 0; cou_Index < State_Depth; cou_Index++)
		{
			std::cout << static_cast<char>(uint64_t(Scaffold[0][cou_Index]) & 0xFF);
		}
		std::cout << "]";
		std::cout << "\n[" << static_cast<char>(uint64_t(Scaffold[1][0]) & 0xFF)  << "]";
	}

	void output_Scaffold_Tops()
	{

	}


	//Outputs the scaffold as character representing the address. Currently only 1D supports this.
	void output_Scaffold_Symbols(int p_Type = 0)
	{
		std::cout << "\n";
		for (int cou_Index = 0; cou_Index < State_Depth; cou_Index++)
		{
			std::cout << "[";
			if (Scaffold[0][cou_Index] != NULL)
			{
				Scaffold[0][cou_Index]->bp_O(p_Type);
			}
			else
			{
				std::cout << "NULL";
			}
			std::cout << "]";
		}
		std::cout << "\n[";
		if (Scaffold[1][0] != NULL)
		{
			Scaffold[1][0]->bp_O(p_Type);
		}
		else
		{
			std::cout << "NULL";
		}
		std::cout << "]";
	}
};

//This functions to create a trace where all legs are connected to one node.
//Load up the input, hit encode(), boom you single permutation of all legs bound to that node.
//Most useful when each index in the input is a separate state space from the other indexes, sensors == good, language == shared states across words !good
class c_CAN_1D_Pyramid : public c_Base_CAN
{
public:

	//Each CAN node is just a pointer to a node in the network.
	//Scaffold[Tier][Index]
	//Tier_Depth == where T = current tier: (Input_Depth - T)
	c_Node*** Scaffold;

	int State_Depth; //We track this so that if the input is changed we can still properly delete the scaffold.

	c_CAN_1D_Pyramid()
	{
		init();

		Scaffold = NULL;

		State_Depth = 0;
	}

	~c_CAN_1D_Pyramid()
	{
		NNet = NULL;
		reset_Scaffold();
		reset_Input();
	}

	//Resets the CAN to NULL, and deletes the state tier + treetop.
	void reset_Scaffold()
	{
		if (Scaffold != NULL)
		{
			//For every tier
			for (int cou_T = 0; cou_T < State_Depth; cou_T++)
			{
				if (Scaffold[cou_T] != NULL)
				{
					for (int cou_Index = 0; cou_Index < (State_Depth - cou_T); cou_Index++)
					{
						//Make sure to NULL the scaffold first.
						//DO NOT DELETE THEM, the addresses are for the node network, deleting them here will cause null pointer deletion in Node_Network.
						Scaffold[cou_T][cou_Index] = NULL;
					}

					delete[] Scaffold[cou_T];
					Scaffold[cou_T] = NULL;
				}
			}
			delete[] Scaffold;
			Scaffold = NULL;
		}
	}

	//This sets up the actual CAN scaffold to use.
	//It assumes the input array is filled out, the size is based upon that array.
	void setup_CAN_Scaffold()
	{
		//Take it out back and put it down.
		reset_Scaffold();

		//Sizing her up!
		State_Depth = Input.Depth;

		//Define the tiers, the number of tiers to hold a pyramid is equal to the depth of the pattern it represents.
		Scaffold = new c_Node ** [State_Depth];

		//Through the tiers we brings beers.
		for (int cou_T = 0; cou_T < State_Depth; cou_T++)
		{
			//Through the steps Randolph Carter crept.
			Scaffold[cou_T] = new c_Node * [State_Depth - cou_T];

			for (int cou_Index = 0; cou_Index < (State_Depth - cou_T); cou_Index++)
			{
				Scaffold[cou_T][cou_Index] = NULL;
			}
		}
	}

	//This fills the state tier by querying the node network.
	//p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.
	void fill_State(std::string p_How = "Encode")
	{
		//---std::cout << "\n Encoding with State_Nodes_Index: " << State_Nodes_Index;
		if (p_How == "Encode")
		{
			for (int cou_Index = 0; cou_Index < State_Depth; cou_Index++)
			{
				//Request the state node form the node network using get_State_Node so one is created if not found.
				//We have to make sure we request the correct state tree.
				Scaffold[0][cou_Index] = NNet->get_State_Node(State_Nodes_Index, Input.Data[cou_Index]);
				Scaffold[0][cou_Index]->RC++;

				//If the node is also a treetop then set it to state/treetop.
				if ((Scaffold[0][cou_Index]->Type == 2))
				{
					Scaffold[0][cou_Index]->Type = 3;
				}
			}
		}
		if (p_How == "Query")
		{
			for (int cou_Index = 0; cou_Index < State_Depth; cou_Index++)
			{
				//Request the state node form the node network using get_State_Node so one is created if not found.
				//We have to make sure we request the correct state tree.
				Scaffold[0][cou_Index] = NNet->does_State_Node_Exist(State_Nodes_Index, Input.Data[cou_Index]);
			}
		}
	}

	//Just one node at the tippy top.
	//p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.
	void fill_Scaffold(std::string p_How = "Encode")
	{
		if (State_Depth == 0)
		{
			return;
		}
		//---std::cout << "\n State_Depth: " << State_Depth;
		for (int cou_T = 1; cou_T < State_Depth; cou_T++)
		{
			//---std::cerr << "\n T: " << cou_T;
			//The extra -1 is so we don't step to the last node and reach into the void.
			for (int cou_Index = 0; cou_Index < (State_Depth - cou_T); cou_Index++)
			{
				//---std::cerr << " - " << cou_Index;
				if (p_How == "Encode")
				{
					//We request a node that links 2 nodes together.
					Scaffold[cou_T][cou_Index] = NNet->get_Upper_Tier_Node(&(Scaffold[cou_T - 1][cou_Index]), 2, 1, cou_T);
					Scaffold[cou_T][cou_Index]->RC++;
					Scaffold[cou_T][cou_Index]->rectify_Double_Legged_Nodes(); //Only need to do this for tiers 1+ as tier 0 doesn't have dendrites in this CAN.
				}
				if (p_How == "Query")
				{
					//---std::cout << "\n Query: Scaffold[" << cou_T << "][" << cou_Index << "]";
					//We request a node that links the entire state tier together, but do not create them.
					//Scaffold[cou_T][cou_Index] = NNet->does_Upper_Tier_Connection_Exist(&(Scaffold[cou_T][cou_Index]), 2);
					Scaffold[cou_T][cou_Index] = NNet->does_Upper_Tier_Connection_Exist(&(Scaffold[cou_T - 1][cou_Index]), 2);
					//---std::cout << " " << Scaffold[cou_T - 1][cou_Index] << " " << Scaffold[cou_T - 1][cou_Index - 1] << " => " << Scaffold[cou_T][cou_Index];
				}
			}
		}
		if (p_How == "Encode")
		{
			Scaffold[State_Depth - 1][0]->Type = 2;
		}
	}

	void check_Symbol()
	{
		//Set up the scaffold for the nodes to reside in as we build the trace.
		setup_CAN_Scaffold();

		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Query");

		//Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.
		fill_Scaffold("Query");
	}

	//Encodes a single trace, forcibly.
	void encode()
	{
		//---std::cout << "\n\n<<-- Begin Encoding -->>\n\n";

		//Set up the scaffold for the nodes to reside in as we build the trace.
		setup_CAN_Scaffold();

		//---output_Scaffold();

		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Encode");

		//---std::cerr << "\n State Filled.";
		//---output_Scaffold();

		//Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.
		fill_Scaffold("Encode");

		//To be removed later after testing.
		//output_Input();
		//output_Scaffold();
		//output_Scaffold_Char();
		/*
		if (Scaffold[State_Depth - 1][0] != NULL)
		{
			std::cout << "\nTreetop: " << Scaffold[State_Depth - 1][0]->NID;
		}
		else
		{
			std::cout << "\nTreetop: NULL";
		}
		*/
		//---std::cout << "\n\n-- End Encoding --\n\n";
	}

	

	//Style determines whether it charges with normal submission of raw, or if it does the specific leg charging for Chrono.
	//Assumes the CAN is setup.
	void charge_Buffers(int p_Style = -1, int p_Leg = 0, int * p_Legs = NULL)
	{
		tmp_Buffman.reset();

		tmp_Buffman.Input_Position = 0;

		tmp_Buffman.charge_Outputs();

		for (int cou_T = Charging_Tier; cou_T < State_Depth; cou_T++)
		{
			//---std::cout << "\n  ~~~~~~~~~~~~~~~~~~~~~ Charging Tier [" << cou_T << "]";
			for (int cou_Input = 0; cou_Input < (State_Depth - cou_T); cou_Input++)
			{
				if (Scaffold[cou_T][cou_Input] != NULL)
				{
					//---std::cout << "\n             -Scaffold[" << cou_T << "][" << cou_Input << "]";

					if (p_Style == -1)
					{
						tmp_Buffman.submit(Scaffold[cou_T][cou_Input], (tmp_Buffman.get_Base_Charge()));
					}
					if (p_Style == 1)
					{
						tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_Input], (tmp_Buffman.get_Base_Charge()), cou_Input);
					}
					if (p_Style == 2)
					{
						//p_Leg specifies which leg to charge in this function, p_Legs[] being unused.
						tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_Input], (tmp_Buffman.get_Base_Charge()), p_Leg);
					}
					if (p_Style == 3)
					{
						//p_Leg is used here as the count of elements in p_Legs[].
						tmp_Buffman.charge_Given_Legs(Scaffold[cou_T][cou_Input], p_Leg, p_Legs, (tmp_Buffman.get_Base_Charge()));
					}
					if (p_Style == 4)
					{
						tmp_Buffman.submit(Scaffold[cou_T][cou_Input], (tmp_Buffman.get_Base_Charge()));
					}
				}
			}
		}

		//---std::cout << "\n   {{{{{{{ 0 }}}}}}}}";
		//---tmp_Buffman.output_All_Buffers();

		tmp_Buffman.gather();

		//---std::cout << "\n   {{{{{{{ 1 }}}}}}}}";
		//---tmp_Buffman.output_All_Buffers();

		while (tmp_Buffman.flg_Not_Done)
		{
			tmp_Buffman.charge_Outputs();

			tmp_Buffman.gather();

			//---std::cout << "\n   {{{{{{{ 2 }}}}}}}}";
			//---tmp_Buffman.output_All_Buffers();
		}

		//---std::cout << "\n   {{{{{{{ 3 }}}}}}}}";
		//---tmp_Buffman.output_All_Buffers();
	}

	void gather_Treetops()
	{
		//---std::cout << "\n\n Gathering Treetops...";
		float tmp_Charge = 0.0;
		float tmp_H_Charge = tmp_Buffman.get_Treetops_Highest_Charge();
		if (tmp_H_Charge == 0) { return; }

		c_Charging_Linked_List* tmp_Current_LL = NULL;
		tmp_Current_LL = tmp_Buffman.Treetops.Root;

		Output.clear();
		Output.resize(tmp_Buffman.Treetops.Depth);

		int tmp_Current_Index = 0;

		c_Linked_List_Handler tmp_Pattern;

		c_Linked_List* tmp_LL_Pat = NULL;

		while (tmp_Current_LL != NULL)
		{
			tmp_Pattern.reset();

			//Get the pattern into a linked list
			tmp_Current_LL->NID->bp_Trace_O(&tmp_Pattern);

			//---std::cout << "\n NID: " << tmp_Current_LL->NID->NID;
			//---std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;
			//---tmp_Pattern.output();

			//---std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;
			//Copy the pattern over
			Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);

			//---std::cout << "\n Output[" << tmp_Current_Index << "].Depth: " << Output[tmp_Current_Index].Depth;

			//---std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;

			tmp_LL_Pat = tmp_Pattern.Root;

			//We can iterate through given we know how big the linked list is.
			for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
			{
				Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);
				tmp_LL_Pat = tmp_LL_Pat->Next;
			}

			//---std::cout << "\n tmp_Current_LL->NID->Current_Charge: " << tmp_Current_LL->NID->Current_Charge;
			//---std::cout << "\n tmp_Current_LL->Charge: " << tmp_Current_LL->Charge;
			//---std::cout << "\n tmp_Current_LL->NID->RC: " << tmp_Current_LL->NID->RC;

			tmp_Charge = (tmp_Current_LL->Charge / tmp_H_Charge) * get_Base_Charge();
			Output[tmp_Current_Index].set_Charge(tmp_Charge);
			//Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);
			Output[tmp_Current_Index].set_RC(tmp_Current_LL->NID->RC);
			Output[tmp_Current_Index].set_Treetop(tmp_Current_LL->NID);

			tmp_Current_LL = tmp_Current_LL->Next;
			
			//---Output[tmp_Current_Index].output(0);
			//---Output[tmp_Current_Index].output(1);

			tmp_Current_Index++;
		}

		tmp_Buffman.reset_Treetops();
	}

	void backpropagate_NID_Into_Given_Index(uint64_t p_NID, int p_Index, float p_Charge)
	{
		c_Linked_List_Handler tmp_Pattern;

		c_Linked_List* tmp_LL_Pat = NULL;

		tmp_Pattern.reset();

		c_Node* tmp_Node = NNet->get_Node_Ref_By_NID(p_NID);

		if (tmp_Node == NULL) { std::cerr << "\n\n   v(o.O)V   Error in backpropagage_NID_Into_Given_Index, Node " << p_NID << " not found!"; return; }

		//Get the pattern into a linked list
		tmp_Node->bp_Trace_O(&tmp_Pattern);

		//Copy the pattern over
		Output[p_Index].set_Depth(tmp_Pattern.Depth);

		tmp_LL_Pat = tmp_Pattern.Root;

		//We can iterate through given we know how big the linked list is.
		for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
		{
			Output[p_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);
			tmp_LL_Pat = tmp_LL_Pat->Next;
		}

		Output[p_Index].set_Charge(p_Charge);

		Output[p_Index].set_RC(tmp_Node->RC);
		Output[p_Index].set_Treetop(tmp_Node);
	}

	//Gets a single trace from a given node. Puts it into the output.
	void gather_All_Traces()
	{
		std::cout << "\n\n Gathering All Traces!!!";



		c_Node* tmp_Node = NULL;
		tmp_Node = NNet->Root;

		Output.clear();

		int tmp_Current_Index = 0;

		c_Linked_List_Handler tmp_Pattern;

		c_Linked_List* tmp_LL_Pat = NULL;

		while (tmp_Node != NULL)
		{
			std::cout << "\nNode (" << tmp_Node->NID << ") ";
			tmp_Node->bp_O();


			tmp_Pattern.reset();

			//Get the pattern into a linked list
			tmp_Node->bp_Trace_O(&tmp_Pattern);

			std::cout << "\n NID: " << tmp_Node->NID;
			std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;
			tmp_Pattern.output();

			std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;
			//Copy the pattern over
			Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);

			std::cout << "\n Output[" << tmp_Current_Index << "].Depth: " << Output[tmp_Current_Index].get_Output_Pattern_Size();

			std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;

			tmp_LL_Pat = tmp_Pattern.Root;

			//We can iterate through given we know how big the linked list is.
			for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
			{
				Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);
				tmp_LL_Pat = tmp_LL_Pat->Next;
			}

			//std::cout << "\n tmp_Current_LL->NID->Current_Charge: " << tmp_Node->Current_Charge;
			std::cout << "\n tmp_Current_LL->NID->RC: " << tmp_Node->RC;
			//Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);
			//Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);
			Output[tmp_Current_Index].set_RC(tmp_Node->RC);
			Output[tmp_Current_Index].set_Treetop(tmp_Node);

			Output[tmp_Current_Index].output(0);
			Output[tmp_Current_Index].output(1);

			tmp_Current_Index++;

			tmp_Node = tmp_Node->Next;
		}
	}

	//Gets a single trace from a given node. Puts it into the output.
	void gather_Given_Trace(uint64_t p_NID)
	{
		//---std::cout << "\n\n Gathering Given Trace " << p_NID << "...";

		c_Node* tmp_Node = NULL;
		tmp_Node = NNet->get_Node_Ref_By_NID(p_NID);

		Output.clear();

		int tmp_Current_Index = 0;

		c_Linked_List_Handler tmp_Pattern;

		c_Linked_List* tmp_LL_Pat = NULL;

		tmp_Pattern.reset();

		//Get the pattern into a linked list
		tmp_Node->bp_Trace_O(&tmp_Pattern);

		//---std::cout << "\n NID: " << tmp_Node->NID;
		//---std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;
		//---tmp_Pattern.output();

		//Copy the pattern over
		Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);

		//---std::cout << "\n Output[" << tmp_Current_Index << "].Depth: " << Output[tmp_Current_Index].Depth;

		//---std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;

		tmp_LL_Pat = tmp_Pattern.Root;

		//We can iterate through given we know how big the linked list is.
		for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
		{
			Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);
			tmp_LL_Pat = tmp_LL_Pat->Next;
		}

		//---std::cout << "\n tmp_Node->Current_Charge: " << tmp_Node->Current_Charge;
		//---std::cout << "\n tmp_Node->RC: " << tmp_Node->RC;
		//Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);
		//Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);
		Output[tmp_Current_Index].set_RC(tmp_Node->RC);
		Output[tmp_Current_Index].set_Treetop(tmp_Node);

		//---Output[tmp_Current_Index].output(0);
		//---Output[tmp_Current_Index].output(1);

		tmp_Current_Index++;
	}


	//Fills out the NULLCAN, does not forcibly encode, and then charges the network.
	//Charging style determines leg charging. May move it to be a setting.
	//     -1: Charge by giving the input node the base charge, normal node charging.
	//      1: Use leg specific charging to charge every node based on its position in the input array. Node[1] would charge axons on Axon[1][n].
	//      2: Charge every input on the given p_Leg, used mainly when inputing single values to charge. Allows you to input Node[x] as the only input to the Chrono and charge it using Axon[4][n], or any axon hillock you choose.
	//		 This allows you to search forward by setting a node early in the time series and searching forwards, or setting it late in the time series and searching backwards.
	void query(int p_Charging_Style = -1, int p_Leg = 0, int * p_Legs = NULL)
	{
		//Set up the scaffold for the nodes to reside in as we build the trace.
		setup_CAN_Scaffold();

		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Query");

		//Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.
		fill_Scaffold("Query");

		charge_Buffers(p_Charging_Style, p_Leg, p_Legs);

		//gather_Treetops();


		//To be removed later after testing.
		//---output_Input();
		//output_Scaffold();
		//output_Scaffold_Char();
		//---output_Output();
	}

	//This allows for passing unordered sets of nodes
	void submit_Set(uint64_t* p_Input, int p_Depth)
	{
		//Firstly we gather the inputly
		set_Input(p_Input, p_Depth);

		//We only do the query on the state tier. This is because the nodes will not be in a coherent relationship to each other, only their presence is important.
		//The node adress being read in as the state means that the unordered set can be read in to the state tier because the shared memory space precludes duplicates, you just ignore any higher tiers than 0.
		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Query");

		//Then charge the buffers as normal.
		charge_Buffers();
	}

	//Gets the current treetop at the given index.
	c_Node* get_Treetop(int p_Index = -1)
	{
		if (State_Depth > 0)
		{
			return Scaffold[State_Depth - 1][0];
		}
		return NULL;
	}

	//Returns the dimension of the data.
	int get_Dimension()
	{
		return 1;
	}

	//Outputs the scaffold.
	void output_Scaffold()
	{
		for (int cou_T = 0; cou_T < State_Depth; cou_T++)
		{
			std::cout << "\nT<" << cou_T << ">";
			for (int cou_Index = 0; cou_Index < (State_Depth - cou_T); cou_Index++)
			{
				std::cout << " [";
				if (Scaffold[cou_T][cou_Index] != NULL) { std::cout << Scaffold[cou_T][cou_Index]->NID; } else { std::cout << "NULL"; }
				std::cout << "] ";
			}
		}
	}

	//Outputs the scaffold as character representing the address.
	void output_Scaffold_Char()
	{
		for (int cou_T = 0; cou_T < State_Depth; cou_T++)
		{
			std::cout << "\nT<" << cou_T << "> [";
			for (int cou_Index = 0; cou_Index < (State_Depth - cou_T); cou_Index++)
			{
				std::cout << static_cast<char>(uint64_t(Scaffold[cou_T][cou_Index]) & 0xFF);
			}
			std::cout << "]";
		}
	}

	void output_Scaffold_Tops()
	{
		std::vector<uint64_t> tmp_NID[2];
		std::vector<int> tmp_Index;
		std::vector<int> tmp_Tier;

		std::vector<uint64_t> xmp_NID;
		std::vector<int> xmp_Index;
		std::vector<int> xmp_Tier;

		tmp_NID[0].resize(State_Depth);
		tmp_NID[1].resize(State_Depth);
		tmp_Index.resize(State_Depth);
		tmp_Tier.resize(State_Depth);



		for (int cou_T = (State_Depth - 1); cou_T >= 0; cou_T--)
		{
			std::cout << "\nT<" << cou_T << "> [";
			for (int cou_Index = 0; cou_Index < (State_Depth - cou_T); cou_Index++)
			{
				std::cout << static_cast<char>(uint64_t(Scaffold[cou_T][cou_Index]) & 0xFF);

				if (tmp_NID[0][cou_Index] == 0)
				{
					if (Scaffold[cou_T][cou_Index] != NULL)
					{
						std::cout << "\n\n[" << cou_Index << "]";

						for (int cou_Fill = cou_Index; cou_Fill <= (cou_Index + cou_T); cou_Fill++)
						{
							tmp_NID[0][cou_Fill] = Scaffold[cou_T][cou_Index]->NID;
							//tmp_NID[1][cou_Fill] = 0;
							tmp_Index[cou_Fill] = cou_Index;
							tmp_Tier[cou_Fill] = cou_T;

							std::cout << " >NID: " << tmp_NID[0][cou_Index];
							std::cout << " >NID: " << tmp_NID[1][cou_Index];
							std::cout << " >Index: " << tmp_Index[cou_Index];
							std::cout << " >Tier: " << tmp_Tier[cou_Index];
							std::cout << " >[___]   ";
						}
						tmp_NID[1][cou_Index] = Scaffold[cou_T][cou_Index]->NID;

						std::cout << " NID: " << tmp_NID[0][cou_Index];
						std::cout << " NID: " << tmp_NID[1][cou_Index];
						std::cout << " Index: " << tmp_Index[cou_Index];
						std::cout << " Tier: " << tmp_Tier[cou_Index];
						std::cout << " [___]   ";

						xmp_NID.push_back(Scaffold[cou_T][cou_Index]->NID);
						xmp_Index.push_back(cou_Index);
						xmp_Tier.push_back(cou_T);
					}
				}
			}
			std::cout << "]";
		}

		for (int cou_Index = 0; cou_Index < State_Depth; cou_Index++)
		{
			std::cout << "\n[" << cou_Index << "]";
			std::cout << " NID: " << tmp_NID[0][cou_Index];
			std::cout << " NID: " << tmp_NID[1][cou_Index];
			std::cout << " Index: " << tmp_Index[cou_Index];
			std::cout << " Tier: " << tmp_Tier[cou_Index];
			std::cout << " [___]";
			Scaffold[tmp_Tier[cou_Index]][tmp_Index[cou_Index]]->bp_O(0);
			std::cout << "[___]  ";
		}
		std::cout << "\n\n";
		for (int cou_Index = 0; cou_Index < State_Depth; cou_Index++)
		{
			if (tmp_NID[1][cou_Index] != NULL)
			{
				Scaffold[tmp_Tier[cou_Index]][tmp_Index[cou_Index]]->bp_O(0);
			}
		}
		
		bool tmp_Done = false;
		uint64_t xtmp_NID = 0;
		int xtmp_Index = 0;
		int xtmp_Tier = 0;

		while (!tmp_Done)
		{
			tmp_Done = true;

			for (int cou_Index = 1; cou_Index < xmp_NID.size(); cou_Index++)
			{
				if (xmp_Index[cou_Index - 1] > xmp_Index[cou_Index])
				{
					xtmp_Tier = xmp_Tier[cou_Index - 1];
					xtmp_Index = xmp_Index[cou_Index - 1];

					xmp_Tier[cou_Index - 1] = xmp_Tier[cou_Index];
					xmp_Index[cou_Index - 1] = xmp_Index[cou_Index];

					xmp_Tier[cou_Index] = xtmp_Tier;
					xmp_Index[cou_Index] = xtmp_Index;

					tmp_Done = false;
				}
			}
		}

		std::cout << "\n\n";
		for (int cou_Index = 0; cou_Index < xmp_NID.size(); cou_Index++)
		{
			//std::cout << "\n [" << cou_Index << "] ___ " << xmp_Tier[cou_Index] << " <___> " << xmp_Index[cou_Index];
			Scaffold[xmp_Tier[cou_Index]][xmp_Index[cou_Index]]->bp_O(0);
		}
	}

	//Outputs the scaffold as character representing the address. Currently only 1D supports this.
	void output_Scaffold_Symbols(int p_Type = 0)
	{
		for (int cou_T = 0; cou_T < State_Depth; cou_T++)
		{
			std::cout << "\nT<" << cou_T << "> ";
			for (int cou_Index = 0; cou_Index < (State_Depth - cou_T); cou_Index++)
			{
				std::cout << "[";
				if (Scaffold[cou_T][cou_Index] != NULL)
				{
					Scaffold[cou_T][cou_Index]->bp_O(p_Type);
				}
				else
				{
					std::cout << "NULL";
				}
				std::cout << "]";
			}
		}
	}
};

//This functions to create a trace where all legs are connected to one node.
//Load up the input, hit encode(), boom you single permutation of all legs bound to that node.
//Most useful when each index in the input is a separate state space from the other indexes, sensors == good, language == shared states across words !good
class c_CAN_2D_Pyramid : public c_Base_CAN
{
public:

	//Each CAN node is just a pointer to a node in the network.
	//Scaffold[Tier][X][Y]
	//Tier_Depth == where T = current tier: (Input_Depth - T)
	c_Node**** Scaffold;

	int State_Depth_X; //We track this so that if the input is changed we can still properly delete the scaffold.
	int State_Depth_Y; //We track this so that if the input is changed we can still properly delete the scaffold.
	int Top_Tier; //Whichever dimension is lowest is the limiting factor on the height for nodes with the same leg count. For every dimsension that 'closes' you want to drop a lower dimensional construct on top.

	c_CAN_2D_Pyramid()
	{
		init();

		Scaffold = NULL;

		State_Depth_X = 0;
		State_Depth_Y = 0;

		Top_Tier = 0;
	}

	~c_CAN_2D_Pyramid()
	{
		NNet = NULL;
		reset_Scaffold();
		reset_Input();
	}

	//Resets the CAN to NULL, and deletes the state tier + treetop.
	void reset_Scaffold()
	{
		if (Scaffold != NULL)
		{
			//For every tier
			for (int cou_T = 0; cou_T < Top_Tier; cou_T++)
			{
				if (Scaffold[cou_T] != NULL)
				{
					for (int cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)
					{
						for (int cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)
						{
							//Make sure to NULL the scaffold first.
							//DO NOT DELETE THEM, the addresses are for the node network, deleting them here will cause null pointer deletion in Node_Network.
							Scaffold[cou_T][cou_X][cou_Y] = NULL;
						}
						delete[] Scaffold[cou_T][cou_X];
						Scaffold[cou_T][cou_X] = NULL;
					}

					delete[] Scaffold[cou_T];
					Scaffold[cou_T] = NULL;
				}
			}
			delete[] Scaffold;
			Scaffold = NULL;
		}
	}

	//This sets up the actual CAN scaffold to use.
	//It assumes the input array is filled out, the size is based upon that array.
	void setup_CAN_Scaffold()
	{
		//Take it out back and put it down.
		reset_Scaffold();

		//Sizing her up!
		State_Depth_X = Input_2D.Depth[0];
		State_Depth_Y = Input_2D.Depth[1];

		Top_Tier = State_Depth_X;
		if (State_Depth_Y < State_Depth_X) { Top_Tier = State_Depth_Y; }

		//Define the tiers, the number of tiers to hold a pyramid is equal to the depth of the pattern it represents.
		Scaffold = new c_Node *** [Top_Tier];

		//Through the tiers we brings beers.
		for (int cou_T = 0; cou_T < Top_Tier; cou_T++)
		{
			//Through the steps Randolph Carter crept.
			Scaffold[cou_T] = new c_Node ** [State_Depth_X - cou_T];

			for (int cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)
			{
				Scaffold[cou_T][cou_X] = new c_Node * [State_Depth_Y - cou_T];

				for (int cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)
				{
					Scaffold[cou_T][cou_X][cou_Y] = NULL;
				}
			}
		}
	}

	//This fills the state tier by querying the node network.
	//p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.
	void fill_State(std::string p_How = "Encode")
	{
		//---std::cout << "\n Encoding with State_Nodes_Index: " << State_Nodes_Index;
		if (p_How == "Encode")
		{
			for (int cou_X = 0; cou_X < State_Depth_X; cou_X++)
			{
				for (int cou_Y = 0; cou_Y < State_Depth_Y; cou_Y++)
				{
					//Request the state node form the node network using get_State_Node so one is created if not found.
					//We have to make sure we request the correct state tree.
					Scaffold[0][cou_X][cou_Y] = NNet->get_State_Node(State_Nodes_Index, Input_2D.get_Value(cou_X, cou_Y));
					Scaffold[0][cou_X][cou_Y]->RC++;

					//If the node is also a treetop then set it to state/treetop.
					if ((Scaffold[0][cou_X][cou_Y]->Type == 2))
					{
						Scaffold[0][cou_X][cou_Y]->Type = 3;
					}
				}
			}
		}
		if (p_How == "Query")
		{
			for (int cou_X = 0; cou_X < State_Depth_X; cou_X++)
			{
				for (int cou_Y = 0; cou_Y < State_Depth_Y; cou_Y++)
				{
					//Request the state node form the node network using get_State_Node so one is created if not found.
					//We have to make sure we request the correct state tree.
					Scaffold[0][cou_X][cou_Y] = NNet->does_State_Node_Exist(State_Nodes_Index, Input_2D.get_Value(cou_X, cou_Y));
				}
			}
		}
	}

	//Just one node at the tippy top.
	//p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.
	void fill_Scaffold(std::string p_How = "Encode")
	{
		if ((State_Depth_X == 0) || (State_Depth_Y == 0))
		{
			return;
		}

		//These hold the matrix we use to get the nodes to submit to the get upper tier node.
		c_Node* tmp_Nodes[4];

		for (int cou_T = 1; cou_T < Top_Tier; cou_T++)
		{
			//---std::cerr << "\n T: " << cou_T;
			//The extra -1 is so we don't step to the last node and reach into the void.
			/*
			We need to take them in a 2x2 grid.
			0[0, 0] 1[1, 0]
			2[0, 1] 3[1, 1]
			*/
			for (int cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)
			{
				for (int cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)
				{
					//---std::cerr << " - " << cou_X << ", " << cou_Y;

					//Get the legs for the node, the 2x2
					tmp_Nodes[0] = Scaffold[cou_T - 1][cou_X][cou_Y]; //1

					tmp_Nodes[1] = Scaffold[cou_T - 1][cou_X][cou_Y + 1]; //2

					tmp_Nodes[2] = Scaffold[cou_T - 1][cou_X + 1][cou_Y]; //3

					tmp_Nodes[3] = Scaffold[cou_T - 1][cou_X + 1][cou_Y + 1]; //4

					if (p_How == "Encode")
					{
						//We request a node that links 4 nodes together.
						Scaffold[cou_T][cou_X][cou_Y] = NNet->get_Upper_Tier_Node(tmp_Nodes, 4, 1);
						Scaffold[cou_T][cou_X][cou_Y]->RC++;
						Scaffold[cou_T][cou_X][cou_Y]->rectify_Double_Legged_Nodes(); //Only need to do this for tiers 1+ as tier 0 doesn't have dendrites in this CAN.
					}
					if (p_How == "Query")
					{
						//We request a node that links the entire state tier together, but do not create them.
						Scaffold[cou_T][cou_X][cou_Y] = NNet->does_Upper_Tier_Connection_Exist(tmp_Nodes, 4);
					}
				}
			}
		}

		if (p_How == "Encode")
		{
			for (int cou_X = 0; cou_X < (State_Depth_X - Top_Tier - 1); cou_X++)
			{
				for (int cou_Y = 0; cou_Y < (State_Depth_Y - Top_Tier - 1); cou_Y++)
				{
					Scaffold[Top_Tier - 1][cou_X][cou_Y]->Type = 2;
				}
			}
		}
	}

	void check_Symbol()
	{
		//Set up the scaffold for the nodes to reside in as we build the trace.
		setup_CAN_Scaffold();

		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Query");

		//Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.
		fill_Scaffold("Query");
	}

	//Encodes a single trace, forcibly.
	void encode()
	{
		//---std::cout << "\n\n<<-- Begin Encoding -->>\n\n";

		//Set up the scaffold for the nodes to reside in as we build the trace.
		setup_CAN_Scaffold();

		//---output_Scaffold();

		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Encode");

		//---std::cerr << "\n State Filled.";
		//---output_Scaffold();

		//Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.
		fill_Scaffold("Encode");

		//To be removed later after testing.
		//output_Input();
		//---output_Scaffold();
		//output_Scaffold_Char();
		for (int cou_X = 0; cou_X < (State_Depth_X - (Top_Tier - 1)); cou_X++)
		{
			for (int cou_Y = 0; cou_Y < (State_Depth_Y - (Top_Tier - 1)); cou_Y++)
			{
				if (Scaffold[Top_Tier - 1][cou_X][cou_Y] != NULL)
				{
					std::cout << "\nTreetop: " << Scaffold[Top_Tier - 1][cou_X][cou_Y]->NID;
				}
				else
				{
					std::cout << "\nTreetop: NULL";
				}
			}
		}
	}

	//Style determines whether it charges with normal submission of raw, or if it does the specific leg charging for Chrono.
	//Assumes the CAN is setup.
	void charge_Buffers(int p_Style = -1, int p_Leg = 0, int * p_Legs = NULL)
	{
		tmp_Buffman.reset();

		tmp_Buffman.Input_Position = 0;

		tmp_Buffman.charge_Outputs();

		for (int cou_T = Charging_Tier; cou_T < Top_Tier; cou_T++)
		{
			for (int cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)
			{
				for (int cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)
				{
					if (Scaffold[cou_T][cou_X][cou_Y] != NULL)
					{
						if (p_Style == -1)
						{
							tmp_Buffman.submit(Scaffold[cou_T][cou_X][cou_Y], (tmp_Buffman.get_Base_Charge()));
						}
						if (p_Style == 1)
						{
							//This style not used in pyramidal.
							//tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_X][cou_Y], (tmp_Buffman.get_Base_Charge()), cou_Input);
						}
						if (p_Style == 2)
						{
							//p_Leg specifies which leg to charge in this function, p_Legs[] being unused.
							tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_X][cou_Y], (tmp_Buffman.get_Base_Charge()), p_Leg);
						}
						if (p_Style == 3)
						{
							//p_Leg is used here as the count of elements in p_Legs[].
							tmp_Buffman.charge_Given_Legs(Scaffold[cou_T][cou_X][cou_Y], p_Leg, p_Legs, (tmp_Buffman.get_Base_Charge()));
						}
					}
				}
			}
		}

		tmp_Buffman.gather();

		while (tmp_Buffman.flg_Not_Done)
		{
			tmp_Buffman.charge_Outputs();

			tmp_Buffman.gather();
		}

		c_Charging_Linked_List * tmp_Current_LL = NULL;
		tmp_Current_LL = tmp_Buffman.Treetops.Root;
	}

	void gather_Treetops()
	{
		float tmp_Charge = 0.0;
		float tmp_H_Charge = tmp_Buffman.get_Treetops_Highest_Charge();
		if (tmp_H_Charge == 0) { return; }
		//---std::cout << "\n\n\n\n\n Gathering Treetops...";

		c_Charging_Linked_List* tmp_Current_LL = NULL;
		tmp_Current_LL = tmp_Buffman.Treetops.Root;

		if (Output_2D != NULL) { delete[] Output_2D; Output_2D = NULL; }

		Output_2D = new c_2D_Trace[tmp_Buffman.Treetops.Depth];
		Output_Depth_2D = tmp_Buffman.Treetops.Depth;

		int tmp_Current_Index = 0;

		c_Linked_List_Handler tmp_Pattern;
		c_Linked_List_Handler tmp_Pattern_X;
		c_Linked_List_Handler tmp_Pattern_Y;
		int tmp_Top_X = 0; //Loop through tmp_Pattern_X to find the highest.
		int tmp_Top_Y = 0; //Loop through tmp_Pattern_Y to find the highest.

		c_Linked_List* tmp_LL_Pat = NULL;
		c_Linked_List* tmp_LL_Pat_X = NULL;
		c_Linked_List* tmp_LL_Pat_Y = NULL;

		while (tmp_Current_LL != NULL)
		{
			tmp_Top_X = 0;
			tmp_Top_Y = 0;

			tmp_Pattern.reset();
			tmp_Pattern_X.reset();
			tmp_Pattern_Y.reset();

			//Get the pattern into a linked list
			tmp_Current_LL->NID->bp_2D_Trace_O(&tmp_Pattern, &tmp_Pattern_X, &tmp_Pattern_Y);

			tmp_Top_X = get_Top(&tmp_Pattern_X);
			tmp_Top_Y = get_Top(&tmp_Pattern_Y);

			//Copy the pattern over
			Output_2D[tmp_Current_Index].set_Depth(tmp_Top_X, tmp_Top_Y);

			tmp_LL_Pat = tmp_Pattern.Root;
			tmp_LL_Pat_X = tmp_Pattern_X.Root;
			tmp_LL_Pat_Y = tmp_Pattern_Y.Root;

			//We can iterate through given we know how big the linked list is.
			for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
			{
				Output_2D[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, int(tmp_LL_Pat_X->Quanta), int(tmp_LL_Pat_Y->Quanta));
				tmp_LL_Pat = tmp_LL_Pat->Next;
				tmp_LL_Pat_X = tmp_LL_Pat_X->Next;
				tmp_LL_Pat_Y = tmp_LL_Pat_Y->Next;
			}

			tmp_Charge = (tmp_Current_LL->Charge / tmp_H_Charge) * get_Base_Charge();
			Output_2D[tmp_Current_Index].set_Charge(tmp_Charge);
			Output_2D[tmp_Current_Index].set_RC(tmp_Current_LL->NID->RC);
			Output_2D[tmp_Current_Index].set_Treetop(tmp_Current_LL->NID);

			tmp_Current_LL = tmp_Current_LL->Next;

			tmp_Current_Index++;
		}

		tmp_Buffman.reset_Treetops();
	}

	void backpropagate_NID_Into_Given_Index(uint64_t p_NID, int p_Index, float p_Charge)
	{
		c_Linked_List_Handler tmp_Pattern;
		c_Linked_List_Handler tmp_Pattern_X;
		c_Linked_List_Handler tmp_Pattern_Y;
		int tmp_Top_X = 0; //Loop through tmp_Pattern_X to find the highest.
		int tmp_Top_Y = 0; //Loop through tmp_Pattern_Y to find the highest.

		c_Linked_List* tmp_LL_Pat = NULL;
		c_Linked_List* tmp_LL_Pat_X = NULL;
		c_Linked_List* tmp_LL_Pat_Y = NULL;

		tmp_Pattern.reset();
		tmp_Pattern_X.reset();
		tmp_Pattern_Y.reset();

		c_Node* tmp_Node = NNet->get_Node_Ref_By_NID(p_NID);

		if (tmp_Node == NULL) { std::cerr << "\n\n   v(o.O)V   Error in backpropagage_NID_Into_Given_Index, Node " << p_NID << " not found!"; }

		//Get the pattern into a linked list
		tmp_Node->bp_2D_Trace_O(&tmp_Pattern, &tmp_Pattern_X, &tmp_Pattern_Y);

		tmp_Top_X = get_Top(&tmp_Pattern_X);
		tmp_Top_Y = get_Top(&tmp_Pattern_Y);

		//Copy the pattern over
		Output_2D[p_Index].set_Depth(tmp_Top_X, tmp_Top_Y);

		tmp_LL_Pat = tmp_Pattern.Root;
		tmp_LL_Pat_X = tmp_Pattern_X.Root;
		tmp_LL_Pat_Y = tmp_Pattern_Y.Root;

		//We can iterate through given we know how big the linked list is.
		for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
		{
			Output_2D[p_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, int(tmp_LL_Pat_X->Quanta), int(tmp_LL_Pat_Y->Quanta));
			tmp_LL_Pat = tmp_LL_Pat->Next;
			tmp_LL_Pat_X = tmp_LL_Pat_X->Next;
			tmp_LL_Pat_Y = tmp_LL_Pat_Y->Next;
		}

		Output_2D[p_Index].set_Charge(p_Charge);
		Output_2D[p_Index].set_RC(tmp_Node->RC);
		Output_2D[p_Index].set_Treetop(tmp_Node);

	}

	//Gets a single trace from a given node. Puts it into the output.
	void gather_All_Traces()
	{
		c_Node* tmp_Node = NULL;
		tmp_Node = NNet->Root;

		//if (Output != NULL) { delete[] Output; Output = NULL; Output_Depth = 0; }
		Output.clear();
		if (Output_2D != NULL) { delete[] Output_2D; Output_2D = NULL; Output_Depth_2D = 0; }

		Output_2D = new c_2D_Trace[NNet->Node_Count];
		Output_Depth_2D = int(NNet->Node_Count);

		int tmp_Current_Index = 0;

		c_Linked_List_Handler tmp_Pattern;
		c_Linked_List_Handler tmp_Pattern_X;
		c_Linked_List_Handler tmp_Pattern_Y;
		int tmp_Top_X = 0; //Loop through tmp_Pattern_X to find the highest.
		int tmp_Top_Y = 0; //Loop through tmp_Pattern_Y to find the highest.

		c_Linked_List* tmp_LL_Pat = NULL;
		c_Linked_List* tmp_LL_Pat_X = NULL;
		c_Linked_List* tmp_LL_Pat_Y = NULL;

		while (tmp_Node != NULL)
		{
			tmp_Top_X = 0;
			tmp_Top_Y = 0;

			//If the node isn't 2D don't try to force it or you will crash.
			//if (tmp_Node->Dendrite_Count != 4) { tmp_Node = tmp_Node->Next; continue; }

			tmp_Pattern.reset();
			tmp_Pattern_X.reset();
			tmp_Pattern_Y.reset();

			//Get the pattern into a linked list
			tmp_Node->bp_2D_Trace_O(&tmp_Pattern, &tmp_Pattern_X, &tmp_Pattern_Y);

			tmp_Top_X = get_Top(&tmp_Pattern_X);
			tmp_Top_Y = get_Top(&tmp_Pattern_Y);

			//Copy the pattern over
			Output_2D[tmp_Current_Index].set_Depth(tmp_Top_X, tmp_Top_Y);

			tmp_LL_Pat = tmp_Pattern.Root;
			tmp_LL_Pat_X = tmp_Pattern_X.Root;
			tmp_LL_Pat_Y = tmp_Pattern_Y.Root;

			//We can iterate through given we know how big the linked list is.
			for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
			{
				Output_2D[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, int(tmp_LL_Pat_X->Quanta), int(tmp_LL_Pat_Y->Quanta));
				tmp_LL_Pat = tmp_LL_Pat->Next;
				tmp_LL_Pat_X = tmp_LL_Pat_X->Next;
				tmp_LL_Pat_Y = tmp_LL_Pat_Y->Next;
			}

			//Output_2D[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);
			//Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);
			Output_2D[tmp_Current_Index].set_RC(tmp_Node->RC);
			Output_2D[tmp_Current_Index].set_Treetop(tmp_Node);

			tmp_Current_Index++;

			tmp_Node = tmp_Node->Next;
		}
	}


	//Gets a single trace from a given node. Puts it into the output.
	void gather_Given_Trace(uint64_t p_NID)
	{
		//---std::cout << "\n\n Gathering Given Trace " << p_NID << "...";

		c_Node* tmp_Node = NULL;
		tmp_Node = NNet->get_Node_Ref_By_NID(p_NID);

		if (Output_2D != NULL) { delete[] Output_2D; Output_2D = NULL; Output_Depth_2D = 0; }

		Output_2D = new c_2D_Trace[1];
		Output_Depth_2D = 1;

		int tmp_Current_Index = 0;

		c_Linked_List_Handler tmp_Pattern;
		c_Linked_List_Handler tmp_Pattern_X;
		c_Linked_List_Handler tmp_Pattern_Y;

		tmp_Pattern.reset();
		tmp_Pattern_X.reset();
		tmp_Pattern_Y.reset();

		int tmp_Top_X = 0; //Loop through tmp_Pattern_X to find the highest.
		int tmp_Top_Y = 0; //Loop through tmp_Pattern_Y to find the highest.
		int tmp_Top_Z = 0; //Loop through tmp_Pattern_Y to find the highest.

		c_Linked_List* tmp_LL_Pat = NULL;
		c_Linked_List* tmp_LL_Pat_X = NULL;
		c_Linked_List* tmp_LL_Pat_Y = NULL;

		//Get the pattern into a linked list
		tmp_Node->bp_2D_Trace_O(&tmp_Pattern, &tmp_Pattern_X, &tmp_Pattern_Y);

		tmp_LL_Pat_X = tmp_Pattern_X.Root;

		//We can iterate through given we know how big the linked list is.
		tmp_Top_X = get_Top(&tmp_Pattern_X);
		tmp_Top_Y = get_Top(&tmp_Pattern_Y);

		//Copy the pattern over
		Output_2D[0].set_Depth(tmp_Top_X, tmp_Top_Y);

		tmp_LL_Pat = tmp_Pattern.Root;
		tmp_LL_Pat_X = tmp_Pattern_X.Root;
		tmp_LL_Pat_Y = tmp_Pattern_Y.Root;

		//We can iterate through given we know how big the linked list is.
		for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
		{
			Output_2D[0].set_Pattern_Index(tmp_LL_Pat->Quanta, int(tmp_LL_Pat_X->Quanta), int(tmp_LL_Pat_Y->Quanta));

			tmp_LL_Pat = tmp_LL_Pat->Next;
			tmp_LL_Pat_X = tmp_LL_Pat_X->Next;
			tmp_LL_Pat_Y = tmp_LL_Pat_Y->Next;
		}

		//No charge set here
		Output_2D[0].set_RC(tmp_Node->RC);
		Output_2D[0].set_Treetop(tmp_Node);

	}


	//Fills out the NULLCAN, does not forcibly encode, and then charges the network.
	//Charging style determines leg charging. May move it to be a setting.
	//     -1: Charge by giving the input node the base charge, normal node charging.
	//      1: Use leg specific charging to charge every node based on its position in the input array. Node[1] would charge axons on Axon[1][n].
	//      2: Charge every input on the given p_Leg, used mainly when inputing single values to charge. Allows you to input Node[x] as the only input to the Chrono and charge it using Axon[4][n], or any axon hillock you choose.
	//		 This allows you to search forward by setting a node early in the time series and searching forwards, or setting it late in the time series and searching backwards.
	void query(int p_Charging_Style = -1, int p_Leg = 0, int * p_Legs = NULL)
	{
		//Set up the scaffold for the nodes to reside in as we build the trace.
		setup_CAN_Scaffold();

		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Query");

		//Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.
		fill_Scaffold("Query");

		charge_Buffers(p_Charging_Style, p_Leg, p_Legs);

		//gather_Treetops();


		//To be removed later after testing.
		//output_Input();
		//output_Scaffold();
		//output_Scaffold_Char();
		//output_Output();
	}

	//This allows for passing unordered sets of nodes
	void submit_Set(uint64_t* p_Input, int p_Depth)
	{
		//Firstly we gather the inputly
		set_Input(p_Input, p_Depth);

		//We only do the query on the state tier. This is because the nodes will not be in a coherent relationship to each other, only their presence is important.
		//The node adress being read in as the state means that the unordered set can be read in to the state tier because the shared memory space precludes duplicates, you just ignore any higher tiers than 0.
		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Query");

		//Then charge the buffers as normal.
		charge_Buffers();
	}

	//Gets the current treetop at the given index.
	c_Node* get_Treetop(int p_Index = -1)
	{
		if (Top_Tier > 0)
		{
			if (p_Index == -1)
			{
				return Scaffold[Top_Tier - 1][0][0];
			}

			//This construct is 2d which means at the highest point of 4 legged nodes before it turns to 2D then the dimension which is longer than the pyramid is tall will have treetops in a 1D line, like if you took a pyramid of Gaza and click-dragged it sideways with tracers on.
			if (State_Depth_X >= Top_Tier)
			{
				return Scaffold[Top_Tier - 1][p_Index][0];
			}
			//>= in case X == Y and we don't want fall-through on a perfect one.
			if (State_Depth_Y >= Top_Tier)
			{
				return Scaffold[Top_Tier - 1][0][p_Index];
			}
		}
		return NULL;
	}

	//Returns the dimension of the data.
	int get_Dimension()
	{
		return 2;
	}

	//Outputs the scaffold.
	void output_Scaffold()
	{
		for (int cou_T = 0; cou_T < Top_Tier; cou_T++)
		{
			std::cout << "\n <- Tier[" << cou_T << "] ->\n";
			for (int cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)
			{
				std::cout << "\n";
				for (int cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)
				{
					std::cout << " [";
					if (Scaffold[cou_T][cou_X][cou_Y] != NULL) { std::cout << Scaffold[cou_T][cou_X][cou_Y]->NID; } else { std::cout << "NULL"; }
					std::cout << "] ";
				}
			}
			std::cout << "\n";
		}
	}

	//Outputs the scaffold as character representing the address.
	void output_Scaffold_Char()
	{
		for (int cou_T = 0; cou_T < Top_Tier; cou_T++)
		{
			std::cout << "\n";
			for (int cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)
			{
				for (int cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)
				{
					std::cout << "[";
					std::cout << static_cast<char>(uint64_t(Scaffold[cou_T][cou_X][cou_Y]) & 0xFF);
					std::cout << "]";
				}
			}
		}
	}

	void output_Scaffold_Tops()
	{

	}

	//Outputs the scaffold as character representing the address. Currently only 1D supports this.
	void output_Scaffold_Symbols(int p_Type = 0)
	{
	}
};

//This functions to create a trace where all legs are connected to one node.
//Load up the input, hit encode(), boom you single permutation of all legs bound to that node.
//Most useful when each index in the input is a separate state space from the other indexes, sensors == good, language == shared states across words !good
class c_CAN_3D_Pyramid : public c_Base_CAN
{
public:

	//Each CAN node is just a pointer to a node in the network.
	//Scaffold[Tier][X][Y]
	//Tier_Depth == where T = current tier: (Input_Depth - T)
	c_Node***** Scaffold;

	int State_Depth_X; //We track this so that if the input is changed we can still properly delete the scaffold.
	int State_Depth_Y; //We track this so that if the input is changed we can still properly delete the scaffold.
	int State_Depth_Z; //We track this so that if the input is changed we can still properly delete the scaffold.
	int Top_Tier; //Whichever dimension is lowest is the limiting factor on the height for nodes with the same leg count. For every dimsension that 'closes' you want to drop a lower dimensional construct on top.

	c_CAN_3D_Pyramid()
	{
		init();

		Scaffold = NULL;

		State_Depth_X = 0;
		State_Depth_Y = 0;
		State_Depth_Z = 0;
		Top_Tier = 0;
	}

	~c_CAN_3D_Pyramid()
	{
		NNet = NULL;
		reset_Scaffold();
		reset_Input();
	}

	//Resets the CAN to NULL, and deletes the state tier + treetop.
	void reset_Scaffold()
	{
		if (Scaffold != NULL)
		{
			//For every tier
			for (int cou_T = 0; cou_T < Top_Tier; cou_T++)
			{
				if (Scaffold[cou_T] != NULL)
				{
					for (int cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)
					{
						for (int cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)
						{
							for (int cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)
							{
								//Make sure to NULL the scaffold first.
								//DO NOT DELETE THEM, the addresses are for the node network, deleting them here will cause null pointer deletion in Node_Network.
								Scaffold[cou_T][cou_X][cou_Y][cou_Z] = NULL;
							}
							delete[] Scaffold[cou_T][cou_X][cou_Y];
							Scaffold[cou_T][cou_X][cou_Y] = NULL;
						}
						delete[] Scaffold[cou_T][cou_X];
						Scaffold[cou_T][cou_X] = NULL;
					}
					delete[] Scaffold[cou_T];
					Scaffold[cou_T] = NULL;
				}
			}
			delete[] Scaffold;
			Scaffold = NULL;
		}
	}

	//This sets up the actual CAN scaffold to use.
	//It assumes the input array is filled out, the size is based upon that array.
	void setup_CAN_Scaffold()
	{
		//Take it out back and put it down.
		reset_Scaffold();

		//Sizing her up!
		State_Depth_X = Input_3D.Depth[0];
		State_Depth_Y = Input_3D.Depth[1];
		State_Depth_Z = Input_3D.Depth[2];

		//---std::cout << "\n State_Depth_X: " << State_Depth_X;
		//---std::cout << "\n State_Depth_Y: " << State_Depth_Y;
		//---std::cout << "\n State_Depth_Z: " << State_Depth_Y;

		//Find the shortest side to set the top tier to as that is when the symbol will reduce in dimension.
		Top_Tier = State_Depth_X;
		if (State_Depth_Y < Top_Tier) { Top_Tier = State_Depth_Y; }
		if (State_Depth_Z < Top_Tier) { Top_Tier = State_Depth_Z; }

		//Define the tiers, the number of tiers to hold a pyramid is equal to the depth of the pattern it represents.
		Scaffold = new c_Node **** [Top_Tier];

		//Through the tiers we brings beers.
		for (int cou_T = 0; cou_T < Top_Tier; cou_T++)
		{
			//Through the steps Randolph Carter crept.
			Scaffold[cou_T] = new c_Node *** [State_Depth_X - cou_T];

			for (int cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)
			{
				Scaffold[cou_T][cou_X] = new c_Node ** [State_Depth_Y - cou_T];

				for (int cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)
				{
					Scaffold[cou_T][cou_X][cou_Y] = new c_Node *[State_Depth_Z - cou_T];

					for (int cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)
					{
						Scaffold[cou_T][cou_X][cou_Y][cou_Z] = NULL;
					}
				}
			}
		}
	}

	//This fills the state tier by querying the node network.
	//p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.
	void fill_State(std::string p_How = "Encode")
	{
		//---std::cout << "\n Encoding with State_Nodes_Index: " << State_Nodes_Index;
		if (p_How == "Encode")
		{
			for (int cou_X = 0; cou_X < State_Depth_X; cou_X++)
			{
				for (int cou_Y = 0; cou_Y < State_Depth_Y; cou_Y++)
				{
					for (int cou_Z = 0; cou_Z < State_Depth_Z; cou_Z++)
					{
						//Request the state node form the node network using get_State_Node so one is created if not found.
						//We have to make sure we request the correct state tree.
						Scaffold[0][cou_X][cou_Y][cou_Z] = NNet->get_State_Node(State_Nodes_Index, Input_3D.get_Value(cou_X, cou_Y, cou_Z));
						Scaffold[0][cou_X][cou_Y][cou_Z]->RC++;

						//If the node is also a treetop then set it to state/treetop.
						if ((Scaffold[0][cou_X][cou_Y][cou_Z]->Type == 2))
						{
							Scaffold[0][cou_X][cou_Y][cou_Z]->Type = 3;
						}
					}
				}
			}
		}
		if (p_How == "Query")
		{
			for (int cou_X = 0; cou_X < State_Depth_X; cou_X++)
			{
				for (int cou_Y = 0; cou_Y < State_Depth_Y; cou_Y++)
				{
					for (int cou_Z = 0; cou_Z < State_Depth_Z; cou_Z++)
					{
						//Request the state node form the node network using get_State_Node so one is created if not found.
						//We have to make sure we request the correct state tree.
						Scaffold[0][cou_X][cou_Y][cou_Z] = NNet->does_State_Node_Exist(State_Nodes_Index, Input_3D.get_Value(cou_X, cou_Y, cou_Z));
					}
				}
			}
		}
	}

	//Just one node at the tippy top.
	//p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.
	void fill_Scaffold(std::string p_How = "Encode")
	{
		if ((State_Depth_X == 0) || (State_Depth_Y == 0) || (State_Depth_Z == 0))
		{
			return;
		}

		//These hold the matrix we use to get the nodes to submit to the get upper tier node.
		//It takes 8 points to define a cube, each point is a sub-symbol, so we gather the 8 sub-symbols and abstract them.
		c_Node* tmp_Nodes[8];

		for (int cou_T = 1; cou_T < Top_Tier; cou_T++)
		{
			//---std::cerr << "\n T: " << cou_T;
			//The extra -1 is so we don't step to the last node and reach into the void.
			/*
			We need to take them in a 2x2x2 block my dude don't be rude or crude unless you've got a job to Derude.
			
			0[0, 0, 0] 1[1, 0, 0]
			2[0, 1, 0] 3[1, 1, 0]

			4[0, 0, 1] 5[1, 0, 1]
			6[0, 1, 1] 7[1, 1, 1]

			*/
			for (int cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)
			{
				for (int cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)
				{
					for (int cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)
					{
						//---std::cerr << " - " << cou_X << ", " << cou_Y << ", " << cou_Z;

						//Get the legs for the node, the 2x2
						tmp_Nodes[0] = Scaffold[cou_T - 1][cou_X][cou_Y][cou_Z];
						tmp_Nodes[1] = Scaffold[cou_T - 1][cou_X + 1][cou_Y][cou_Z];
						tmp_Nodes[2] = Scaffold[cou_T - 1][cou_X][cou_Y + 1][cou_Z];
						tmp_Nodes[3] = Scaffold[cou_T - 1][cou_X + 1][cou_Y + 1][cou_Z];

						tmp_Nodes[4] = Scaffold[cou_T - 1][cou_X][cou_Y][cou_Z + 1];
						tmp_Nodes[5] = Scaffold[cou_T - 1][cou_X + 1][cou_Y][cou_Z + 1];
						tmp_Nodes[6] = Scaffold[cou_T - 1][cou_X][cou_Y + 1][cou_Z + 1];
						tmp_Nodes[7] = Scaffold[cou_T - 1][cou_X + 1][cou_Y + 1][cou_Z + 1];

						if (p_How == "Encode")
						{
							//We request a node that links 4 nodes together.
							Scaffold[cou_T][cou_X][cou_Y][cou_Z] = NNet->get_Upper_Tier_Node(tmp_Nodes, 8, 1);
							Scaffold[cou_T][cou_X][cou_Y][cou_Z]->RC++;
							Scaffold[cou_T][cou_X][cou_Y][cou_Z]->rectify_Double_Legged_Nodes(); //Only need to do this for tiers 1+ as tier 0 doesn't have dendrites in this CAN.
						}
						if (p_How == "Query")
						{
							//We request a node that links the entire state tier together, but do not create them.
							Scaffold[cou_T][cou_X][cou_Y][cou_Z] = NNet->does_Upper_Tier_Connection_Exist(tmp_Nodes, 8);
						}
					}
				}
			}
		}

		if (p_How == "Encode")
		{
			for (int cou_X = 0; cou_X < (State_Depth_X - Top_Tier - 1); cou_X++)
			{
				for (int cou_Y = 0; cou_Y < (State_Depth_Y - Top_Tier - 1); cou_Y++)
				{
					for (int cou_Z = 0; cou_Z < (State_Depth_Z - Top_Tier - 1); cou_Z++)
					{
						Scaffold[Top_Tier - 1][cou_X][cou_Y][cou_Z]->Type = 2;
					}
				}
			}
		}
	}

	void check_Symbol()
	{
		//Set up the scaffold for the nodes to reside in as we build the trace.
		setup_CAN_Scaffold();

		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Query");

		//Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.
		fill_Scaffold("Query");
	}

	//Encodes a single trace, forcibly.
	//Arguments no longer used, need to remove during refactoria.
	void encode()
	{
		//Set up the scaffold for the nodes to reside in as we build the trace.
		setup_CAN_Scaffold();

		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Encode");

		//Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.
		fill_Scaffold("Encode");

		for (int cou_X = 0; cou_X < (State_Depth_X - (Top_Tier - 1)); cou_X++)
		{
			for (int cou_Y = 0; cou_Y < (State_Depth_Y - (Top_Tier - 1)); cou_Y++)
			{
				for (int cou_Z = 0; cou_Z < (State_Depth_Z - (Top_Tier - 1)); cou_Z++)
				{
					if (Scaffold[Top_Tier - 1][cou_X][cou_Y][cou_Z] != NULL)
					{
						std::cout << "\nTreetop: " << Scaffold[Top_Tier - 1][cou_X][cou_Y][cou_Z]->NID;
					}
					else
					{
						std::cout << "\nTreetop: NULL";
					}
				}
			}
		}
	}

	//Style determines whether it charges with normal submission of raw, or if it does the specific leg charging for Chrono.
	//Assumes the CAN is setup.
	void charge_Buffers(int p_Style = -1, int p_Leg = 0, int * p_Legs = NULL)
	{

		tmp_Buffman.reset();

		tmp_Buffman.Input_Position = 0;

		tmp_Buffman.charge_Outputs();

		for (int cou_T = Charging_Tier; cou_T < Top_Tier; cou_T++)
		{
			for (int cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)
			{
				for (int cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)
				{
					for (int cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)
					{
						if (Scaffold[cou_T][cou_X][cou_Y][cou_Z] != NULL)
						{
							if (p_Style == -1)
							{
								tmp_Buffman.submit(Scaffold[cou_T][cou_X][cou_Y][cou_Z], (tmp_Buffman.get_Base_Charge()));
							}
							if (p_Style == 1)
							{
								//This style not used in pyramidal.
								//tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_X][cou_Y], (tmp_Buffman.get_Base_Charge()), cou_Input);
							}
							if (p_Style == 2)
							{
								//p_Leg specifies which leg to charge in this function, p_Legs[] being unused.
								tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_X][cou_Y][cou_Z], (tmp_Buffman.get_Base_Charge()), p_Leg);
							}
							if (p_Style == 3)
							{
								//p_Leg is used here as the count of elements in p_Legs[].
								tmp_Buffman.charge_Given_Legs(Scaffold[cou_T][cou_X][cou_Y][cou_Z], p_Leg, p_Legs, (tmp_Buffman.get_Base_Charge()));
							}
						}
					}
				}
			}
		}

		tmp_Buffman.gather();

		while (tmp_Buffman.flg_Not_Done)
		{
			tmp_Buffman.charge_Outputs();

			tmp_Buffman.gather();
		}

		c_Charging_Linked_List * tmp_Current_LL = NULL;
		tmp_Current_LL = tmp_Buffman.Treetops.Root;
	}


	void gather_Treetops()
	{
		//---std::cout << "\n\n\n\n\n Gathering Treetops...";

		float tmp_Charge = 0.0;
		float tmp_H_Charge = tmp_Buffman.get_Treetops_Highest_Charge();
		if (tmp_H_Charge == 0) { return; }

		c_Charging_Linked_List* tmp_Current_LL = NULL;
		tmp_Current_LL = tmp_Buffman.Treetops.Root;

		//---tmp_Current_LL->output_LL();

		if (Output_3D != NULL) { delete[] Output_3D; Output_3D = NULL; }

		Output_3D = new c_3D_Trace[tmp_Buffman.Treetops.Depth];
		Output_Depth_3D = tmp_Buffman.Treetops.Depth;

		int tmp_Current_Index = 0;

		c_Linked_List_Handler tmp_Pattern;
		c_Linked_List_Handler tmp_Pattern_X;
		c_Linked_List_Handler tmp_Pattern_Y;
		c_Linked_List_Handler tmp_Pattern_Z;
		int tmp_Top_X = 0; //Loop through tmp_Pattern_X to find the highest.
		int tmp_Top_Y = 0; //Loop through tmp_Pattern_Y to find the highest.
		int tmp_Top_Z = 0; //Loop through tmp_Pattern_Y to find the highest.

		c_Linked_List* tmp_LL_Pat = NULL;
		c_Linked_List* tmp_LL_Pat_X = NULL;
		c_Linked_List* tmp_LL_Pat_Y = NULL;
		c_Linked_List* tmp_LL_Pat_Z = NULL;

		while (tmp_Current_LL != NULL)
		{
			tmp_Top_X = 0;
			tmp_Top_Y = 0;
			tmp_Top_Z = 0;

			tmp_Pattern.reset();
			tmp_Pattern_X.reset();
			tmp_Pattern_Y.reset();
			tmp_Pattern_Z.reset();

			//Get the pattern into a linked list
			tmp_Current_LL->NID->bp_3D_Trace_O(&tmp_Pattern, &tmp_Pattern_X, &tmp_Pattern_Y, &tmp_Pattern_Z);


			//We can iterate through given we know how big the linked list is.
			tmp_LL_Pat_X = tmp_Pattern_X.Root;

			tmp_Top_X = get_Top(&tmp_Pattern_X);
			tmp_Top_Y = get_Top(&tmp_Pattern_Y);
			tmp_Top_Z = get_Top(&tmp_Pattern_Z);

			//Copy the pattern over
			Output_3D[tmp_Current_Index].set_Depth(tmp_Top_X, tmp_Top_Y, tmp_Top_Z);

			//---std::cerr << "\n Depth Set";

			tmp_LL_Pat = tmp_Pattern.Root;
			tmp_LL_Pat_X = tmp_Pattern_X.Root;
			tmp_LL_Pat_Y = tmp_Pattern_Y.Root;
			tmp_LL_Pat_Z = tmp_Pattern_Z.Root;

			//---std::cout << "\n"; tmp_LL_Pat->output_LL();
			//---std::cout << "\n"; tmp_LL_Pat_X->output_LL();
			//---std::cout << "\n"; tmp_LL_Pat_Y->output_LL();
			//---std::cout << "\n"; tmp_LL_Pat_Z->output_LL();

			//We can iterate through given we know how big the linked list is.
			for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
			{
				Output_3D[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, int(tmp_LL_Pat_X->Quanta), int(tmp_LL_Pat_Y->Quanta), int(tmp_LL_Pat_Z->Quanta));
				tmp_LL_Pat = tmp_LL_Pat->Next;
				tmp_LL_Pat_X = tmp_LL_Pat_X->Next;
				tmp_LL_Pat_Y = tmp_LL_Pat_Y->Next;
				tmp_LL_Pat_Z = tmp_LL_Pat_Z->Next;
			}

			tmp_Charge = (tmp_Current_LL->Charge / tmp_H_Charge) * get_Base_Charge();
			Output_3D[tmp_Current_Index].set_Charge(tmp_Charge);
			//Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);
			Output_3D[tmp_Current_Index].set_RC(tmp_Current_LL->NID->RC);
			Output_3D[tmp_Current_Index].set_Treetop(tmp_Current_LL->NID);

			//---std::cout << "\n Output[" << tmp_Current_Index << "].Depth: " << Output_3D[tmp_Current_Index].Depth_X << ", " << Output_3D[tmp_Current_Index].Depth_Y << ", " << Output_3D[tmp_Current_Index].Depth_Z;
			//---std::cout << "\n Charge: " << tmp_Current_LL->Charge;

			//---std::cout << "\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;

			//---Output_3D[tmp_Current_Index].output(1);

			tmp_Current_LL = tmp_Current_LL->Next;

			tmp_Current_Index++;
		}

		tmp_Buffman.reset_Treetops();
	}

	void backpropagate_NID_Into_Given_Index(uint64_t p_NID, int p_Index, float p_Charge)
	{
		c_Linked_List_Handler tmp_Pattern;
		c_Linked_List_Handler tmp_Pattern_X;
		c_Linked_List_Handler tmp_Pattern_Y;
		c_Linked_List_Handler tmp_Pattern_Z;
		int tmp_Top_X = 0; //Loop through tmp_Pattern_X to find the highest.
		int tmp_Top_Y = 0; //Loop through tmp_Pattern_Y to find the highest.
		int tmp_Top_Z = 0; //Loop through tmp_Pattern_Y to find the highest.

		c_Linked_List* tmp_LL_Pat = NULL;
		c_Linked_List* tmp_LL_Pat_X = NULL;
		c_Linked_List* tmp_LL_Pat_Y = NULL;
		c_Linked_List* tmp_LL_Pat_Z = NULL;

		tmp_Pattern.reset();
		tmp_Pattern_X.reset();
		tmp_Pattern_Y.reset();
		tmp_Pattern_Z.reset();

		c_Node* tmp_Node = NNet->get_Node_Ref_By_NID(p_NID);

		if (tmp_Node == NULL) { std::cerr << "\n\n   v(o.O)V   Error in backpropagage_NID_Into_Given_Index, Node " << p_NID << " not found!"; }

		//Get the pattern into a linked list
		tmp_Node->bp_3D_Trace_O(&tmp_Pattern, &tmp_Pattern_X, &tmp_Pattern_Y, &tmp_Pattern_Z);

		tmp_Top_X = get_Top(&tmp_Pattern_X);
		tmp_Top_Y = get_Top(&tmp_Pattern_Y);
		tmp_Top_Z = get_Top(&tmp_Pattern_Z);

		//Copy the pattern over
		Output_3D[p_Index].set_Depth(tmp_Top_X, tmp_Top_Y, tmp_Top_Z);

		tmp_LL_Pat = tmp_Pattern.Root;
		tmp_LL_Pat_X = tmp_Pattern_X.Root;
		tmp_LL_Pat_Y = tmp_Pattern_Y.Root;
		tmp_LL_Pat_Z = tmp_Pattern_Z.Root;

		//We can iterate through given we know how big the linked list is.
		for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
		{
			Output_3D[p_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, int(tmp_LL_Pat_X->Quanta), int(tmp_LL_Pat_Y->Quanta), int(tmp_LL_Pat_Z->Quanta));
			tmp_LL_Pat = tmp_LL_Pat->Next;
			tmp_LL_Pat_X = tmp_LL_Pat_X->Next;
			tmp_LL_Pat_Y = tmp_LL_Pat_Y->Next;
			tmp_LL_Pat_Z = tmp_LL_Pat_Z->Next;
		}

		Output_3D[p_Index].set_Charge(p_Charge);
		Output_3D[p_Index].set_RC(tmp_Node->RC);
		Output_3D[p_Index].set_Treetop(tmp_Node);
	}

	//Gets a single trace from a given node. Puts it into the output.
	void gather_All_Traces()
	{
		c_Node* tmp_Node = NULL;
		tmp_Node = NNet->Root;

		if (Output_3D != NULL) { delete[] Output_3D; Output_3D = NULL; Output_Depth_3D = 0; }

		Output_3D = new c_3D_Trace[NNet->Node_Count];
		Output_Depth_3D = int(NNet->Node_Count);

		int tmp_Current_Index = 0;

		c_Linked_List_Handler tmp_Pattern;
		c_Linked_List_Handler tmp_Pattern_X;
		c_Linked_List_Handler tmp_Pattern_Y;
		c_Linked_List_Handler tmp_Pattern_Z;

		int tmp_Top_X = 0; //Loop through tmp_Pattern_X to find the highest.
		int tmp_Top_Y = 0; //Loop through tmp_Pattern_Y to find the highest.
		int tmp_Top_Z = 0; //Loop through tmp_Pattern_Y to find the highest.

		c_Linked_List* tmp_LL_Pat = NULL;
		c_Linked_List* tmp_LL_Pat_X = NULL;
		c_Linked_List* tmp_LL_Pat_Y = NULL;
		c_Linked_List* tmp_LL_Pat_Z = NULL;

		while (tmp_Node != NULL)
		{
			tmp_Top_X = 0;
			tmp_Top_Y = 0;
			tmp_Top_Z = 0;


			//If the node isn't 2D don't try to force it or you will crash.
			//if (tmp_Node->Dendrite_Count != 4) { tmp_Node = tmp_Node->Next; continue; }

			tmp_Pattern.reset();
			tmp_Pattern_X.reset();
			tmp_Pattern_Y.reset();
			tmp_Pattern_Z.reset();

			//Get the pattern into a linked list
			tmp_Node->bp_3D_Trace_O(&tmp_Pattern, &tmp_Pattern_X, &tmp_Pattern_Y, &tmp_Pattern_Z);

			tmp_Top_X = get_Top(&tmp_Pattern_X);
			tmp_Top_Y = get_Top(&tmp_Pattern_Y);
			tmp_Top_Z = get_Top(&tmp_Pattern_Z);

			//Copy the pattern over
			Output_3D[tmp_Current_Index].set_Depth(tmp_Top_X, tmp_Top_Y, tmp_Top_Z);

			tmp_LL_Pat = tmp_Pattern.Root;
			tmp_LL_Pat_X = tmp_Pattern_X.Root;
			tmp_LL_Pat_Y = tmp_Pattern_Y.Root;
			tmp_LL_Pat_Z = tmp_Pattern_Z.Root;

			//We can iterate through given we know how big the linked list is.
			for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
			{
				Output_3D[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, int(tmp_LL_Pat_X->Quanta), int(tmp_LL_Pat_Y->Quanta), int(tmp_LL_Pat_Z->Quanta));

				tmp_LL_Pat = tmp_LL_Pat->Next;
				tmp_LL_Pat_X = tmp_LL_Pat_X->Next;
				tmp_LL_Pat_Y = tmp_LL_Pat_Y->Next;
				tmp_LL_Pat_Z = tmp_LL_Pat_Z->Next;
			}

			//No charge set here
			Output_3D[tmp_Current_Index].set_RC(tmp_Node->RC);
			Output_3D[tmp_Current_Index].set_Treetop(tmp_Node);

			tmp_Current_Index++;

			tmp_Node = tmp_Node->Next;
		}
	}

	//Gets a single trace from a given node. Puts it into the output.
	void gather_Given_Trace(uint64_t p_NID)
	{
		//---std::cout << "\n\n Gathering Given Trace " << p_NID << "...";

		c_Node* tmp_Node = NULL;
		tmp_Node = NNet->get_Node_Ref_By_NID(p_NID);

		if (Output_3D != NULL) { delete[] Output_3D; Output_3D = NULL; Output_Depth_3D = 0; }

		Output_3D = new c_3D_Trace[1];
		Output_Depth_3D = 1;

		int tmp_Current_Index = 0;

		c_Linked_List_Handler tmp_Pattern;
		c_Linked_List_Handler tmp_Pattern_X;
		c_Linked_List_Handler tmp_Pattern_Y;
		c_Linked_List_Handler tmp_Pattern_Z;

		tmp_Pattern.reset();
		tmp_Pattern_X.reset();
		tmp_Pattern_Y.reset();
		tmp_Pattern_Z.reset();

		int tmp_Top_X = 0; //Loop through tmp_Pattern_X to find the highest.
		int tmp_Top_Y = 0; //Loop through tmp_Pattern_Y to find the highest.
		int tmp_Top_Z = 0; //Loop through tmp_Pattern_Y to find the highest.

		c_Linked_List* tmp_LL_Pat = NULL;
		c_Linked_List* tmp_LL_Pat_X = NULL;
		c_Linked_List* tmp_LL_Pat_Y = NULL;
		c_Linked_List* tmp_LL_Pat_Z = NULL;

		//Get the pattern into a linked list
		tmp_Node->bp_3D_Trace_O(&tmp_Pattern, &tmp_Pattern_X, &tmp_Pattern_Y, &tmp_Pattern_Z);

		tmp_LL_Pat_X = tmp_Pattern_X.Root;

		//We can iterate through given we know how big the linked list is.
		tmp_Top_X = get_Top(&tmp_Pattern_X);
		tmp_Top_Y = get_Top(&tmp_Pattern_Y);
		tmp_Top_Z = get_Top(&tmp_Pattern_Z);

		//Copy the pattern over
		Output_3D[0].set_Depth(tmp_Top_X, tmp_Top_Y, tmp_Top_Z);

		tmp_LL_Pat = tmp_Pattern.Root;
		tmp_LL_Pat_X = tmp_Pattern_X.Root;
		tmp_LL_Pat_Y = tmp_Pattern_Y.Root;
		tmp_LL_Pat_Z = tmp_Pattern_Z.Root;

		//We can iterate through given we know how big the linked list is.
		for (int cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)
		{
			Output_3D[0].set_Pattern_Index(tmp_LL_Pat->Quanta, int(tmp_LL_Pat_X->Quanta), int(tmp_LL_Pat_Y->Quanta), int(tmp_LL_Pat_Z->Quanta));

			tmp_LL_Pat = tmp_LL_Pat->Next;
			tmp_LL_Pat_X = tmp_LL_Pat_X->Next;
			tmp_LL_Pat_Y = tmp_LL_Pat_Y->Next;
			tmp_LL_Pat_Z = tmp_LL_Pat_Z->Next;
		}

		//No charge set here
		Output_3D[0].set_RC(tmp_Node->RC);
		Output_3D[0].set_Treetop(tmp_Node);

	}


	//Fills out the NULLCAN, does not forcibly encode, and then charges the network.
	//Charging style determines leg charging. May move it to be a setting.
	//     -1: Charge by giving the input node the base charge, normal node charging.
	//      1: Use leg specific charging to charge every node based on its position in the input array. Node[1] would charge axons on Axon[1][n].
	//      2: Charge every input on the given p_Leg, used mainly when inputing single values to charge. Allows you to input Node[x] as the only input to the Chrono and charge it using Axon[4][n], or any axon hillock you choose.
	//		 This allows you to search forward by setting a node early in the time series and searching forwards, or setting it late in the time series and searching backwards.
	void query(int p_Charging_Style = -1, int p_Leg = 0, int * p_Legs = NULL)
	{
		//Set up the scaffold for the nodes to reside in as we build the trace.
		setup_CAN_Scaffold();

		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Query");

		//Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.
		fill_Scaffold("Query");

		charge_Buffers(p_Charging_Style, p_Leg, p_Legs);

		//gather_Treetops();
	}

	//This allows for passing unordered sets of nodes
	void submit_Set(uint64_t* p_Input, int p_Depth)
	{
		//Firstly we gather the inputly
		set_Input(p_Input, p_Depth);

		//We only do the query on the state tier. This is because the nodes will not be in a coherent relationship to each other, only their presence is important.
		//The node adress being read in as the state means that the unordered set can be read in to the state tier because the shared memory space precludes duplicates, you just ignore any higher tiers than 0.
		//Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.
		fill_State("Query");

		//Then charge the buffers as normal.
		charge_Buffers();
	}

	//Gets the current treetop at the given index.
	c_Node* get_Treetop(int p_Index = -1)
	{
		if (Top_Tier > 0)
		{
			if (p_Index == -1)
			{
				return Scaffold[Top_Tier - 1][0][0][0];
			}

			//This construct is 4d which means at the highest point of 8 legged nodes before it turns to 2D then the dimension which is longer than the pyramid is tall will have treetops in a 1D line, like if you took a pyramid of Gaza and click-dragged it sideways with tracers on. Same with this 3D object except describing dragging a 3D 0bject is not intuitive to monke brayne.
			if (State_Depth_X >= Top_Tier)
			{
				return Scaffold[Top_Tier - 1][p_Index][0][0];
			}
			//>= in case X == Y and we don't want fall-through on a perfect one.
			if (State_Depth_Y >= Top_Tier)
			{
				return Scaffold[Top_Tier - 1][0][p_Index][0];
			}
			//>= in case X == Y == Z and we don't want fall-through on a perfect one.
			if (State_Depth_Z >= Top_Tier)
			{
				return Scaffold[Top_Tier - 1][0][0][p_Index];
			}
		}
		return NULL;
	}

	//Returns the dimension of the data.
	int get_Dimension()
	{
		return 3;
	}

	//Outputs the scaffold.
	void output_Scaffold()
	{
		for (int cou_T = 0; cou_T < Top_Tier; cou_T++)
		{
			std::cout << "\n <- Tier[" << cou_T << "] ->";
			for (int cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)
			{
				std::cout << "\n";
				for (int cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)
				{
					std::cout << "\n";
					for (int cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)
					{
						std::cout << " [";
						if (Scaffold[cou_T][cou_X][cou_Y][cou_Z] != NULL) { std::cout << Scaffold[cou_T][cou_X][cou_Y][cou_Z]->NID; } else { std::cout << "NULL"; }
						std::cout << "] ";
					}
				}
			}
			std::cout << "\n";
		}
	}

	//Outputs the scaffold as character representing the address.
	void output_Scaffold_Char()
	{
		std::cout << "\n Top_Tier: " << Top_Tier;
		for (int cou_T = 0; cou_T < Top_Tier; cou_T++)
		{
			std::cout << "\n[" << cou_T << "]";
			for (int cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)
			{
				std::cout << "\n";
				for (int cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)
				{
					std::cout << "\n[";
					for (int cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)
					{
						std::cout << static_cast<char>(uint64_t(Scaffold[cou_T][cou_X][cou_Y][cou_Z]) & 0xFF);
					}
					std::cout << "]";
				}
			}
		}
	}

	void output_Scaffold_Tops()
	{

	}

	//Outputs the scaffold as character representing the address. Currently only 1D supports this.
	void output_Scaffold_Symbols(int p_Type = 0)
	{
	}
};
/** \addtogroup Construct
 *  @{
 */

 /** \class c_Construct
	 \brief This class encapsulates and manipulates the Neural Network Engine directly while providing a public interface.

	 Inside the construct you'll find the raw C++. The interface brings highly granular control from the sub-classes to the surface. On this interface the other ones are built.

 */

//The construct encapsulates the node network, the CANs, I/O, granulation filter, uinterface, actuator interface, and I/O tables.
//The result is that after setting up the network the user can use it like a black box.
class c_Construct
{
public:

	//The shared node network.
	c_Node_Network Nodes;

	//The lookup tree for Construct names.
	c_Lookup_Tree Construct_Name_Tree;

	struct s_Construct
	{
		//The names of each Construct within the construct.
		std::string Name;

		//These are the files each Construct uses for input, defaults to "Input.ssv"
		std::string Input_File;

		//This file is is for the configuration file for the hyperparameters and other things
		std::string Config_File;

		//The file for each Construct to use as output.
		std::string Output_File;

		//This holds the CAN scaffold structures.
		//c_Base_CAN is a base class.
		c_Base_CAN* CAN;

		//This array keeps track of what type each CAN is.
		std::string CAN_Type;

		//This is the count of lower constructs.
		int Connection_Count;

		//These are the IDs of the lower constructs to connect to.
		int* Connections;

		s_Construct()
		{
			Name = "UNINITIALIZED";
			Input_File = "";
			Config_File = "";
			Output_File = "";
			CAN = NULL;
			CAN_Type = "UNINITIALIZED";
			Connection_Count = 0;
			Connections = NULL;
		}
	};

	s_Construct** Constructs;

	//For each Construct we have an index in the State_Tree[], CAN[], etc.
	int Construct_Count;

	c_Construct()
	{
		Construct_Count = 0; //Variables dependent on this value: Construct_Names, CAN
		Constructs = NULL;
	}

	//I need to refactor this jfc
	int add_Construct(std::string p_Construct_Name)
	{
		Construct_Name_Tree.search(p_Construct_Name);

		if (Construct_Name_Tree.flg_Foundit == 1) { std::cerr << "\n\n   V(O.o)/   Error: Construct [" << p_Construct_Name << "] already exists!"; return -1; }

		Construct_Name_Tree.set_Current_Data(Construct_Count);

		//Construct_Name_Tree.output_Tree();

		s_Construct** tmp_Constructs = NULL;

		tmp_Constructs = new s_Construct * [Construct_Count];

		for (int cou_Index = 0; cou_Index < Construct_Count; cou_Index++)
		{
			tmp_Constructs[cou_Index] = Constructs[cou_Index];
			Constructs[cou_Index] = NULL;
		}

		if (Constructs != NULL) { delete[] Constructs; }

		Constructs = new s_Construct * [Construct_Count + 1];


		for (int cou_Index = 0; cou_Index < Construct_Count; cou_Index++)
		{
			Constructs[cou_Index] = tmp_Constructs[cou_Index];
			tmp_Constructs[cou_Index] = NULL;
		}

		delete[] tmp_Constructs; tmp_Constructs = NULL;

		Constructs[Construct_Count] = new s_Construct;

		Constructs[Construct_Count]->Name = p_Construct_Name;

		//The reason the .Input and .Output are appended even though they are in folders named input and output this allows you to copy them into the same dir if you feel like it.
		Constructs[Construct_Count]->Input_File = "./Input/" + p_Construct_Name + ".Input.ssv";
		Constructs[Construct_Count]->Config_File = "./Config/" + p_Construct_Name + ".Config.ssv";
		Constructs[Construct_Count]->Output_File = "./Output/" + p_Construct_Name + ".Output.ssv";

		std::ofstream tmp_IF(Constructs[Construct_Count]->Input_File, std::ios::app);
		tmp_IF.close();

		std::ofstream tmp_CF(Constructs[Construct_Count]->Config_File, std::ios::app);
		tmp_CF.close();

		std::ofstream tmp_OF(Constructs[Construct_Count]->Output_File, std::ios::app);
		tmp_OF.close();

		//The CAN is made later because there are different subtypes.
		Constructs[Construct_Count]->CAN = NULL;

		Constructs[Construct_Count]->CAN_Type = "NONE";

		Constructs[Construct_Count]->Connection_Count = 0;

		Constructs[Construct_Count]->Connections = NULL;

		Construct_Count++;

		//Return the index of the newly created Construct.
		return Construct_Count - 1;
	}

	int get_Construct_ID(std::string p_Construct_Name)
	{
		Construct_Name_Tree.search(p_Construct_Name);

		if (Construct_Name_Tree.flg_Foundit == 1) { return int(Construct_Name_Tree.get_Current_Data()); }
		std::cout << "\n   ^(o.O)V   ERROR: Construct ID [" << p_Construct_Name << "] not found!";
		return -1;
	}

	void chrono_Shift(int p_Construct)
	{
		Constructs[p_Construct]->CAN->chrono_Shift();
	}

	void add_Chrono(int p_Construct, uint64_t p_Chrono)
	{
		Constructs[p_Construct]->CAN->add_Chrono(p_Chrono);
	}

	void add_Connection_Index(int p_Construct)
	{
		int* tmp_Connections = new int[Constructs[p_Construct]->Connection_Count];

		if (Constructs[p_Construct]->Connection_Count > 0)
		{
			for (int cou_Index = 0; cou_Index < Constructs[p_Construct]->Connection_Count; cou_Index++)
			{
				tmp_Connections[cou_Index] = Constructs[p_Construct]->Connections[cou_Index];
			}

			delete[] Constructs[p_Construct]->Connections;
			Constructs[p_Construct]->Connections = NULL;
		}

		Constructs[p_Construct]->Connections = new int[Constructs[p_Construct]->Connection_Count + 1];

		for (int cou_Index = 0; cou_Index < Constructs[p_Construct]->Connection_Count; cou_Index++)
		{
			Constructs[p_Construct]->Connections[cou_Index] = tmp_Connections[cou_Index];
		}

		if (tmp_Connections != NULL) { delete[] tmp_Connections; tmp_Connections = NULL; }

		Constructs[p_Construct]->Connections[Constructs[p_Construct]->Connection_Count] = 0;

		Constructs[p_Construct]->Connection_Count++;
	}

	void create_Construct_Connection(int p_From, int p_To)
	{
		add_Connection_Index(p_To);

		Constructs[p_To]->Connections[Constructs[p_To]->Connection_Count - 1] = p_From;
	}

	void output_Construct_Connections(int p_Construct)
	{
		if (p_Construct == -1) { return; }
		std::cout << "\n\nLower Connections for " << Constructs[p_Construct]->Name;
		for (int cou_Index = 0; cou_Index < Constructs[p_Construct]->Connection_Count; cou_Index++)
		{
			int tmp_Con = Constructs[p_Construct]->Connections[cou_Index];
			std::cout << "\n [" << cou_Index << "] " << Constructs[tmp_Con]->Name;
		}
	}


	//==--- DIRECT_HOOK ---==//
	//This doesn't make sense to run through the API
	c_Node* get_Node_Ref_By_NID(uint64_t p_NID)
	{
		return Nodes.get_Node_Ref_By_NID(p_NID);
	}






	//      ---==================---
	//     ---====================---
	//    ---======================---
	//   ---========================---
	//  ---==   NT4 Deep Control   ==---
	//   ---========================---
	//    ---======================---
	//     ---====================---
	//      ---==================---



	//    ---==========---
	//   ---============---
	//  ---==   Node   ==---
	//   ---============---
	//    ---==========---

		//==--- DIRECT_HOOK ---==//
		//(0: State), (1: Branch), (2: Treetop), (3: State/Treetop)
	void set_Type(c_Node* p_Node, uint8_t p_Type)
	{
		if (p_Node != NULL)
		{
			p_Node->set_Type(p_Type);
		}
	}


	//==--- DIRECT_HOOK ---==//
	//Adds an axon to the axon list at the given index, if the index doesn't exist then exist it with resize_Axon_Hillocks()
	void add_Axon_Index(c_Node* p_Node, c_Node* p_Axon, int p_Index)
	{
		if (p_Node != NULL)
		{
			p_Node->add_Axon_Index(p_Axon, p_Index);
		}
	}


	//==--- DIRECT_HOOK ---==//
	//Sets the dendrites of the node.
	//This assumes the node has no dendrites yet, if it does you be dangling and jangling
	void set_Dendrites(c_Node* p_Node, int p_Count, c_Node** p_Dendrites)
	{
		if (p_Node != NULL)
		{
			p_Node->set_Dendrites(p_Dendrites, p_Count);
		}
	}


	//==--- DIRECT_HOOK ---==//
	//Searches the axons to see if an upper tier connection exists.
	//This is always called from the first leg, that is why we separate _F from normal.
	c_Node* does_Upper_Tier_Connection_Exist(int p_Count, c_Node** p_Nodes)
	{
		return Nodes.does_Upper_Tier_Connection_Exist(p_Nodes, p_Count);
	}


	//==--- DIRECT_HOOK ---==//
	//Checks if the given node matches a dendrite on the right leg.
	bool does_Lower_Connection_Exist(c_Node* p_Node, int p_Count, c_Node** p_Nodes)
	{
		if (p_Node != NULL)
		{
			return p_Node->does_Lower_Connection_Exist(p_Nodes, p_Count);
		}
		return 0;
	}



	//==--- DIRECT_HOOK ---==//
	//Binds a node to a quanta of data, the state of the input.
	void bind_State(c_Node* p_Node, uint64_t p_State)
	{
		if (p_Node != NULL)
		{
			p_Node->bind_State(p_State);
		}
	}



	//==--- DIRECT_HOOK ---==//
	//Initiates a backpropagation that outputs the pattern represented by this node.
	void bp_O(c_Node* p_Node)
	{
		if (p_Node != NULL)
		{
			p_Node->bp_O();
		}
	}



	//==--- DIRECT_HOOK ---==//
	//The CAN handles this for backpropagating a trace into a given CAN input. "gather_Given_Trace(uint64_t p_NID)"
	void bp_Trace_O(c_Node* p_Node, c_Linked_List_Handler* p_LL)
	{
		if ((p_Node != NULL) && (p_LL != NULL))
		{
			p_Node->bp_Trace_O(p_LL);
		}
	}



	//==--- DIRECT_HOOK ---==//
	//Outputs the ugly raw info dump for the node.
	void output_Node_Raw(c_Node* p_Node)
	{
		if (p_Node != NULL)
		{
			p_Node->output_Node_Raw();
		}
	}



	//==--- DIRECT_HOOK ---==//
	//Outputs the ugly raw info dump for the node.
	void output_Treetop_Node_Raw(int p_Construct)
	{
		if ((Constructs[p_Construct]->CAN->get_Treetop()) != NULL)
		{
			(Constructs[p_Construct]->CAN->get_Treetop())->output_Node_Raw();
		}
	}



	//==--- DIRECT_HOOK ---==//
	//Casts the node address to char() and outputs it.
	void output_Node_Char(c_Node* p_Node)
	{
		if (p_Node != NULL)
		{
			p_Node->output_Node_Char();
		}
	}





	//    ---==================---
	//   ---====================---
	//  ---==   Node_Network   ==---
	//   ---====================---
	//    ---==================---

		//==--- DIRECT_HOOK ---==//
		//Creates a new node and adds it to the fractal tree.
		//Each node is stored as a link in a linked list.
	c_Node* new_Node()
	{
		return Nodes.new_Node();
	}


	//==--- DIRECT_HOOK ---==//
	//Creates a new node, then adds it to the state tree.
	//Assumes the construct is already registered so the index is valid.
	c_Node* new_State_Node(int p_Construct, uint64_t p_State)
	{
		return Nodes.new_State_Node(p_Construct, p_State);
	}


	//==--- DIRECT_HOOK ---==//
	//Creates a connection between nodes.
	//p_To forms dendritic connections to p_From, and on p_From you have the axonic connections.
	void create_Connections(c_Node* p_To, int p_Count, c_Node** p_From)
	{
		Nodes.create_Connections(p_To, p_From, p_Count);
	}


	//==--- DIRECT_HOOK ---==//
	//Checks if an upper tier node exists.
	c_Node* does_Upper_Tier_Connection_Exist_Network(int p_Count, c_Node** p_Legs)
	{
		return Nodes.does_Upper_Tier_Connection_Exist(p_Legs, p_Count);
	}


	//==--- DIRECT_HOOK ---==//
	//Gets an upper tier node based on the given legs. Will create it if not found and give it the type 1.
	c_Node* get_Upper_Tier_Node(int p_Count, c_Node** p_Legs)
	{
		return Nodes.get_Upper_Tier_Node(p_Legs, p_Count, 1);
	}


	//==--- DIRECT_HOOK ---==//
	//If a state node exists in the given construct index then return it.
	//Otherwise return NULL.
	//This assumes the [Index] is valid
	c_Node* does_State_Node_Exist(int p_Construct, uint64_t p_State)
	{
		return Nodes.does_State_Node_Exist(p_Construct, p_State);
	}


	//==--- DIRECT_HOOK ---==//
	//Checks to see if a node in the given Construct is bound to the given state, if not the node is created.
	c_Node* get_State_Node(int p_Construct, uint64_t p_State)
	{
		return Nodes.get_State_Node(p_Construct, p_State);
	}


	//==--- DIRECT_HOOK ---==//
	//Iterates through every node and outputs their bp_O()
	void output_Backpropagated_Symbols(int p_Datatype = 0)
	{
		Nodes.output_BP(p_Datatype);
	}


	//==--- DIRECT_HOOK ---==//
	//Finds given NID and outputs the bp_O()
	void output_Backpropagated_Symbol_NID(uint64_t p_NID)
	{
		Nodes.output_BP_NID(p_NID);
	}


	void output_Backpropagated_Symbol_NID_uint(uint64_t p_NID)
	{
		Nodes.output_Symbol_uint(p_NID);
	}


	//---==  DIRECT_HOOK  ==---//
	//Outputs all of the nodes as raw.
	void output_Node_Network()
	{
		Nodes.output_Raw();
	}



	//    ---=========---
	//   ---===========---
	//  ---==   CAN   ==---
	//   ---===========---
	//    ---=========---



	//==--- DIRECT_HOOK ---==//
	//This encodes the p_Input data, if the nodes aren't found they are created, used for training.
	void encode(int p_Construct)
	{
		Constructs[p_Construct]->CAN->encode();
	}
	

	void check_Symbol(int p_Construct)
	{
		Constructs[p_Construct]->CAN->check_Symbol();
	}

	//==--- DIRECT_HOOK ---==//
	//This sets up the scaffold as encode does, but it doesn't create nodes if they aren't found, they remain NULL in the scaffold, this we call a NULLCAN
	//Used for querying the network, you input, fill the NULLCAN, charge the network, then gather the outputs.
	//Suggested for use before encoding (if using learning mode and not locked_to_initial_training_mode) otherwise it will also find the current trace as the perfect match.
	void query(int p_Construct, int p_Charging_Style = -1, int p_Leg = 0, int* p_Legs = NULL)
	{
		if (p_Charging_Style == 4) { wipe_Network_Charges(); output_Network_Charges(); }
		
		Constructs[p_Construct]->CAN->query(p_Charging_Style, p_Leg, p_Legs);

		if (p_Charging_Style == 4) { output_Network_Charges(); }
	}


	//==--- DIRECT_HOOK ---==//
	//This allows for passing unordered sets of nodes
	void submit_Set(int p_Construct, int p_Depth, uint64_t* p_Input)
	{
		Constructs[p_Construct]->CAN->submit_Set(p_Input, p_Depth);
	}


	//==--- DIRECT_HOOK ---==//
	//Gets the treetop node for a given Construct.
	//This doesn't make sense to create an API for.
	//This returns the treetop node at a given index, for most structures this will be a single node, but for those like stiched-base networks with a treetop node count equal to the input node count then you can access them by index.
	c_Node* get_Treetop(int p_Construct)
	{
		return (Constructs[p_Construct]->CAN->get_Treetop());
	}


	//==--- DIRECT_HOOK ---==//
	//Gets the treetop node for a given Construct.
	uint64_t get_Treetop_NID(int p_Construct)
	{
		if (Constructs[p_Construct]->CAN->get_Treetop() != NULL)
		{
			return (Constructs[p_Construct]->CAN->get_Treetop())->NID;
		}
		return 0;
	}


	//==--- DIRECT_HOOK ---==//
	//Gets the treetop node for a given Construct.
	uint64_t get_Treetop_NID_At_Given_Index(int p_Construct, int p_Index)
	{
		if (Constructs[p_Construct]->CAN->get_Treetop(p_Index) != NULL)
		{
			return (Constructs[p_Construct]->CAN->get_Treetop(p_Index))->NID;
		}
		return 0;
	}


	//==--- DIRECT_HOOK ---==//
	//Gets a single trace from a given node. Puts it into the output.
	void gather_Given_Trace(int p_Construct, uint64_t p_NID)
	{
		Constructs[p_Construct]->CAN->gather_Given_Trace(p_NID);

		gather_Output(p_Construct);
	}


	//==--- DIRECT_HOOK ---==//
	//Gets a single trace from a given node. Puts it into the output.
	void write_Given_Pattern_As_Number(int p_Construct, uint64_t p_NID)
	{
		Constructs[p_Construct]->CAN->gather_Given_Trace(p_NID);

		gather_Output_uint(p_Construct);
	}


	//==--- DIRECT_HOOK ---==//
	//Gets a single trace from a given node. Puts it into the output.
	void gather_Given_Trace_uint(int p_Construct, uint64_t p_NID)
	{
		Constructs[p_Construct]->CAN->gather_Given_Trace(p_NID);

		gather_Output_uint(p_Construct);
	}


	//==--- DIRECT_HOOK ---==//
	//Gathers all the traces as it says.
	void gather_All_Traces(int p_Construct)
	{
		Constructs[p_Construct]->CAN->gather_All_Traces();

		gather_Output(p_Construct);
	}  


	//==--- DIRECT_HOOK ---==//
	//Gathers all the traces as it says.
	void gather_All_Traces_uint(int p_Construct)
	{
		Constructs[p_Construct]->CAN->gather_All_Traces();

		gather_Output_uint(p_Construct);
	}


	//==--- DIRECT_HOOK ---==//
	//Wipe the input array.
	void reset_Input(int p_Construct)
	{
		Constructs[p_Construct]->CAN->reset_Input();
	}



	//==--- DIRECT_HOOK ---==//
	//Wipe the input array.
	void reset_Output(int p_Construct)
	{
		Constructs[p_Construct]->CAN->reset_Output();
	}


	//==--- DIRECT_HOOK ---==//
	//Associate the CAN with a network from which to draw nodes.
	//This doesn't make sense to wrap in the API.
	void set_NNet(int p_Construct, c_Node_Network* p_NNet)
	{
		Constructs[p_Construct]->CAN->set_NNet(p_NNet);
	}


	//==--- DIRECT_HOOK ---==//
	//Sets the index for the state_Node_Tree in the c_Node_Network::State_Nodes[]
	void set_State_Nodes_Index(int p_Construct, int p_Index)
	{
		Constructs[p_Construct]->CAN->set_State_Nodes_Index(p_Index);
	}


	//==--- DIRECT_HOOK ---==//
	//Sets the input to the given uint64_t array.
	//The input array is 1D.
	void set_Input(int p_Construct, int p_Input_Depth, uint64_t* p_Input)
	{
		Constructs[p_Construct]->CAN->set_Input(p_Input, p_Input_Depth);
	}

	//==--- DIRECT_HOOK ---==//
	//Sets the input to the given uint64_t array.
	//The input array is 2D.
	void set_2D_Input(int p_Construct, int p_X_Depth, int p_Y_Depth, uint64_t** p_Input)
	{
		Constructs[p_Construct]->CAN->set_2D_Input(p_Input, p_X_Depth, p_Y_Depth);
	}

	//==--- DIRECT_HOOK ---==//
	//Sets the input to the given uint64_t array.
	//The input array is 3D.
	void set_3D_Input(int p_Construct, int p_X_Depth, int p_Y_Depth, int p_Z_Depth, uint64_t*** p_Input)
	{
		Constructs[p_Construct]->CAN->set_3D_Input(p_Input, p_X_Depth, p_Y_Depth, p_Z_Depth);
	}


	//==--- DIRECT_HOOK ---==//
	//This is used for setting the input array to reflect a sequence of characters.
	void set_Input_String(int p_Construct, std::string p_Input)
	{
		Constructs[p_Construct]->CAN->set_Input_String(p_Input);
	}


	//==--- DIRECT_HOOK ---==//
	//Outputs the scaffold as addresses.
	void output_Scaffold(int p_Construct)
	{
		Constructs[p_Construct]->CAN->output_Scaffold();
	}


	//==--- DIRECT_HOOK ---==//	
	//==--- CLI_HOOK ---==//	
	//    ---==  output_input [Construct_ID]  ==---
	//		Outputs the input of the given Construct to the console.
	//Outputs the input for the Construct.
	void output_Input(int p_Construct)
	{
		Constructs[p_Construct]->CAN->output_Input();
	}


	//==--- DIRECT_HOOK ---==//	
	//==--- CLI_HOOK ---==//	
	//    ---==  output_input [Construct_ID]  ==---
	//		Outputs the input of the given Construct to the console.
	//Outputs the input for the Construct.
	void output_Input_uint(int p_Construct)
	{
		Constructs[p_Construct]->CAN->output_Input(1);
	}


	//==--- DIRECT_HOOK ---==//
	//The output trace set is output.
	void output_Output(int p_Construct)
	{
		Constructs[p_Construct]->CAN->output_Output(0);
	}


	//==--- DIRECT_HOOK ---==//
	//The output trace set is output.
	void output_Output_uint(int p_Construct)
	{
		Constructs[p_Construct]->CAN->output_Output(1);
	}


	//==--- DIRECT_HOOK ---==//
	//The output trace set is output.
	void output_Output_Double(int p_Construct)
	{
		Constructs[p_Construct]->CAN->output_Output(2);
	}


	//==--- DIRECT_HOOK ---==//
	//The output trace set is output.
	void output_Output_Int(int p_Construct)
	{
		Constructs[p_Construct]->CAN->output_Output(3);
	}


	//==--- DIRECT_HOOK ---==//
	//Each address is typecast to a char to give a pseudo-unique look to each node. For monke brain.
	void output_Scaffold_Char(int p_Construct)
	{
		Constructs[p_Construct]->CAN->output_Scaffold_Char();
	}

	//==--- DIRECT_HOOK ---==//
	//Each address is typecast to a char to give a pseudo-unique look to each node. For monke brain.
	//Type: 0 = char, 1 = uint64_t
	void output_Scaffold_Symbols(int p_Construct, int p_Type = 0)
	{
		Constructs[p_Construct]->CAN->output_Scaffold_Symbols(p_Type);
	}

	void output_Scaffold_Symbols_uint(int p_Construct)
	{
		output_Scaffold_Symbols(p_Construct, 1);
	}

	void output_Scaffold_Symbols_Float(int p_Construct)
	{
		output_Scaffold_Symbols(p_Construct, 2);
	}





	//      ---====================---
	//     ---======================---
	//    ---========================---
	//   ---==========================---
	//  ---==   NT4 specific hooks   ==---
	//   ---==========================---
	//    ---========================---
	//     ---======================---
	//      ---====================---


	//Used to wipe the charges of the network.
	void wipe_Network_Charges()
	{
		c_Node* tmp_Node = NULL;
		tmp_Node = Nodes.Root;

		while (tmp_Node != NULL)
		{
			tmp_Node->Charge = 0;

			tmp_Node = tmp_Node->Next;
		}
	}

	void output_Network_Charges(std::string p_FName_Prefix = "")
	{
		std::cout << "\n Charges:";
		c_Node* tmp_Node = NULL;
		tmp_Node = Nodes.Root;
		
		std::string tmp_OFName = "";

		if (p_FName_Prefix != "")
		{
			tmp_OFName = "./Testing/" + p_FName_Prefix + "node_Charge_Output.ssv";
		}
		else
		{
			tmp_OFName = "./Testing/node_Charge_Output.ssv";
		}

		std::ofstream OF;
		//std::ofstream OFXY;
		//std::ofstream OFRC;
		OF.open(tmp_OFName, std::ios::app);
		//OFXY.open("./Testing/Node_Network_Output/node_Charge_Output_XY.dat", std::ios::app);
		//OFRC.open("./Testing/Node_Network_Output/node_RC_Output.dat", std::ios::app);

		int tmp_Cur = 0;
		char tmp_Char = ' ';
		
		int tmp_Top_Tier = 0;

		tmp_Node = NULL;
		tmp_Node = Nodes.Root;
		
		std::cout << "\n Finding Top_Tier & Widest_Tier...";
		while (tmp_Node != NULL)
		{
			if (tmp_Top_Tier <= tmp_Node->Tier)
			{
				tmp_Top_Tier = tmp_Node->Tier + 1;
			}

			tmp_Node = tmp_Node->Next;
		}

		std::cout << "Top_Tier: " << tmp_Top_Tier;

		std::vector<int> Skipdex;
		Skipdex.resize(tmp_Top_Tier);

		float tmp_Skipval = 0.0;
		float tmp_Skipcur = 0.0;

		std::cout << "\n SkipDex Building...";

		for (int cou_T = 0; cou_T < tmp_Top_Tier; cou_T++)
		{
			Skipdex[cou_T] = 0;
		}

		tmp_Node = NULL;
		tmp_Node = Nodes.Root;

		while (tmp_Node != NULL)
		{
			Skipdex[tmp_Node->Tier]++;

			if (Nodes.Fat_Tier < Skipdex[tmp_Node->Tier])
			{ 
				Nodes.Fat_Tier = Skipdex[tmp_Node->Tier];
			}

			tmp_Node = tmp_Node->Next;

		}

		std::cout << "\n Constructing XY Mapping...";

		std::vector<int> Skipdex_Cur;
		std::vector<int> Skipdex_Val;

		std::vector<std::vector<std::string>> Skipdex_Out;
		//std::vector<std::vector<std::string>> Skipdex_RC_Out;
		//std::vector<std::vector<std::string>> Skipdex_XY_Out;

		Skipdex_Cur.resize(tmp_Top_Tier);
		Skipdex_Val.resize(tmp_Top_Tier);

		Skipdex_Out.resize(tmp_Top_Tier);
		//Skipdex_RC_Out.resize(tmp_Top_Tier);
		//Skipdex_XY_Out.resize(tmp_Top_Tier);

		std::cout << "Allocating Memory...";
		for (int cou_T = 0; cou_T < tmp_Top_Tier; cou_T++)
		{
			Skipdex_Cur[cou_T] = 0;
			Skipdex_Val[cou_T] = Nodes.Fat_Tier / Skipdex[cou_T];

			Skipdex_Out[cou_T].resize(Nodes.Fat_Tier);
			//Skipdex_RC_Out[cou_T].resize(Nodes.Fat_Tier);
			//Skipdex_XY_Out[cou_T].resize(Nodes.Fat_Tier);

			/*
			for (int cou_FT = 0; cou_FT < Nodes.Fat_Tier; cou_FT++)
			{
				Skipdex_Out[cou_T][cou_FT] = " 0";
				Skipdex_RC_Out[cou_T][cou_FT] = " 0";
				Skipdex_XY_Out[cou_T][cou_FT] = "\n(" + std::to_string(cou_FT) + ", " + std::to_string(cou_T) + ") 0";
			}
			*/
		}

		tmp_Node = NULL;
		tmp_Node = Nodes.Root;

		std::cout << "Calculating XY...";
		while (tmp_Node != NULL)
		{
			Skipdex_Out[tmp_Node->Tier][int(Skipdex_Cur[tmp_Node->Tier])] = " " + std::to_string(tmp_Node->Charge);
			//Skipdex_RC_Out[tmp_Node->Tier][int(Skipdex_Cur[tmp_Node->Tier])] = " " + std::to_string(tmp_Node->RC);
			//Skipdex_XY_Out[tmp_Node->Tier][int(Skipdex_Cur[tmp_Node->Tier])] = "\n(" + std::to_string(int(Skipdex_Cur[tmp_Node->Tier])) + ", " + std::to_string(tmp_Node->Tier) + ") " + std::to_string(tmp_Node->NID);

			tmp_Node->Index = int(Skipdex_Cur[tmp_Node->Tier]);

			Skipdex_Cur[tmp_Node->Tier] += Skipdex_Val[tmp_Node->Tier];

			if (Skipdex_Cur[tmp_Node->Tier] >= Nodes.Fat_Tier) { Skipdex_Cur[tmp_Node->Tier] = Nodes.Fat_Tier - 1; }

			//Skipdex_Cur[tmp_Node->Tier]++;

			tmp_Node = tmp_Node->Next;
		}

		std::cout << "Writing Files...";
		/*
		for (int cou_I = 0; cou_I < Nodes.Fat_Tier; cou_I++)
		{
			OF << " 0";
			OFRC << " 0";
		}
		*/
		for (int cou_T = 0; cou_T < tmp_Top_Tier; cou_T++)
		{
			OF << "\n";
			//OFXY << "\n";
			//OFRC << "\n";

			OF << " " << cou_T << " ";
			//OFRC << " " << cou_T << " ";

			for (int cou_I = 0; cou_I < Nodes.Fat_Tier; cou_I++)
			{
				if (Skipdex_Out[cou_T][cou_I] == "") 
				{
					OF << " 0";
					//OFRC << " 0";
					//OFXY << "\n(" + std::to_string(cou_I) + ", " + std::to_string(cou_T) + ") 0";
					continue;
				}

				OF << Skipdex_Out[cou_T][cou_I];
				//OFRC << Skipdex_RC_Out[cou_T][cou_I];
				//OFXY << Skipdex_XY_Out[cou_T][cou_I];

			}
		}
		/*
		OF << "\n";
		OFXY << "\n";
		OFRC << "\n";
		for (int cou_I = 0; cou_I < Nodes.Fat_Tier; cou_I++)
		{
			OF << " 0";
			OFRC << " 0";
		}
		OF << "\n";
		OFXY << "\n";
		OFRC << "\n";*/

		OF.close();
		//OFRC.close();
		//OFXY.close();

		/*
		tmp_Node = NULL;
		tmp_Node = Nodes.Root;

		for (int cou_T = 0; cou_T < tmp_Top_Tier; cou_T++)
		{
			tmp_Node = NULL;
			tmp_Node = Nodes.Root;
			
			OF << "\n";
			OFXY << "\n";
			OFRC << "\n";
			//std::cout << "\n";

			tmp_Skipcur = 0.0;
			tmp_Skipval = Nodes.Fat_Tier / Skipdex[cou_T];

			std::vector<std::string> tmp_Out;
			std::vector<std::string> tmp_RC_Out;
			std::vector<std::string> tmp_XY_Out;
			tmp_Out.resize(Nodes.Fat_Tier);
			tmp_RC_Out.resize(Nodes.Fat_Tier);
			tmp_XY_Out.resize(Nodes.Fat_Tier);
			
			for (int cou_FT = 0; cou_FT < Nodes.Fat_Tier; cou_FT++)
			{
				tmp_Out[cou_FT] = " 0";
				tmp_RC_Out[cou_FT] = " 0";
				tmp_XY_Out[cou_FT] = "\n(" + std::to_string(cou_FT) + ", " + std::to_string(cou_T) + ") 0";
			}



			tmp_Cur = 0;


			while (tmp_Node != NULL)
			{
				if (tmp_Node->Tier == cou_T)
				{
					tmp_Out[int(tmp_Skipcur)] = " " + std::to_string(tmp_Node->Charge);

					tmp_RC_Out[int(tmp_Skipcur)] = " " + std::to_string(tmp_Node->RC);

					tmp_XY_Out[int(tmp_Skipcur)] = "\n(" + std::to_string(int(tmp_Skipcur)) + ", " + std::to_string(tmp_Node->Tier) + ") " + std::to_string(tmp_Node->NID);

					tmp_Node->Index = int(tmp_Skipcur);

					tmp_Skipcur += tmp_Skipval;

					if (tmp_Skipcur >= Nodes.Fat_Tier) { (tmp_Skipcur = Nodes.Fat_Tier - 1); }

					tmp_Cur++;
				}

				tmp_Node = tmp_Node->Next;
			}

			OF << " " << cou_T << " ";
			OFRC << " " << cou_T << " ";

			for (int cou_FT = 0; cou_FT < Nodes.Fat_Tier; cou_FT++)
			{
				OF << tmp_Out[cou_FT];
				OFRC << tmp_RC_Out[cou_FT];
				OFXY << tmp_XY_Out[cou_FT];
			}
		}
		OF.close();
		OFRC.close();
		OFXY.close();
		*/
		std::cout << "Complete...";
	}


	//    ---======================================---
	//   ---========================================---
	//  ---==   Used to register new Constructs.   ==---
	//   ---========================================---
	//    ---======================================---

		//    ---==  register_Construct [Construct_TYPE] [Construct_NAME]  ==---
		//p_Type is the type of CAN to declare. 
		// "Many_To_One" - The I/O tier has every node connected to a single upper tier node.
	int register_Construct(std::string p_Type, std::string p_Construct_Name)
	{
		int tmp_Construct_ID = add_Construct(p_Construct_Name);

		if (tmp_Construct_ID == -1) { return -1; }

		bool flg_Made_It = false;

		if (p_Type == "Many_To_One")
		{
			Constructs[tmp_Construct_ID]->CAN = new c_CAN_Many_To_One;

			//Make sure we set the node network for the CAN.
			Constructs[tmp_Construct_ID]->CAN->set_NNet(&Nodes);

			Constructs[tmp_Construct_ID]->CAN->State_Nodes_Index = Nodes.register_New_Construct();

			Constructs[tmp_Construct_ID]->CAN_Type = "Many_To_One";

			flg_Made_It = true;
		}
		if (p_Type == "1D_Pyramid")
		{
			Constructs[tmp_Construct_ID]->CAN = new c_CAN_1D_Pyramid;

			//Make sure we set the node network for the CAN.
			Constructs[tmp_Construct_ID]->CAN->set_NNet(&Nodes);

			Constructs[tmp_Construct_ID]->CAN->State_Nodes_Index = Nodes.register_New_Construct();

			Constructs[tmp_Construct_ID]->CAN_Type = "1D_Pyramid";

			flg_Made_It = true;
		}
		if (p_Type == "2D_Pyramid")
		{
			Constructs[tmp_Construct_ID]->CAN = new c_CAN_2D_Pyramid;

			//Make sure we set the node network for the CAN.
			Constructs[tmp_Construct_ID]->CAN->set_NNet(&Nodes);

			Constructs[tmp_Construct_ID]->CAN->State_Nodes_Index = Nodes.register_New_Construct();

			Constructs[tmp_Construct_ID]->CAN_Type = "2D_Pyramid";

			flg_Made_It = true;
		}
		if (p_Type == "3D_Pyramid")
		{
			Constructs[tmp_Construct_ID]->CAN = new c_CAN_3D_Pyramid;

			//Make sure we set the node network for the CAN.
			Constructs[tmp_Construct_ID]->CAN->set_NNet(&Nodes);

			Constructs[tmp_Construct_ID]->CAN->State_Nodes_Index = Nodes.register_New_Construct();

			Constructs[tmp_Construct_ID]->CAN_Type = "3D_Pyramid";

			flg_Made_It = true;
		}

		if (!flg_Made_It)
		{
			std::cerr << "\n\n /(>.>)/ WARNING: " << p_Type << " type construct not recognized! Construct [" << tmp_Construct_ID << "] defaulted to Many_To_One!\n";

			Constructs[tmp_Construct_ID]->CAN = new c_CAN_Many_To_One;

			//Make sure we set the node network for the CAN.
			Constructs[tmp_Construct_ID]->CAN->set_NNet(&Nodes);

			Constructs[tmp_Construct_ID]->CAN->State_Nodes_Index = Nodes.register_New_Construct();

			Constructs[tmp_Construct_ID]->CAN_Type = "Many_To_One";
		}

		save_Config(tmp_Construct_ID);

		//output_Constructs();

		return tmp_Construct_ID;
	}




	//    ---=====================---
	//   ---=======================---
	//  ---==   Input handling.   ==---
	//   ---=======================---
	//    ---=====================---

//    ---==  load_input  ==---
	int load_Input(int p_Construct)
	{
		std::ifstream InputFile(Constructs[p_Construct]->Input_File);

		std::string tmp_Input_Full = "";
		std::string tmp_In = "";
		int tmp_Count = 0;

		if (InputFile.is_open())
		{
			while (!InputFile.eof())
			{
				tmp_In = "";
				InputFile >> tmp_In;
				if (tmp_In == "") { continue; }
				std::cout << "\n - [ " << tmp_Count << " ]: " << tmp_In;
				tmp_Count++;

				if (tmp_Input_Full != "") { tmp_Input_Full = tmp_Input_Full + " " + tmp_In; }
				if (tmp_Input_Full == "") { tmp_Input_Full = tmp_In; }

				//Neuralman.output_Input();
			}

			std::cout << "\n Input.ssv contents: " << tmp_Input_Full << "\n";

			//set_Input_1D_string(int p_Construct, std::string p_Input)

			set_Input(p_Construct, tmp_Input_Full);

			return 1;
		}
		else
		{
			std::cerr << "\n Unable to open Input.ssv for set_Input_1D_string ...\n";

			return 0;
		}

		return 1;
	}

	//    ---==  load_input  ==---
	int load_Input_uint(int p_Construct)
	{
		std::ifstream InputFile(Constructs[p_Construct]->Input_File);

		int tmp_Count = 0;
		int tmp_Current = 0;
		uint64_t* tmp_Input = NULL;

		if (InputFile.is_open())
		{
			//Get the count:
			if (!InputFile.eof())
			{
				InputFile >> tmp_Count;
			}

			std::cout << "\n Count: " << tmp_Count;

			if (tmp_Count > 0)
			{
				tmp_Input = new uint64_t[tmp_Count];

				for (int cou_Index = 0; cou_Index < tmp_Count; cou_Index++)
				{
					tmp_Input[cou_Index] = 0;
				}

				while (!InputFile.eof())
				{
					InputFile >> tmp_Input[tmp_Current];

					std::cout << "\n - [ " << tmp_Current << " ]: " << tmp_Input[tmp_Current];
					tmp_Current++;
				}
			}

			set_Input_uint(p_Construct, tmp_Count, tmp_Input);

			if (tmp_Input != NULL) { delete[] tmp_Input; tmp_Input = NULL; }

			return 1;
		}
		else
		{
			std::cerr << "\n Unable to open Input.ssv for set_Input_1D_string ...\n";

			return 0;
		}

		return 1;
	}

	void round_Up_Input(int p_Construct)
	{
		uint64_t* tmp_Input = new uint64_t[Constructs[p_Construct]->Connection_Count];

		for (int cou_C = 0; cou_C < Constructs[p_Construct]->Connection_Count; cou_C++)
		{
			tmp_Input[cou_C] = 0;
			tmp_Input[cou_C] = get_Treetop_NID(Constructs[p_Construct]->Connections[cou_C]);
		}

		set_Input_uint(p_Construct, Constructs[p_Construct]->Connection_Count, tmp_Input);

		if (tmp_Input != NULL) { delete[] tmp_Input; }
	}

	void round_Up_Given_Input(int p_Construct, int p_Input)
	{
		uint64_t tmp_Input = get_Treetop_NID(Constructs[p_Construct]->Connections[p_Input]);
		set_Input_uint(p_Construct, 1, &tmp_Input);
	}

	int get_Output_Depth(int p_Construct)
	{
		return int(Constructs[p_Construct]->CAN->Output.size());
	}

	std::string get_Output_Pattern(int p_Construct, int p_Index)
	{
		return (Constructs[p_Construct]->CAN->get_Output(p_Index))->get_Pattern();
	}

	std::vector<uint64_t> get_Output_Pattern_uint(int p_Construct, int p_Index)
	{
		return (Constructs[p_Construct]->CAN->get_Output(p_Index))->get_Pattern_uint();
	}

	uint64_t get_Output_Primitive_uint(int p_Construct, int p_Index, int p_Primitive)
	{
		return (Constructs[p_Construct]->CAN->get_Output(p_Index))->get_Primitive_uint(p_Primitive);
	}

	int get_Output_Pattern_Size(int p_Construct, int p_Index)
	{
		return (Constructs[p_Construct]->CAN->get_Output(p_Index))->get_Output_Pattern_Size();
	}

	float get_Output_Charge(int p_Construct, int p_Index)
	{
		return (Constructs[p_Construct]->CAN->get_Output(p_Index))->get_Charge();
	}

	uint64_t get_Output_Treetop_NID(int p_Construct, int p_Index)
	{
		return (Constructs[p_Construct]->CAN->get_Output(p_Index))->get_Treetop_NID();
	}

	float get_Output_RC(int p_Construct, int p_Index)
	{
		return (Constructs[p_Construct]->CAN->get_Output(p_Index))->get_RC();
	}

	int get_Construct_Count()
	{
		return Construct_Count;
	}

	//Used for eval, pulls the output from lower to upper.
	void pull_From_Lower_Connections(int p_Construct)
	{
		uint64_t* tmp_Final_Input = NULL;
		std::vector<float> tmp_Charging_Mask;
		int tmp_Dimension = 0;
		int tmp_Input_Depth_Total = 0;
		int tmp_Tick = 0;
		int tmp_Con = 0;

		for (int cou_C = 0; cou_C < Constructs[p_Construct]->Connection_Count; cou_C++)
		{
			tmp_Con = Constructs[p_Construct]->Connections[cou_C];
			//---std::cout << "\n Construct[" << p_Construct << "] Connections[" << cou_C << "]: " << tmp_Con;
			//---std::cout << "\n Construct[" << tmp_Con << "] Output_Depth: " << Constructs[tmp_Con]->CAN->Output_Depth;
			//---std::cout << "\n Construct[" << tmp_Con << "] Output_Depth_2D: " << Constructs[tmp_Con]->CAN->Output_Depth_2D;
			//---std::cout << "\n Construct[" << tmp_Con << "] Output_Depth_3D: " << Constructs[tmp_Con]->CAN->Output_Depth_3D;
			tmp_Input_Depth_Total += Constructs[tmp_Con]->CAN->get_Output_Depth();
		}

		//---std::cout << "\n Input_Depth_Total: " << tmp_Input_Depth_Total;

		tmp_Final_Input = new uint64_t[tmp_Input_Depth_Total];
		tmp_Charging_Mask.resize(tmp_Input_Depth_Total);

		for (int cou_C = 0; cou_C < Constructs[p_Construct]->Connection_Count; cou_C++)
		{
			tmp_Con = Constructs[p_Construct]->Connections[cou_C];

			tmp_Dimension = Constructs[tmp_Con]->CAN->get_Dimension();

			//---std::cout << "\n Construct[" << tmp_Con << "] Dimension: " << tmp_Dimension;
			for (int cou_Index = 0; cou_Index < Constructs[tmp_Con]->CAN->get_Output_Depth(); cou_Index++)
			{
				if (tmp_Dimension == 1) { tmp_Final_Input[tmp_Tick] = Constructs[tmp_Con]->CAN->Output[cou_Index].Treetop->NID; tmp_Charging_Mask[tmp_Tick] = Constructs[tmp_Con]->CAN->Output[cou_Index].Charge; }
				if (tmp_Dimension == 2) { tmp_Final_Input[tmp_Tick] = Constructs[tmp_Con]->CAN->Output_2D[cou_Index].Treetop->NID; tmp_Charging_Mask[tmp_Tick] = Constructs[tmp_Con]->CAN->Output_2D[cou_Index].Charge; }
				if (tmp_Dimension == 3) { tmp_Final_Input[tmp_Tick] = Constructs[tmp_Con]->CAN->Output_3D[cou_Index].Treetop->NID; tmp_Charging_Mask[tmp_Tick] = Constructs[tmp_Con]->CAN->Output_3D[cou_Index].Charge; }

				tmp_Tick++;
			}
		}

		set_Input_uint(p_Construct, tmp_Input_Depth_Total, tmp_Final_Input);
		set_Input_Charging_Mask(p_Construct, tmp_Charging_Mask);

		delete[] tmp_Final_Input;
		tmp_Final_Input = NULL;
	}

	void pull_Chrono_From_Lower_Connection(const int p_Construct)
	{
		int tmp_Con = Constructs[p_Construct]->Connections[0]; //Get the construct we are pulling from.
		//---std::cout << "\n Pulling from: " << Constructs[Constructs[p_Construct]->Connections[0]]->Name;
		add_Chrono(p_Construct, get_Treetop_NID(tmp_Con));
	}

	//Note, only use this on 1D constructs.
	void pull_From_Lower_Connection(const int p_Construct, const int p_Lower_Connection)
	{
		uint64_t* tmp_Final_Input = NULL;
		int tmp_Dimension = 0;
		int tmp_Con = Constructs[p_Construct]->Connections[p_Lower_Connection]; //Get the construct we are pulling from.
		int tmp_Input_Depth_Total = Constructs[tmp_Con]->CAN->get_Output_Depth(); //Get the depth of the output of the construct to pull from.
		int tmp_Tick = 0;
		
		//---std::cout << "\n Input_Depth_Total: " << tmp_Input_Depth_Total;

		tmp_Final_Input = new uint64_t[tmp_Input_Depth_Total];

		tmp_Dimension = Constructs[tmp_Con]->CAN->get_Dimension();

		//---std::cout << "\n Construct[" << tmp_Con << "] Dimension: " << tmp_Dimension;
		for (int cou_Index = 0; cou_Index < tmp_Input_Depth_Total; cou_Index++)
		{
			if (tmp_Dimension == 1) { tmp_Final_Input[tmp_Tick] = Constructs[tmp_Con]->CAN->Output[cou_Index].Treetop->NID; }
			if (tmp_Dimension == 2) { tmp_Final_Input[tmp_Tick] = Constructs[tmp_Con]->CAN->Output_2D[cou_Index].Treetop->NID; }
			if (tmp_Dimension == 3) { tmp_Final_Input[tmp_Tick] = Constructs[tmp_Con]->CAN->Output_3D[cou_Index].Treetop->NID; }

			tmp_Tick++;
		}

		set_Input_uint(p_Construct, tmp_Input_Depth_Total, tmp_Final_Input);

		delete[] tmp_Final_Input;
		tmp_Final_Input = NULL;
	}

	c_Trace* get_Output_Trace(int p_Construct, int p_Index)
	{
		return Constructs[p_Construct]->CAN->get_Output(p_Index);
	}

	bool check_Output_Bounds(int p_Construct, int p_Output_Index)
	{
		if (!(Constructs[p_Construct]->CAN->get_Output_Depth() <= p_Output_Index)) 
		{
			std::cerr << "\n   --(O.o)~~   ERROR: check_Output_Bounds(p_Construct = " << Constructs[p_Construct]->Name << ", p_Output_Index = " << p_Output_Index << ")";

			return 0; 
		}
		return 1;
	}

	//Iterates through every output trace in the given index of the given upper tier construct.
	void pull_From_Upper_Index(int p_Construct_To, int p_Construct_From, int p_Index)
	{
		std::ofstream tmp_Output_File;
		
		c_Trace * tmp_Trace = NULL;

		c_Linked_List_Handler tmp_Pattern;

		c_Linked_List* tmp_LL_Pat = NULL;

		int tmp_Output_Depth = Constructs[p_Construct_From]->CAN->get_Output_Depth();
		int tmp_Dimension = Constructs[p_Construct_To]->CAN->get_Dimension();

		//std::cout << "\n Depth: " << tmp_Output_Depth;

		//Setup the output to hold the traces
		Constructs[p_Construct_To]->CAN->allocate_Output(tmp_Output_Depth, tmp_Dimension);

		//std::cout << "\n Dimension: " << tmp_Dimension;

		//---Constructs[p_Construct_To]->CAN->output_Output();

		for (int cou_Trace = 0; cou_Trace < tmp_Output_Depth; cou_Trace++)
		{
			tmp_Pattern.reset();

			tmp_Trace = get_Output_Trace(p_Construct_From, cou_Trace);

			//std::cout << "\n [" << cou_Trace << "] ";

			//std::cout << " { " << tmp_Trace->get_Pattern_Index(p_Index) << " }";

			//Constructs[p_Construct_To]->CAN->Output[cou_Trace].set_Depth(tmp_Pattern.Depth);

			Constructs[p_Construct_To]->CAN->backpropagate_NID_Into_Given_Index(tmp_Trace->get_Pattern_Index(p_Index), cou_Trace, tmp_Trace->Charge);
		}
		//---output_Output(p_Construct_To);

	}

	//This function moves a uint from a given construct input index to the output of a given construct by appending it. This allows you to take the backpropagated MSC, Chrono, etc pattern of treetops and append each treetop to the output file of the given construct. So you can then run 
	//Comment left here in case I come back to it. Delete if something has superceded it and this comment will not be potentially needed.

	//    ---==  set_input [Construct_ID] [INPUT_STRING]  ==---
		//Set the value to the passed 1D string of uint64_t
	void set_Input(int p_Construct, std::string p_Input)
	{
		Constructs[p_Construct]->CAN->set_Input_String(p_Input);
	}

	//    ---==  set_input_uint [Construct_ID] [ARRAY_DEPTH] [UINT_ARRAY]  ==---
		//Set the value to the passed 1D string of uint64_t
	void set_Input_uint(int p_Construct, int p_Depth, uint64_t* p_Input)
	{
		if (p_Construct == -1) { return; }
		Constructs[p_Construct]->CAN->set_Input(p_Input, p_Depth);
	}



	//    ---==========================================================================---
	//   ---============================================================================---
	//  ---==   Different ways of gathering nodes, individually, and the entire set.   ==---
	//   ---============================================================================---
	//    ---==========================================================================---

	//    ---==  gather_given_node [Construct_ID] [NID]  ==---
	//		Writes the given node's data down in the Constructs[p_Construct]->Output_File file.
	void gather_Given_Node(int p_Construct, uint64_t p_NID)
	{
		std::ofstream tmp_Output_File;
		c_Node* tmp_Node = NULL;

		tmp_Node = Nodes.get_Node_Ref_By_NID(p_NID);

		tmp_Output_File.open(Constructs[p_Construct]->Output_File, std::ios::app);

		write_Node_To_File(p_Construct, &tmp_Output_File, tmp_Node);

		tmp_Output_File.close();
	}

	//		Writes the given node's data down in the Constructs[p_Construct]->Output_File file.
	void gather_Given_Node_uint(int p_Construct, uint64_t p_NID)
	{
		std::ofstream tmp_Output_File;
		c_Node* tmp_Node = NULL;

		tmp_Node = Nodes.get_Node_Ref_By_NID(p_NID);

		tmp_Output_File.open(Constructs[p_Construct]->Output_File, std::ios::app);

		write_Node_To_File(p_Construct, &tmp_Output_File, tmp_Node, 1);

		tmp_Output_File.close();
	}

	//    ---==  gather_all_nodes [Construct_ID]  ==---
	//		This writes the entire network to the Constructs[p_Construct]->Output_File file. Note, the output patterns are treated as character.
		//It uses the passed Construct to output the nodes by putting it into the output of that Construct, then into the file.
	void gather_All_Nodes(int p_Construct)
	{
		std::ofstream tmp_Output_File;

		c_Node* tmp_Node;
		tmp_Node = Nodes.Root;

		tmp_Output_File.open(Constructs[p_Construct]->Output_File, std::ios::app);

		while (tmp_Node != NULL)
		{
			tmp_Output_File << "\n";

			write_Node_To_File(p_Construct, &tmp_Output_File, tmp_Node);

			tmp_Node = tmp_Node->Next;
		}

		tmp_Output_File.close();
	}

	//    ---==  gather_all_nodes_uint [Construct_ID]  ==---
	//		This writes the entire network to the Constructs[p_Construct]->Output_File file. Note, the output patterns are treated as uint.
	void gather_All_Nodes_uint(int p_Construct)
	{
		std::ofstream tmp_Output_File;

		c_Node* tmp_Node;
		tmp_Node = Nodes.Root;

		tmp_Output_File.open(Constructs[p_Construct]->Output_File, std::ios::app);

		while (tmp_Node != NULL)
		{
			tmp_Output_File << "\n";

			write_Node_To_File(p_Construct, &tmp_Output_File, tmp_Node, 1);

			tmp_Node = tmp_Node->Next;
		}

		tmp_Output_File.close();
	}

	void gather_Treetops(int p_Construct)
	{
		Constructs[p_Construct]->CAN->gather_Treetops();
	}

	//    ---==================================================================---
	//   ---====================================================================---
	//  ---==   The output of a given Construct is read into the output file.   ==---
	//   ---====================================================================---
	//    ---==================================================================---

		//==--- DIRECT_HOOK ---==//
	void output_Trace_To_File(std::ofstream* p_SF, c_Trace* p_Trace, int p_Output_Type)
	{
		std::cout << " NID: " << p_Trace->Treetop->NID;
		std::cout << " Charge: " << p_Trace->Charge;
		std::cout << " RC: " << p_Trace->RC;
		std::cout << " Depth: " << p_Trace->get_Output_Pattern_Size();

		*p_SF << "\n";

		*p_SF << p_Trace->Treetop->NID;
		*p_SF << " " << p_Trace->Charge;
		*p_SF << " " << p_Trace->RC;
		*p_SF << " " << p_Trace->get_Output_Pattern_Size();

		*p_SF << " ";
		std::string tmp_In = "";

		if (p_Trace->get_Output_Pattern_Size() > 0)
		{
			if (p_Output_Type == 0)
			{
				*p_SF << char(p_Trace->Pattern[0]);
				std::cout << "  " << char(p_Trace->Pattern[0]);
			}
			if (p_Output_Type == 1)
			{
				*p_SF << p_Trace->Pattern[0];
				std::cout << "  " << p_Trace->Pattern[0];
			}
		}

		for (int cou_Index = 1; cou_Index < p_Trace->get_Output_Pattern_Size(); cou_Index++)
		{
			if (p_Output_Type == 0)
			{
				*p_SF << char(p_Trace->Pattern[cou_Index]);
				std::cout << " " << char(p_Trace->Pattern[cou_Index]);
			}
			if (p_Output_Type == 1)
			{
				*p_SF << " " << p_Trace->Pattern[cou_Index];
				std::cout << " " << p_Trace->Pattern[cou_Index];
			}

		}
	}

		//==--- DIRECT_HOOK ---==//
	void output_3D_Trace_To_File(std::ofstream* p_SF, c_3D_Trace* p_Trace, int p_Output_Type)
	{
		std::cout << " NID: " << p_Trace->Treetop->NID;
		std::cout << " Charge: " << p_Trace->Charge;
		std::cout << " RC: " << p_Trace->RC;
		std::cout << " Depth_X: " << p_Trace->Depth_X;
		std::cout << " Depth_Y: " << p_Trace->Depth_Y;
		std::cout << " Depth_Z: " << p_Trace->Depth_Z;

		*p_SF << "\nNID ";

		*p_SF << p_Trace->Treetop->NID;
		*p_SF << " Charge " << p_Trace->Charge;
		*p_SF << " RC " << p_Trace->RC;
		*p_SF << " Depth_X " << p_Trace->Depth_X;
		*p_SF << " Depth_Y " << p_Trace->Depth_Y;
		*p_SF << " Depth_Z " << p_Trace->Depth_Z;

		*p_SF << " Pat ";
		std::string tmp_In = "";
		/*
		if (p_Trace->Depth > 0)
		{
			if (p_Output_Type == 0)
			{
				*p_SF << char(p_Trace->Pattern[0][0]);
				std::cout << "  " << char(p_Trace->Pattern[0][0]);
			}
			if (p_Output_Type == 1)
			{
				*p_SF << p_Trace->Pattern[0][0];
				std::cout << "  " << p_Trace->Pattern[0][0];
			}
		}
		*/
		*p_SF << "\n";
		std::cout << "\n";
		for (int cou_X = 0; cou_X < p_Trace->Depth_X; cou_X++)
		{
			for (int cou_Y = 0; cou_Y < p_Trace->Depth_Y; cou_Y++)
			{
				for (int cou_Z = 0; cou_Z < p_Trace->Depth_Z; cou_Z++)
				{
					if (p_Output_Type == 0)
					{
						*p_SF << char(p_Trace->Pattern[cou_X][cou_Y][cou_Z]);
						std::cout << char(p_Trace->Pattern[cou_X][cou_Y][cou_Z]) << " ";
					}
					if (p_Output_Type == 1)
					{
						*p_SF << " " << p_Trace->Pattern[cou_X][cou_Y][cou_Z];
						std::cout << " " << p_Trace->Pattern[cou_X][cou_Y][cou_Z];
					}
				}
				*p_SF << "\n";
				std::cout << "\n";
			}
			*p_SF << "\n";
			std::cout << "\n";
		}


	}

		//==--- DIRECT_HOOK ---==//
	void output_2D_Trace_To_File(std::ofstream* p_SF, c_2D_Trace* p_Trace, int p_Output_Type)
	{
		std::cout << " NID: " << p_Trace->Treetop->NID;
		std::cout << " Charge: " << p_Trace->Charge;
		std::cout << " RC: " << p_Trace->RC;
		std::cout << " Depth_X: " << p_Trace->Depth_X;
		std::cout << " Depth_Y: " << p_Trace->Depth_Y;

		*p_SF << "\nNID ";

		*p_SF << p_Trace->Treetop->NID;
		*p_SF << " Charge " << p_Trace->Charge;
		*p_SF << " RC " << p_Trace->RC;
		*p_SF << " Depth_X " << p_Trace->Depth_X;
		*p_SF << " Depth_Y " << p_Trace->Depth_Y;

		*p_SF << " Pat ";
		std::string tmp_In = "";
		/*
		if (p_Trace->Depth > 0)
		{
			if (p_Output_Type == 0)
			{
				*p_SF << char(p_Trace->Pattern[0][0]);
				std::cout << "  " << char(p_Trace->Pattern[0][0]);
			}
			if (p_Output_Type == 1)
			{
				*p_SF << p_Trace->Pattern[0][0];
				std::cout << "  " << p_Trace->Pattern[0][0];
			}
		}
		*/
		*p_SF << "\n";
		std::cout << "\n";
		for (int cou_X = 0; cou_X < p_Trace->Depth_X; cou_X++)
		{
			for (int cou_Y = 0; cou_Y < p_Trace->Depth_Y; cou_Y++)
			{
				if (p_Output_Type == 0)
				{
					*p_SF << char(p_Trace->Pattern[cou_X][cou_Y]);
					std::cout << char(p_Trace->Pattern[cou_X][cou_Y]) << " ";
				}
				if (p_Output_Type == 1)
				{
					*p_SF << " " << p_Trace->Pattern[cou_X][cou_Y];
					std::cout << " " << p_Trace->Pattern[cou_X][cou_Y];
				}
			}
			*p_SF << "\n";
			std::cout << "\n";
		}
	}
	

	//==--- DIRECT_HOOK ---==//
	//Character output for this one, the default, always string.
	//p_Output_Type: 0 = string, 1 = uint64_t
	void output_Output_To_File(int p_Construct, int p_Output_Type = 0)
	{
		std::ofstream tmp_Output_File;

		tmp_Output_File.open(Constructs[p_Construct]->Output_File, std::ios::app);

		// Check if the flag file exists and can be opened
		if (tmp_Output_File.is_open())
		{
			//tmp_Output_File << Constructs[p_Construct]->CAN->Output_Depth;

			//---std::cout << "\n Output_Depth: " << Constructs[p_Construct]->CAN->Output_Depth;
			//---std::cout << "\n Output_Depth_2D: " << Constructs[p_Construct]->CAN->Output_Depth_2D;
			//---std::cout << "\n Output_Depth_3D: " << Constructs[p_Construct]->CAN->Output_Depth_3D;

			//For every trace write the info to the file
			for (int cou_Trace = 0; cou_Trace < Constructs[p_Construct]->CAN->Output.size(); cou_Trace++)
			{
				//---std::cout << "\n Trace [" << cou_Trace << "]";

				output_Trace_To_File(&tmp_Output_File, &(Constructs[p_Construct]->CAN->Output[cou_Trace]), p_Output_Type);
			}
			for (int cou_Trace = 0; cou_Trace < Constructs[p_Construct]->CAN->Output_Depth_2D; cou_Trace++)
			{
				//---std::cout << "\n 2D_Trace [" << cou_Trace << "]";

				output_2D_Trace_To_File(&tmp_Output_File, &(Constructs[p_Construct]->CAN->Output_2D[cou_Trace]), p_Output_Type);
			}
			for (int cou_Trace = 0; cou_Trace < Constructs[p_Construct]->CAN->Output_Depth_3D; cou_Trace++)
			{
				//---std::cerr << "\n 3D_Trace [" << cou_Trace << "]";

				output_3D_Trace_To_File(&tmp_Output_File, &(Constructs[p_Construct]->CAN->Output_3D[cou_Trace]), p_Output_Type);
			}
		}
		tmp_Output_File.close();
	}

	//    ---==  gather_output [Construct_ID]  ==---
	//		Takes every trace in the given Constructs output trace array and writes them to the Constructs[p_Construct]->Output_File file, note the output state patterns are treated as char.
	void gather_Output(int p_Construct)
	{
		output_Output_To_File(p_Construct);
	}

	//    ---==  gather_output_uint [Construct_ID]  ==---
	//		Takes every trace in the given Constructs output trace array and writes them to the Constructs[p_Construct]->Output_File file, note the output state patterns are treated as uint.
	void gather_Output_uint(int p_Construct)
	{
		output_Output_To_File(p_Construct, 1);
	}


	//    ---=============================---
	//   ---===============================---
	//  ---==   Treetop node gathering.   ==---
	//   ---===============================---
	//    ---=============================---


		//==--- DIRECT_HOOK ---==//
	void write_Node_To_File(int p_Construct, std::ofstream* p_SF, c_Node* p_Node, int p_Output_Type = 0)
	{
		if ((p_SF == NULL) || (p_Node == NULL)) { return; }

		// Check if the flag file exists and can be opened
		if (p_SF->is_open())
		{
			*p_SF << p_Node->NID;
			*p_SF << " RC ";
			*p_SF << p_Node->RC;
			*p_SF << " #Denrites ";
			*p_SF << p_Node->Dendrite_Count;
			*p_SF << " Dendrites[] ";
			for (int cou_D = 0; cou_D < p_Node->Dendrite_Count; cou_D++)
			{
				*p_SF << "[" << cou_D << "] ";
				*p_SF << p_Node->Dendrites[cou_D]->NID;
				*p_SF << " Weight ";
				*p_SF << p_Node->Dendrite_Weights[cou_D] << " ";;
			}
			*p_SF << " #Axon_Hillocks ";
			*p_SF << p_Node->Axon_Hillock_Count;
			*p_SF << " ";
			for (int cou_H = 0; cou_H < p_Node->Axon_Hillock_Count; cou_H++)
			{
				*p_SF << " Hill " << cou_H << " ";
				*p_SF << " #Axons ";
				*p_SF << p_Node->Axon_Count[cou_H];
				*p_SF << " Axons[] ";
				for (int cou_A = 0; cou_A < p_Node->Axon_Count[cou_H]; cou_A++)
				{
					*p_SF << "[" << cou_A << "] ";
					*p_SF << p_Node->Axons[cou_H][cou_A]->NID;
				}
			}

			Constructs[p_Construct]->CAN->gather_Given_Trace(p_Node->NID);

			if (Constructs[p_Construct]->CAN->Output.size() > 0)
			{
				//The single node should only generate one trace which will be stored in the [0] index.
				*p_SF << " Symbol_Depth ";
				*p_SF << Constructs[p_Construct]->CAN->Output[0].get_Output_Pattern_Size();
				*p_SF << " Symbol ";
				for (int cou_Index = 0; cou_Index < Constructs[p_Construct]->CAN->Output[0].get_Output_Pattern_Size(); cou_Index++)
				{
					if (p_Output_Type == 0)
					{
						*p_SF << char(Constructs[p_Construct]->CAN->Output[0].get_Pattern_Index(cou_Index));
					}
					if (p_Output_Type == 1)
					{
						*p_SF << Constructs[p_Construct]->CAN->Output[0].get_Pattern_Index(cou_Index) << " ";
					}
				}
			}
		}
	}
	
		//==--- DIRECT_HOOK ---==//
	void write_Node_To_File_2D(int p_Construct, std::ofstream* p_SF, c_Node* p_Node, int p_Output_Type = 0)
	{
		if ((p_SF == NULL) || (p_Node == NULL)) { return; }

		// Check if the flag file exists and can be opened
		if (p_SF->is_open())
		{
			*p_SF << p_Node->NID;
			*p_SF << " RC ";
			*p_SF << p_Node->RC;
			*p_SF << " #Denrites ";
			*p_SF << p_Node->Dendrite_Count;
			*p_SF << " Dendrites[] ";
			for (int cou_D = 0; cou_D < p_Node->Dendrite_Count; cou_D++)
			{
				*p_SF << "[" << cou_D << "] ";
				*p_SF << p_Node->Dendrites[cou_D]->NID;
			}
			*p_SF << " #Axon_Hillocks ";
			*p_SF << p_Node->Axon_Hillock_Count;
			*p_SF << " ";
			for (int cou_H = 0; cou_H < p_Node->Axon_Hillock_Count; cou_H++)
			{
				*p_SF << " Hill " << cou_H << " ";
				*p_SF << " #Axons ";
				*p_SF << p_Node->Axon_Count[cou_H];
				*p_SF << " Axons[] ";
				for (int cou_A = 0; cou_A < p_Node->Axon_Count[cou_H]; cou_A++)
				{
					*p_SF << "[" << cou_A << "] ";
					*p_SF << p_Node->Axons[cou_H][cou_A]->NID;
				}
			}

			Constructs[p_Construct]->CAN->gather_Given_Trace(p_Node->NID);

			if (Constructs[p_Construct]->CAN->Output.size() > 0)
			{
				//The single node should only generate one trace which will be stored in the [0] index.
				*p_SF << " Symbol_Depth ";
				*p_SF << Constructs[p_Construct]->CAN->Output[0].get_Output_Pattern_Size();
				*p_SF << " Symbol ";
				for (int cou_Index = 0; cou_Index < Constructs[p_Construct]->CAN->Output[0].get_Output_Pattern_Size(); cou_Index++)
				{
					if (p_Output_Type == 0)
					{
						*p_SF << char(Constructs[p_Construct]->CAN->Output[0].get_Pattern_Index(cou_Index));
					}
					if (p_Output_Type == 1)
					{
						*p_SF << Constructs[p_Construct]->CAN->Output[0].get_Pattern_Index(cou_Index) << " ";
					}
				}
			}
		}
	}

	void save_Node_To_File(std::ofstream* p_SF, c_Node* p_Node, int p_Output_Type = 0)
	{
		if ((p_SF == NULL) || (p_Node == NULL)) { return; }

		// Check if the flag file exists and can be opened
		if (p_SF->is_open())
		{
			*p_SF << p_Node->NID;
			*p_SF << " ";
			*p_SF << p_Node->RC;
			*p_SF << " ";
			*p_SF << p_Node->Type;
			*p_SF << " ";
			*p_SF << p_Node->State;
			*p_SF << " ";
			*p_SF << p_Node->Dendrite_Count;
			*p_SF << " ";
			for (int cou_D = 0; cou_D < p_Node->Dendrite_Count; cou_D++)
			{
				*p_SF << p_Node->Dendrites[cou_D]->NID;
				*p_SF << " ";
			}
		}
	}

	void save_Constructs(std::ofstream* p_SF)
	{
		*p_SF << Construct_Count;

		for (int cou_Con=0;cou_Con<Construct_Count;cou_Con++)
		{
			*p_SF << "\n";
			*p_SF << Constructs[cou_Con]->Name << " ";
			*p_SF << Constructs[cou_Con]->CAN_Type << " ";
			*p_SF << Constructs[cou_Con]->CAN->State_Nodes_Index << " ";

			*p_SF << get_Base_Charge(cou_Con) << " ";
			*p_SF << get_Modifier_Charge(cou_Con) << " ";
			*p_SF << get_Action_Potential_Threshold(cou_Con) << " ";
			*p_SF << get_Charging_Tier(cou_Con) << " ";
		}
	}

	//Save the node network one node at a time.
	void save_Node_Network(std::ofstream* p_SF)
	{
		*p_SF << "\n";
		*p_SF << Nodes.Node_Count;

		c_Node* tmp_Node;
		tmp_Node = Nodes.Root;

		int tmp_Loading_Bar = int(float(Nodes.Node_Count) / 100.0);
		int tmp_NID = 0;
		std::cout << "\n Saving: " << Nodes.Node_Count << " nodes.";
		std::cout << "\n";
		for (int cou_Index = 0; cou_Index <= 100; cou_Index++)
		{
			std::cout << "_";
		}
		std::cout << "\n";
		while (tmp_Node != NULL)
		{
			if (!(tmp_NID % tmp_Loading_Bar)) { std::cout << "."; }
			tmp_NID++;

			*p_SF << "\n";

			save_Node_To_File(p_SF, tmp_Node);

			tmp_Node = tmp_Node->Next;
		}
	}

	void save_State_Trees(std::ofstream* p_SF)
	{
		*p_SF << "\n" << Nodes.State_Node_Tree_Count;

		for (int cou_State = 0; cou_State < Nodes.State_Node_Tree_Count; cou_State++)
		{
			Nodes.State_Nodes[cou_State]->save_Tree(p_SF);
		}
	}

	void save(std::string p_FName)
	{
		std::ofstream tmp_Output_File;

		tmp_Output_File.open(p_FName, std::ios::ate);

		if (tmp_Output_File.is_open())
		{
			save_Constructs(&tmp_Output_File);
			save_Node_Network(&tmp_Output_File);
			save_State_Trees(&tmp_Output_File);
		}

		tmp_Output_File.close();
	}

	void load_Constructs(std::ifstream* p_SF)
	{
		int tmp_Construct_Count;
		*p_SF >> tmp_Construct_Count;

		std::string tmp_Name = "";
		std::string tmp_Type = "";
		int tmp_State_Index = 0;

		float tmp_Base_Charge = 0.0;
		float tmp_Modifier_Charge = 0.0;
		float tmp_Action_Potential_Threshold = 0.0;
		int tmp_Charging_Tier = 0;

		for (int cou_Con = 0; cou_Con < tmp_Construct_Count; cou_Con++)
		{
			*p_SF >> tmp_Name;
			*p_SF >> tmp_Type;
			*p_SF >> tmp_State_Index;

			register_Construct(tmp_Type, tmp_Name);
			set_State_Nodes_Index(cou_Con, tmp_State_Index);

			*p_SF >> tmp_Base_Charge;
			*p_SF >> tmp_Modifier_Charge;
			*p_SF >> tmp_Action_Potential_Threshold;
			*p_SF >> tmp_Charging_Tier;

			set_Base_Charge(cou_Con, tmp_Base_Charge);
			set_Modifier_Charge(cou_Con, tmp_Modifier_Charge);
			set_Action_Potential_Threshold(cou_Con, tmp_Action_Potential_Threshold);
			set_Charging_Tier(cou_Con, tmp_Charging_Tier);
		}
	}

	void load_Node_Network(std::ifstream* p_SF)
	{
		uint64_t tmp_NID = 0;
		float tmp_RC = 0.0;
		int tmp_Type = 0;
		uint64_t tmp_State = 0;
		int tmp_Dendrite_Count = 0;
		int * tmp_Dendrite_NID = NULL;

		c_Node** tmp_Dendrites = NULL;
		c_Node* tmp_Node = NULL;

		uint64_t tmp_Node_Count = 0;
		
		*p_SF >> tmp_Node_Count;

		std::cout << "\n Found " << tmp_Node_Count << " nodes.";

		int tmp_Loading_Bar = int(float(tmp_Node_Count) / 100.0);
		std::cout << "\n";
		for (int cou_Index = 0; cou_Index < 100; cou_Index++)
		{
			std::cout << "_";
		}
		std::cout << "\n";
		for (int cou_Node = 0; cou_Node < tmp_Node_Count; cou_Node++)
		{
			if (!(cou_Node % tmp_Loading_Bar)) { std::cout << "."; }

			//---std::cout << "\n";
			*p_SF >> tmp_NID;
			//---std::cout << tmp_NID << " ";

			*p_SF >> tmp_RC;
			//---std::cout << tmp_RC << " ";
			*p_SF >> tmp_Type;
			//---std::cout << tmp_Type << " ";
			*p_SF >> tmp_State;
			//---std::cout << tmp_State << " ";

			//This is because node 0 is already made
			if (tmp_NID != 0)
			{
				tmp_Node = new_Node();
			}


			if (tmp_Node != NULL)
			{
				tmp_Node->set_Type(tmp_Type);
				tmp_Node->RC = tmp_RC;
			}

			*p_SF >> tmp_Dendrite_Count;
			//---std::cout << tmp_Dendrite_Count << " ";

			tmp_Dendrite_NID = new int[tmp_Dendrite_Count];
			tmp_Dendrites = new c_Node*[tmp_Dendrite_Count];

			for (int cou_D = 0; cou_D < tmp_Dendrite_Count; cou_D++)
			{
				*p_SF >> tmp_Dendrite_NID[cou_D];
				//---std::cout << tmp_Dendrite_NID[cou_D] << " ";

				tmp_Dendrites[cou_D] = Nodes.get_Node_Ref_By_NID(tmp_Dendrite_NID[cou_D]);
			}

			if (tmp_Dendrite_Count > 0) { create_Connections(tmp_Node, tmp_Dendrite_Count, tmp_Dendrites); }
		}

		if (tmp_Dendrite_NID != NULL) { delete[] tmp_Dendrite_NID; tmp_Dendrite_NID = NULL; }
		if (tmp_Dendrites != NULL) { delete[] tmp_Dendrites; tmp_Dendrites = NULL; }

		//Now gather state nodes.


	}

	void load_State_Trees(std::ifstream* p_SF)
	{
		//This number should exist already in this system from registering the constructs, but we gather it here today to say our...
		int tmp_State_Tree_Count = 0;

		*p_SF >> tmp_State_Tree_Count;
		
		std::cout << "\n Loading [ " << tmp_State_Tree_Count << " ] State Trees...";

		int tmp_State_Node_Count = 0;

		uint64_t tmp_NID = 0;
		uint64_t tmp_State = 0;

		for (int cou_ST = 0; cou_ST < tmp_State_Tree_Count; cou_ST++)
		{
			*p_SF >> tmp_State_Node_Count;

			std::cout << "\n Found [ " << tmp_State_Node_Count << " ] State Bindings...";

			for (int cou_SN = 0; cou_SN < tmp_State_Node_Count; cou_SN++)
			{
				*p_SF >> tmp_NID;
				*p_SF >> tmp_State;

				//---std::cout << "\n NID " << tmp_NID << " State " << tmp_State;
				
				Nodes.assign_State_Node(cou_ST, Nodes.get_Node_Ref_By_NID(tmp_NID), tmp_State);
			}
		}
	}

	void load(std::string p_FName)
	{
		std::ifstream tmp_Load_File;

		tmp_Load_File.open(p_FName);

		if (tmp_Load_File.is_open())
		{
			load_Constructs(&tmp_Load_File);
			load_Node_Network(&tmp_Load_File);
			load_State_Trees(&tmp_Load_File);
		}

		tmp_Load_File.close();
	}

	//    ---==  gather_treetop_node [Construct_ID]  ==---
	//		This writes the current treetop node of the given Construct to the Constructs[p_Construct]->Output_File file. This does not erase the file.
	void gather_Treetop_Node(int p_Construct)
	{
		std::ofstream tmp_Output_File;
		c_Node* tmp_Treetop = NULL;

		tmp_Treetop = get_Treetop(p_Construct);

		tmp_Output_File.open(Constructs[p_Construct]->Output_File, std::ios::app);

		write_Node_To_File(p_Construct, &tmp_Output_File, tmp_Treetop);

		tmp_Output_File.close();
	}

	//    ---==  gather_treetop_node_uint [Construct_ID]  ==---
	//		This writes the current treetop node of the given Construct to the Constructs[p_Construct]->Output_File file. This does not erase the file.
	void gather_Treetop_Node_uint(int p_Construct)
	{
		std::ofstream tmp_Output_File;
		c_Node* tmp_Treetop = NULL;

		tmp_Treetop = get_Treetop(p_Construct);

		tmp_Output_File.open(Constructs[p_Construct]->Output_File, std::ios::app);

		write_Node_To_File(p_Construct, &tmp_Output_File, tmp_Treetop, 1);

		tmp_Output_File.close();
	}

	//    ---==  gather_treetop_NID [Construct_ID]  ==---
	//		This writes only the NID of the current treetop to the file. Does not erase the file.
	void gather_Treetop_NID(int p_Construct)
	{
		std::ofstream tmp_Output_File;
		c_Node* tmp_Treetop = NULL;

		tmp_Treetop = get_Treetop(p_Construct);

		tmp_Output_File.open(Constructs[p_Construct]->Output_File, std::ios::app);

		if (tmp_Treetop != NULL)
		{
			tmp_Output_File << tmp_Treetop->NID;
		}
		else
		{
			tmp_Output_File << "NULL";
		}
		tmp_Output_File.close();
	}

	void write_Treetop_NID_To_Other_Input(int p_Construct_From, int p_Construct_To)
	{
		std::ofstream tmp_Output_File;
		c_Node* tmp_Treetop = NULL;

		tmp_Treetop = get_Treetop(p_Construct_From);

		tmp_Output_File.open(Constructs[p_Construct_To]->Input_File, std::ios::app);

		if (tmp_Treetop != NULL)
		{
			tmp_Output_File << tmp_Treetop->NID << " ";
		}
		else
		{
			tmp_Output_File << "0";
		}
		tmp_Output_File.close();
	}


	//    ---=============---
	//   ---===============---
	//  ---==   Config   ==---
	//   ---==============---
	//    ---============---
	
	int save_Config(int p_Construct)
	{
		std::ofstream file_Object(Constructs[p_Construct]->Config_File, std::ios::ate);

		// Check if the flag file exists and can be opened
		if (file_Object.is_open())
		{
			file_Object << "\nBase_Charge " << get_Base_Charge(p_Construct);
			file_Object << "\nModifier_Charge " << get_Modifier_Charge(p_Construct);
			file_Object << "\nAction_Potential_Threshold " << get_Action_Potential_Threshold(p_Construct);
			file_Object << "\nCharging_Tier " << get_Charging_Tier(p_Construct);
		}
		else
		{
			std::cerr << "\n \\(o.O)/ save_Config " << p_Construct << " could not open the file " << Constructs[p_Construct]->Config_File << " for writing!";
		}

		file_Object.close();
		return 1;
	}

	int update_Config(int p_Construct)
	{
		std::ifstream config_File(Constructs[p_Construct]->Config_File);

		std::string tmp_In = "";
		float tmp_float = 0.0;
		int tmp_Int = 0;

		// Check if the flag file exists and can be opened
		if (config_File.is_open())
		{
			while (!config_File.eof())
			{
				config_File >> tmp_In;

				if (tmp_In == "Base_Charge") { config_File >> tmp_float; set_Base_Charge(p_Construct, tmp_float); }// std::cout << "\nSetting Base_Charge to " << tmp_float; }
				if (tmp_In == "Modifier_Charge") { config_File >> tmp_float; set_Modifier_Charge(p_Construct, tmp_float); }//  std::cout << "\nSetting Modifier_Charge to " << tmp_float; }
				if (tmp_In == "Action_Potential_Threshold") { config_File >> tmp_float; set_Action_Potential_Threshold(p_Construct, tmp_float); }//  std::cout << "\nSetting Action_Potential_Threshold to " << tmp_float; }
				if (tmp_In == "Charging_Tier") { config_File >> tmp_Int; set_Charging_Tier(p_Construct, tmp_Int); }//  std::cout << "\nSetting Charging_Tier to " << tmp_Int; }
			}
		}
		else
		{
			std::cerr << "\n \\(o.O)/ update_Config " << p_Construct << " could not open the file " << Constructs[p_Construct]->Config_File << " for update!";
		}

		config_File.close();
		return 1;
	}

	void output_Config(int p_Construct)
	{
		Constructs[p_Construct]->CAN->output_Config();
	}

	void set_Input_Charging_Mask(const int p_Construct, std::vector<float> p_Input_Charging_Mask)
	{
		Constructs[p_Construct]->CAN->set_Input_Charging_Mask(p_Input_Charging_Mask);
	}

	//Hyperparams
	void set_Base_Charge(int p_Construct, float p_Base_Charge)
	{
		Constructs[p_Construct]->CAN->set_Base_Charge(p_Base_Charge);
	}

	void set_Modifier_Charge(int p_Construct, float p_Modifier_Charge)
	{
		Constructs[p_Construct]->CAN->set_Modifier_Charge(p_Modifier_Charge);
	}

	void set_Action_Potential_Threshold(int p_Construct, float p_Action_Potential_Threshold)
	{
		Constructs[p_Construct]->CAN->set_Action_Potential_Threshold(p_Action_Potential_Threshold);
	}

	void set_Charging_Tier(int p_Construct, int p_Charging_Tier)
	{
		Constructs[p_Construct]->CAN->set_Charging_Tier(p_Charging_Tier);
	}

	float get_Base_Charge(int p_Construct)
	{
		return Constructs[p_Construct]->CAN->get_Base_Charge();
	}

	float get_Modifier_Charge(int p_Construct)
	{
		return Constructs[p_Construct]->CAN->get_Modifier_Charge();
	}

	float get_Action_Potential_Threshold(int p_Construct)
	{
		return Constructs[p_Construct]->CAN->get_Action_Potential_Threshold();
	}

	int get_Charging_Tier(int p_Construct)
	{
		return Constructs[p_Construct]->CAN->get_Charging_Tier();
	}

	//    ---======================================================================---
	//   ---========================================================================---
	//  ---==   Output the Construct input, output, scaffolds, node network, etc.   ==---
	//   ---========================================================================---
	//    ---======================================================================---

	//    ---==  output_Constructs  ==---
	//		Outputs the Constructs currently registered.
	void output_Constructs()
	{
		for (int cou_Con = 0; cou_Con < Construct_Count; cou_Con++)
		{
			std::cout << "\n [" << cou_Con << "]: " << Constructs[cou_Con]->Name << " - " << Constructs[cou_Con]->CAN_Type;
		}
	}

	//      ---==================================---
	//     ---====================================---
	//    ---======================================---
	//   ---========================================---
	//  ---==   Generic commands for the engine.   ==---
	//   ---========================================---
	//    ---======================================---
	//     ---====================================---
	//      ---==================================---



	//    ---==  clear_output  ==---
	int clear_Output(int p_Construct)
	{
		std::ofstream file_Object(Constructs[p_Construct]->Output_File, std::ios::ate);

		// Check if the flag file exists and can be opened
		if (!file_Object.is_open())
		{
			std::cerr << "\n clear_Output " << p_Construct << " could not open the file " << Constructs[p_Construct]->Output_File << " for clearing!";
		}

		file_Object.close();
		return 1;
	}


	//    ---==  output_newline  ==---
	int output_Newline(int p_Construct)
	{
		std::ofstream file_Object(Constructs[p_Construct]->Output_File, std::ios::app);

		// Check if the flag file exists and can be opened
		if (file_Object.is_open())
		{
			file_Object << "\n";
		}
		else
		{
			std::cerr << "\n clear_Output " << p_Construct << " could not open the file " << Constructs[p_Construct]->Output_File << " for newline!";
		}

		file_Object.close();
		return 1;
	}

	//    ---==  output_newline  ==---
	int write_Text(int p_Construct, std::string p_Text)
	{
		std::ofstream file_Object(Constructs[p_Construct]->Output_File, std::ios::app);

		// Check if the flag file exists and can be opened
		if (file_Object.is_open())
		{
			file_Object << p_Text;
		}
		else
		{
			std::cerr << "\n clear_Output " << p_Construct << " could not open the file " << Constructs[p_Construct]->Output_File << " for newline!";
		}

		file_Object.close();
		return 1;
	}

};

/** @}*///It annoys the shit out of me to put the count before the array in the argument list, but the text server is structured as such, mostly because I'm being lazy and don't want to write a complex interpreter atm, so this is structured as such.

//The construct encapsulates the node network, the CANs, I/O, granulation filter, uinterface, actuator interface, and I/O tables.
//The result is that after setting up the network the user can use it like a black box.
class c_Construct_API
{
public:
	
	c_Construct Base;

	c_Construct_API()
	{
	}

	//Checks for a construct by name, if found returns the ID, if not found returns -1
	int get_Construct_ID(std::string p_Construct_Name)
	{
		//std::cout << "\n p_Construct_Name: " << p_Construct_Name << " ID: " << Base.get_Construct_ID(p_Construct_Name);
		return Base.get_Construct_ID(p_Construct_Name);
	}

//      ---==================---
//     ---====================---
//    ---======================---
//   ---========================---
//  ---==   NT4 Deep Control   ==---
//   ---========================---
//    ---======================---
//     ---====================---
//      ---==================---
  
	void save_Config(std::string p_Construct)
	{
		Base.save_Config(get_Construct_ID(p_Construct));
	}

	void update_Config(std::string p_Construct)
	{
		Base.update_Config(get_Construct_ID(p_Construct));
	}

	//Hyperparams
	void set_Base_Charge(std::string p_Construct, float p_Base_Charge)
	{
		Base.set_Base_Charge(get_Construct_ID(p_Construct), p_Base_Charge);
	}

	void set_Modifier_Charge(std::string p_Construct, float p_Modifier_Charge)
	{
		Base.set_Modifier_Charge(get_Construct_ID(p_Construct), p_Modifier_Charge);
	}

	void set_Action_Potential_Threshold(std::string p_Construct, float p_Action_Potential_Threshold)
	{
		Base.set_Action_Potential_Threshold(get_Construct_ID(p_Construct), p_Action_Potential_Threshold);
	}

	void set_Charging_Tier(std::string p_Construct, int p_Charging_Tier)
	{
		Base.set_Charging_Tier(get_Construct_ID(p_Construct), p_Charging_Tier);
	}

	float get_Base_Charge(std::string p_Construct)
	{
		return Base.get_Base_Charge(get_Construct_ID(p_Construct));
	}

	float get_Modifier_Charge(std::string p_Construct)
	{
		return Base.get_Modifier_Charge(get_Construct_ID(p_Construct));
	}

	float get_Action_Potential_Threshold(std::string p_Construct)
	{
		return Base.get_Action_Potential_Threshold(get_Construct_ID(p_Construct));
	}

	int get_Output_Depth(std::string p_Construct)
	{
		return Base.get_Output_Depth(get_Construct_ID(p_Construct));
	}

	float get_Output_Charge(std::string p_Construct, int p_Output)
	{
		return Base.get_Output_Charge(get_Construct_ID(p_Construct), p_Output);
	}

	uint64_t get_Output_Treetop_NID(std::string p_Construct, int p_Output)
	{
		return Base.get_Output_Treetop_NID(get_Construct_ID(p_Construct), p_Output);
	}

	float get_Output_RC(std::string p_Construct, int p_Output)
	{
		return Base.get_Output_RC(get_Construct_ID(p_Construct), p_Output);
	}

	std::string get_Output_Pattern(std::string p_Construct, int p_Output)
	{
		return Base.get_Output_Pattern(get_Construct_ID(p_Construct), p_Output);
	}

	std::vector<uint64_t> get_Output_Pattern_uint(std::string p_Construct, int p_Output)
	{
		return Base.get_Output_Pattern_uint(get_Construct_ID(p_Construct), p_Output);
	}
	
	uint64_t get_Output_Primitive_uint(std::string p_Construct, int p_Output, int p_Index = 0)
	{
		return Base.get_Output_Primitive_uint(get_Construct_ID(p_Construct), p_Output, p_Index);
	}

	int get_Output_Pattern_Size(std::string p_Construct, int p_Output)
	{
		return Base.get_Output_Pattern_Size(get_Construct_ID(p_Construct), p_Output);
	}

	int get_Construct_Count()
	{
		return Base.get_Construct_Count();
	}

//    ---==========---
//   ---============---
//  ---==   Node   ==---
//   ---============---
//    ---==========---

	//---==  set_type [NID] [TYPE]  ==---//
    //(0: State), (1: Branch), (2: Treetop), (3: State/Treetop)
	void set_Type(uint64_t p_NID, uint8_t p_Type)
	{
		Base.set_Type(Base.get_Node_Ref_By_NID(p_NID), p_Type);
	}


	
	//---==  add_axon_index [NID] [Axon_NID] [INDEX]  ==---//
	//Adds an axon to the axon list at the given index, if the index doesn't exist then exist it with resize_Axon_Hillocks()
	void add_Axon_Index(uint64_t p_NID, uint64_t p_Axon_NID, int p_Index)
	{
		Base.add_Axon_Index(Base.get_Node_Ref_By_NID(p_NID), Base.get_Node_Ref_By_NID(p_Axon_NID), p_Index);
	}


	
	//---==  set_Dendrites [NID] [DENDRITE_IDS[]] [COUNT]  ==---//
    //Sets the dendrites of the node.
    //This assumes the node has no dendrites yet, if it does you be dangling and jangling
	void set_Dendrites(uint64_t p_NID, int p_Count, uint64_t* p_Dendrite_NIDs)
	{
		c_Node** tmp_Dendrites = NULL;
		tmp_Dendrites = new c_Node*[p_Count];

		for (int cou_Index = 0; cou_Index < p_Count; cou_Index++)
		{
			tmp_Dendrites[cou_Index] = Base.get_Node_Ref_By_NID(p_Dendrite_NIDs[cou_Index]);
		}

		Base.set_Dendrites(Base.get_Node_Ref_By_NID(p_NID), p_Count, tmp_Dendrites);

		for (int cou_Index = 0; cou_Index < p_Count; cou_Index++)
		{
			tmp_Dendrites[cou_Index] = NULL;
		}

		if (tmp_Dendrites != NULL) { delete[] tmp_Dendrites; tmp_Dendrites = NULL; }
	}


	//---==  does_Upper_Tier_Connection_Exist NODE_COUNT NODES[]  ==---//
    //Searches the axons to see if an upper tier connection exists.
    //This is always called from the first leg, that is why we separate _F from normal.
	uint64_t does_Upper_Tier_Connection_Exist(int p_Count, uint64_t* p_Nodes)
	{
		c_Node** tmp_Nodes = NULL;
		tmp_Nodes = new c_Node*[p_Count];
		c_Node * return_NID = NULL;

		for (int cou_Index = 0; cou_Index < p_Count; cou_Index++)
		{
			tmp_Nodes[cou_Index] = Base.get_Node_Ref_By_NID(p_Nodes[cou_Index]);
		}

		return_NID = Base.does_Upper_Tier_Connection_Exist(p_Count, tmp_Nodes);

		for (int cou_Index = 0; cou_Index < p_Count; cou_Index++)
		{
			tmp_Nodes[cou_Index] = NULL;
		}

		if (tmp_Nodes != NULL) { delete[] tmp_Nodes; tmp_Nodes = NULL; }

		if (return_NID != NULL) { return return_NID->NID; }
		return 0;
	}


	//---==  does_Lower_Connection_Exist [NID] [NODES[]] [NODE_COUNT]  ==---//
    //Checks if the given node matches a dendrite on the right leg.
	bool does_Lower_Connection_Exist(uint64_t p_NID, int p_Count, uint64_t* p_Nodes)
	{
		c_Node** tmp_Nodes = NULL;
		tmp_Nodes = new c_Node*[p_Count];
		bool return_Result = 0;

		for (int cou_Index = 0; cou_Index < p_Count; cou_Index++)
		{
			tmp_Nodes[cou_Index] = Base.get_Node_Ref_By_NID(p_Nodes[cou_Index]);
		}

		return_Result = Base.does_Lower_Connection_Exist(Base.get_Node_Ref_By_NID(p_NID), p_Count, tmp_Nodes);

		for (int cou_Index = 0; cou_Index < p_Count; cou_Index++)
		{
			tmp_Nodes[cou_Index] = NULL;
		}

		if (tmp_Nodes != NULL) { delete[] tmp_Nodes; tmp_Nodes = NULL; }

		return return_Result;
	}



	//---==  bind_State [NID] [STATE_UINT]  ==---//
    //Binds a node to a quanta of data, the state of the input.
	void bind_State(uint64_t p_NID, uint64_t p_State)
	{
		Base.bind_State(Base.get_Node_Ref_By_NID(p_NID), p_State);
	}



	//---==  bp_O [NID]  ==---//
    //Initiates a backpropagation that outputs the pattern represented by this node.
	void bp_O(uint64_t p_NID)
	{
		Base.bp_O(Base.get_Node_Ref_By_NID(p_NID));
	}



	//---==  output_Node_Raw [NID]  ==---//
	//Outputs the ugly raw info dump for the node.
	void output_Node_Raw(uint64_t p_NID)
	{
		Base.output_Node_Raw(Base.get_Node_Ref_By_NID(p_NID));
	}


	//---==  output_Node_Raw [NID]  ==---//
	//Outputs the ugly raw info dump for the node.
	void output_Treetop_Node_Raw(std::string p_Construct)
	{
		Base.output_Treetop_Node_Raw(get_Construct_ID(p_Construct));
	}



	//---==  output_Node_Char [NID]  ==---//
	//Casts the node address to char() and outputs it.
	void output_Node_Char(uint64_t p_NID)
	{
		Base.output_Node_Char(Base.get_Node_Ref_By_NID(p_NID));
	}


	
  
  
//    ---==================---
//   ---====================---
//  ---==   Node_Network   ==---
//   ---====================---
//    ---==================---
  
	//---==  new_Node  ==---//
	//Creates a new node and adds it to the fractal tree.
	//Each node is stored as a link in a linked list.
	uint64_t new_Node()
	{
		return (Base.new_Node())->NID;
	}
  

	//---==  new_State_Node [Construct_ID] [STATE_DOUBLE]  ==---//
	//Creates a new node, then adds it to the state tree.
	//Assumes the construct is already registered so the index is valid.
	uint64_t new_State_Node(std::string p_Construct, uint64_t p_State)
	{
		return (Base.new_State_Node(get_Construct_ID(p_Construct), p_State))->NID;
	}
  

	//---==  create_Connections [TO_NID] [FROM_NIDS[]] [COUNT]  ==---//
	//Creates a connection between nodes.
	//p_To forms dendritic connections to p_From, and on p_From you have the axonic connections.
	void create_Connections(uint64_t p_To_NID, int p_Count, uint64_t* p_From_NID)
	{
		c_Node** tmp_From = NULL;
		tmp_From = new c_Node * [p_Count];

		for (int cou_Index = 0; cou_Index < p_Count; cou_Index++)
		{
			tmp_From[cou_Index] = Base.get_Node_Ref_By_NID(p_From_NID[cou_Index]);
		}

		Base.create_Connections(Base.get_Node_Ref_By_NID(p_To_NID), p_Count, tmp_From);

		for (int cou_Index = 0; cou_Index < p_Count; cou_Index++)
		{
			tmp_From[cou_Index] = NULL;
		}

		if (tmp_From != NULL) { delete[] tmp_From; tmp_From = NULL; }
	}
  

	//---==  does_Upper_Tier_Connection_Exist [LEGS] [LEG_COUNT]  ==---//
	//Checks if an upper tier node exists.
	uint64_t does_Upper_Tier_Connection_Exist_Network(int p_Count, uint64_t* p_Legs_NID)
	{
		c_Node** tmp_Legs = NULL;
		tmp_Legs = new c_Node * [p_Count];
		c_Node* tmp_Return_Node = NULL;

		for (int cou_Index = 0; cou_Index < p_Count; cou_Index++)
		{
			tmp_Legs[cou_Index] = Base.get_Node_Ref_By_NID(p_Legs_NID[cou_Index]);
		}

		tmp_Return_Node = Base.does_Upper_Tier_Connection_Exist(p_Count, tmp_Legs);

		for (int cou_Index = 0; cou_Index < p_Count; cou_Index++)
		{
			tmp_Legs[cou_Index] = NULL;
		}

		if (tmp_Legs != NULL) { delete[] tmp_Legs; tmp_Legs = NULL; }

		if (tmp_Return_Node != NULL) { return tmp_Return_Node->NID; }
		return NULL;
	}
  

	//---==  get_Upper_Tier_Node [LEGS] [LEG_COUNT]  ==---//
	//Gets an upper tier node based on the given legs. Will create it if not found.
	uint64_t get_Upper_Tier_Node(int p_Count, uint64_t* p_Legs_NID)
	{
		c_Node** tmp_Legs = NULL;
		tmp_Legs = new c_Node * [p_Count];
		c_Node* tmp_Return_Node = NULL;

		for (int cou_Index = 0; cou_Index < p_Count; cou_Index++)
		{
			tmp_Legs[cou_Index] = Base.get_Node_Ref_By_NID(p_Legs_NID[cou_Index]);
		}

		tmp_Return_Node = Base.get_Upper_Tier_Node(p_Count, tmp_Legs);

		for (int cou_Index = 0; cou_Index < p_Count; cou_Index++)
		{
			tmp_Legs[cou_Index] = NULL;
		}

		if (tmp_Legs != NULL) { delete[] tmp_Legs; tmp_Legs = NULL; }

		if (tmp_Return_Node != NULL) { return tmp_Return_Node->NID; }
		return NULL;
	}

  
	//---==  does_State_Node_Exist [Construct_ID] [STATE]  ==---//
	//If a state node exists in the given construct index then return it.
	//Otherwise return NULL.
	//This assumes the [Index] is valid
	uint64_t does_State_Node_Exist(std::string p_Construct, uint64_t p_State)
	{
		c_Node* tmp_Node = NULL;
		tmp_Node = Base.does_State_Node_Exist(get_Construct_ID(p_Construct), p_State);

		if (tmp_Node != NULL) { return tmp_Node->NID; }
		return 0;
	}
  

	//---==  get_State_Node [Construct_ID] [STATE]  ==---//
	//Checks to see if a node in the given Construct is bound to the given state, if not the node is created.
	uint64_t get_State_Node(std::string p_Construct, uint64_t p_State)
	{
		c_Node* tmp_Node = NULL;
		tmp_Node = Base.get_State_Node(get_Construct_ID(p_Construct), p_State);

		if (tmp_Node != NULL) { return tmp_Node->NID; }
		return 0;
	}


	//---==  wipe_Network_Charges  ==---//
	//Wipes the current network charges, this is network wide.
	void wipe_Network_Charges()
	{
		Base.wipe_Network_Charges();
	}

	//---==  output_BP  ==---//
	//Iterates through every node and outputs their bp_O()
	void output_Backpropagated_Symbols(int p_Datatype)
	{
		Base.output_Backpropagated_Symbols(p_Datatype);
	}

	//---==  output_BP  ==---//
	//Iterates through every node and outputs their bp_O()
	void output_Backpropagated_Symbols_Float()
	{
		Base.output_Backpropagated_Symbols(2);
	}

  
	//---==  output_BP_NID [NID]  ==---//
	//Finds given NID and outputs the bp_O()
	void output_Backpropagated_Symbol_NID(uint64_t p_NID)
	{
		Base.output_Backpropagated_Symbol_NID(p_NID);
	}

	void output_Backpropagated_Symbol_NID_uint(uint64_t p_NID)
	{
		Base.output_Backpropagated_Symbol_NID_uint(p_NID);
	}
  
	//---==  output_Node_Network  ==---//
	//Outputs all of the nodes as raw.
	void output_Node_Network()
	{
		Base.output_Node_Network();
	}
  
	//---==  output_Network_Charges  ==---//
	//Outputs all of the charges as characters.
	void output_Network_Charges(std::string p_FName_Prefix = "")
	{
		Base.output_Network_Charges(p_FName_Prefix);
	}

	//    ---=========---
	//   ---===========---
	//  ---==   CAN   ==---
	//   ---===========---
	//    ---=========---

	void chrono_Shift(std::string p_Construct)
	{
		Base.chrono_Shift(get_Construct_ID(p_Construct));
	}

	void add_Chrono(std::string p_Construct, uint64_t p_Chrono)
	{
		Base.add_Chrono(get_Construct_ID(p_Construct), p_Chrono);
	}

	void pull_Chrono_From_Lower_Connection(std::string p_Construct)
	{
		Base.pull_Chrono_From_Lower_Connection(get_Construct_ID(p_Construct));
	}

	//---==  encode [Construct_ID]  ==---//
	//This encodes the p_Input data, if the nodes aren't found they are created, used for training.
	//Encodes the current input of the given Construct. How it does this is determined by what type of Construct it is.
	void encode(std::string p_Construct)
	{
		Base.encode(get_Construct_ID(p_Construct));
	}

	//This fills out the NULLCAN, but does not eval, and does not encode. Used when you want to check for an encoded symbol and get the Treetop.
	void check_Symbol(std::string p_Construct)
	{
		Base.check_Symbol(get_Construct_ID(p_Construct));
	}

	//    ---==  query [Construct_ID]  ==---
	//This sets up the scaffold as encode does, but it doesn't create nodes if they aren't found, they remain NULL in the scaffold, this we call a NULLCAN
	//Used for querying the network, you input, fill the NULLCAN, charge the network, then gather the outputs.
	//Suggested for use before encoding (if using learning mode and not locked_to_initial_training_mode) otherwise it will also find the current trace as the perfect match.
	//		Queries the network with the current input set for the given Construct.
		//Passes the values to an Construct to encode.
	void query(std::string p_Construct)
	{
		Base.query(get_Construct_ID(p_Construct));
	}

	//    ---==  query_spacial [Construct_ID]  ==---
	//		Queries the network with the current input set of the given Construct, but the input index determines what leg is charged. Meaning if an input at index [3] is charged then only upper tier nodes connected on axon hillock [3] will be charged.
		//Passes the values to an Construct to encode.
	void query_Spacial(std::string p_Construct)
	{
		Base.query(get_Construct_ID(p_Construct), 1);
	}

	//    ---==  query_given_index [Construct_ID] [INDEX]  ==---
	//		Queries the network with the current input set, however, every input node is charged on the given index. If INDEX is [3] then all nodes in the input set will be charging using axon hillock [3].
		//Passes the values to an Construct to encode.
	void query_Given_Index(std::string p_Construct, int p_Index)
	{
		Base.query(get_Construct_ID(p_Construct), 2, p_Index);
	}

	//    ---==  query_given_legs[Construct_ID] [LEG_COUNT] [LEG_0] [LEG_1] [...]  ==---
	void query_Given_Legs(std::string p_Construct, int p_Leg_Count, int* p_Legs)
	{
		Base.query(get_Construct_ID(p_Construct), 3, p_Leg_Count, p_Legs);
	}


	//---==  submit_Set [Construct_ID] [INPUT_UINT[]] [DEPTH]  ==---//
	//This allows for passing unordered sets of nodes
	void submit_Set(std::string p_Construct, int p_Depth, uint64_t* p_Input)
	{
		Base.submit_Set(get_Construct_ID(p_Construct), p_Depth, p_Input);
	}

	//Used for encoding.
	void round_Up_Input(std::string p_Construct)
	{
		Base.round_Up_Input(get_Construct_ID(p_Construct));
	}

	void round_Up_Given_Input(std::string p_Construct, int p_Input)
	{
		Base.round_Up_Given_Input(get_Construct_ID(p_Construct), p_Input);
	}

	//Used for eval, pulls the output from lower to upper.
	void pull_From_Lower_Connections(std::string p_Construct)
	{
		Base.pull_From_Lower_Connections(get_Construct_ID(p_Construct));
	}

	void pull_From_Lower_Connection(std::string p_Construct, int p_Index)
	{
		Base.pull_From_Lower_Connection(get_Construct_ID(p_Construct), p_Index);
	}

	//Iterates through every output trace in the given index of the given upper tier construct.
	void pull_From_Upper_Index(std::string p_Construct_To, std::string p_Construct_From, int p_Index)
	{
		Base.pull_From_Upper_Index(get_Construct_ID(p_Construct_To), get_Construct_ID(p_Construct_From), p_Index);
	}

	//---==  get_Treetop [Construct_ID]  ==---//
	//Gets the treetop node for a given Construct.
	//This returns the treetop node at a given index, for most structures this will be a single node, but for those like stiched-base networks with a treetop node count equal to the input node count then you can access them by index.
	//Gets the treetop node for a given Construct.
	uint64_t get_Treetop_NID(std::string p_Construct)
	{
		return Base.get_Treetop_NID(get_Construct_ID(p_Construct));
	}


	//---==  gather_Given_Trace [Construct_ID] [NID]  ==---//
	//Gets a single trace from a given node. Puts it into the output.
	void gather_Given_Trace(std::string p_Construct, uint64_t p_NID)
	{
		Base.gather_Given_Trace(get_Construct_ID(p_Construct), p_NID);
	}

	void write_Given_Pattern_As_Number(std::string p_Construct, uint64_t p_NID)
	{
		Base.write_Given_Pattern_As_Number(get_Construct_ID(p_Construct), p_NID);
	}


	//---==  gather_All_Traces [Construct]  ==---//
	//Gathers all the traces as it says.
	void gather_All_Traces(std::string p_Construct)
	{
		Base.gather_All_Traces(get_Construct_ID(p_Construct));
	}

	//---==  gather_All_Traces [Construct]  ==---//
	//Gathers all the traces as it says.
	void gather_All_Traces_uint(std::string p_Construct)
	{
		Base.gather_All_Traces_uint(get_Construct_ID(p_Construct));
	}


	//---==  reset_Input [Construct_ID]  ==---//
	//Wipe the input array.
	void reset_Input(std::string p_Construct)
	{
		Base.reset_Input(get_Construct_ID(p_Construct));
	}


	//---==  reset_Output [Construct_ID]  ==---//
	//Wipe the output array.
	void reset_Output(std::string p_Construct)
	{
		Base.reset_Output(get_Construct_ID(p_Construct));
	}


	//---==  set_State_Nodes_Index [Construct_ID] [INDEX]  ==---//
	//Sets the index for the state_Node_Tree in the c_Node_Network::State_Nodes[]
	void set_State_Nodes_Index(std::string p_Construct, int p_Index)
	{
		Base.set_State_Nodes_Index(get_Construct_ID(p_Construct), p_Index);
	}


	

	//---==  output_Scaffold [Construct_ID]  ==---//
	//Outputs the scaffold as addresses.
	void output_Scaffold(std::string p_Construct)
	{
		Base.output_Scaffold(get_Construct_ID(p_Construct));
	}


	//---==  output_Input [Construct_ID]  ==---//
	//		Outputs the input of the given Construct to the console.
	void output_Input(std::string p_Construct)
	{
		Base.output_Input(get_Construct_ID(p_Construct));
	}


	//---==  output_Input [Construct_ID]  ==---//
	//		Outputs the input of the given Construct to the console.
	void output_Input_uint(std::string p_Construct)
	{
		Base.output_Input_uint(get_Construct_ID(p_Construct));
	}


	//---==  output_Output [Construct_ID]  ==---//
	//The output trace set is output.
	void output_Output(std::string p_Construct)
	{
		Base.output_Output(get_Construct_ID(p_Construct));
	}



	//---==  output_Output [Construct_ID]  ==---//
	//The output trace set is output.
	void output_Output_uint(std::string p_Construct)
	{
		Base.output_Output_uint(get_Construct_ID(p_Construct));
	}
	
	void output_Output_Double(std::string p_Construct)
	{
		Base.output_Output_Double(get_Construct_ID(p_Construct));
	}
	
	
	void output_Output_Int(std::string p_Construct)
	{
		Base.output_Output_Int(get_Construct_ID(p_Construct));
	}


	//---==  output_Scaffold_Char [Construct_ID]  ==---//
	//Each address is typecast to a char to give a pseudo-unique look to each node. For monke brain.
	void output_Scaffold_Char(std::string p_Construct)
	{
		Base.output_Scaffold_Char(get_Construct_ID(p_Construct));
	}


	//---==  output_Scaffold_Char [Construct_ID]  ==---//
	//Each address is typecast to a char to give a pseudo-unique look to each node. For monke brain.
	void output_Scaffold_Symbols(std::string p_Construct)
	{
		Base.output_Scaffold_Symbols(get_Construct_ID(p_Construct));
	}

	void output_Scaffold_Symbols_uint(std::string p_Construct)
	{
		Base.output_Scaffold_Symbols_uint(get_Construct_ID(p_Construct));
	}

	void output_Scaffold_Symbols_Float(std::string p_Construct)
	{
		Base.output_Scaffold_Symbols_Float(get_Construct_ID(p_Construct));
	}





	//      ---====================---
	//     ---======================---
	//    ---========================---
	//   ---==========================---
	//  ---==   NT4 specific hooks   ==---
	//   ---==========================---
	//    ---========================---
	//     ---======================---
	//      ---====================---



	//    ---======================================---
	//   ---========================================---
	//  ---==   Used to register/connect new Constructs.   ==---
	//   ---========================================---
	//    ---======================================---

		//    ---==  register_Construct [Construct_TYPE] [Construct_NAME]  ==---
		//p_Type is the type of CAN to declare. 
		// "Many_To_One" - The I/O tier has every node connected to a single upper tier node.
	int register_Construct(std::string p_Type, std::string p_Construct_Name)
	{
		return Base.register_Construct(p_Type, p_Construct_Name);
	}

	void create_Construct_Connection(std::string p_From, std::string p_To)
	{
		Base.create_Construct_Connection(get_Construct_ID(p_From), get_Construct_ID(p_To));
	}

	void output_Construct_Connections(std::string p_Construct)
	{
		Base.output_Construct_Connections(get_Construct_ID(p_Construct));
	}

	//    ---=====================---
	//   ---=======================---
	//  ---==   Input handling.   ==---
	//   ---=======================---
	//    ---=====================---

	//    ---==  load_input  ==---
	int load_Input(std::string p_Construct)
	{
		return Base.load_Input(get_Construct_ID(p_Construct));
	}

	int load_Input_uint(std::string p_Construct)
	{
		return Base.load_Input_uint(get_Construct_ID(p_Construct));
	}

	//    ---==  set_input [Construct_ID] [INPUT_STRING]  ==---
		//Set the value to the passed 1D string of uint64_t
	void set_Input(std::string p_Construct, std::string p_Input)
	{
		Base.set_Input(get_Construct_ID(p_Construct), p_Input);
	}

	//    ---==  set_input_uint [Construct_ID] [ARRAY_DEPTH] [UINT_ARRAY]  ==---
		//Set the value to the passed 1D string of uint64_t
	void set_Input_uint(std::string p_Construct, int p_Depth, uint64_t* p_Input)
	{
		Base.set_Input_uint(get_Construct_ID(p_Construct), p_Depth, p_Input);
	}


	void set_Input_Charging_Mask(std::string p_Construct, std::vector<float> p_Input_Charging_Mask)
	{
		Base.set_Input_Charging_Mask(get_Construct_ID(p_Construct), p_Input_Charging_Mask);
	}


	//---==  set_Input [Construct_ID] [INPUT_UINT[]] [INPUT_DEPTH]  ==---//
	//Sets the input to the given uint64_t array.
	//The input array is 1D
	void set_Input(std::string p_Construct, int p_Input_Depth, uint64_t* p_Input)
	{
		Base.set_Input(get_Construct_ID(p_Construct), p_Input_Depth, p_Input);
	}



	//Sets the input to the given uint64_t 2d array.
	//The input array is 2D
	void set_2D_Input_uint(std::string p_Construct, int p_X_Depth, int p_Y_Depth, uint64_t** p_Input)
	{
		Base.set_2D_Input(get_Construct_ID(p_Construct), p_X_Depth, p_Y_Depth, p_Input);
	}


	//Sets the input to the given uint64_t 3d array.
	//The input array is 3D
	void set_3D_Input_uint(std::string p_Construct, int p_X_Depth, int p_Y_Depth, int p_Z_Depth, uint64_t*** p_Input)
	{
		Base.set_3D_Input(get_Construct_ID(p_Construct), p_X_Depth, p_Y_Depth, p_Z_Depth, p_Input);
	}



	//---==  set_Input_String [Construct_ID] [INPUT_STR]  ==---//
	//This is used for setting the input array to reflect a sequence of characters.
	void set_Input_String(std::string p_Construct, std::string p_Input)
	{
		Base.set_Input_String(get_Construct_ID(p_Construct), p_Input);
	}

	//    ---==========================================================================---
	//   ---============================================================================---
	//  ---==   Different ways of gathering nodes, individually, and the entire set.   ==---
	//   ---============================================================================---
	//    ---==========================================================================---

	//    ---==  gather_given_node [Construct_ID] [NID]  ==---
	//		Writes the given node's data down in the Construct_Output_Files[get_Construct_ID(p_Construct)] file.
	void gather_Given_Node(std::string p_Construct, uint64_t p_NID)
	{
		Base.gather_Given_Node(get_Construct_ID(p_Construct), p_NID);
	}

	//		Writes the given node's data down in the Construct_Output_Files[get_Construct_ID(p_Construct)] file.
	void gather_Given_Node_uint(std::string p_Construct, uint64_t p_NID)
	{
		Base.gather_Given_Node_uint(get_Construct_ID(p_Construct), p_NID);
	}

	//    ---==  gather_all_nodes [Construct_ID]  ==---
	//		This writes the entire network to the Construct_Output_Files[get_Construct_ID(p_Construct)] file. Note, the output patterns are treated as character.
		//It uses the passed Construct to output the nodes by putting it into the output of that Construct, then into the file.
	void gather_All_Nodes(std::string p_Construct)
	{
		Base.gather_All_Nodes(get_Construct_ID(p_Construct));
	}

	//    ---==  gather_all_nodes_uint [Construct_ID]  ==---
	//		This writes the entire network to the Construct_Output_Files[get_Construct_ID(p_Construct)] file. Note, the output patterns are treated as uint.
	void gather_All_Nodes_uint(std::string p_Construct)
	{
		Base.gather_All_Nodes_uint(get_Construct_ID(p_Construct));
	}


	//    ---==================================================================---
	//   ---====================================================================---
	//  ---==   The output of a given Construct is read into the output file.   ==---
	//   ---====================================================================---
	//    ---==================================================================---


	//    ---==  gather_output [Construct_ID]  ==---
	//		Takes every trace in the given Constructs output trace array and writes them to the Construct_Output_Files[get_Construct_ID(p_Construct)] file, note the output state patterns are treated as char.
	void gather_Output(std::string p_Construct)
	{
		Base.gather_Output(get_Construct_ID(p_Construct));
	}

	//    ---==  gather_output_uint [Construct_ID]  ==---
	//		Takes every trace in the given Constructs output trace array and writes them to the Construct_Output_Files[get_Construct_ID(p_Construct)] file, note the output state patterns are treated as uint.
	void gather_Output_uint(std::string p_Construct)
	{
		Base.gather_Output_uint(get_Construct_ID(p_Construct));
	}


	//    ---=============================---
	//   ---===============================---
	//  ---==   Treetop node gathering.   ==---
	//   ---===============================---
	//    ---=============================---

	//    ---==  gather_treetop_node [Construct_ID]  ==---
	//		This writes the current treetop node of the given Construct to the Construct_Output_Files[get_Construct_ID(p_Construct)] file. This does not erase the file.
	void gather_Treetop_Node(std::string p_Construct)
	{
		Base.gather_Treetop_Node(get_Construct_ID(p_Construct));
	}

	//    ---==  gather_treetop_node_uint [Construct_ID]  ==---
	//		This writes the current treetop node of the given Construct to the Construct_Output_Files[get_Construct_ID(p_Construct)] file. This does not erase the file.
	void gather_Treetop_Node_uint(std::string p_Construct)
	{
		Base.gather_Treetop_Node_uint(get_Construct_ID(p_Construct));
	}

	//    ---==  gather_treetop_NID [Construct_ID]  ==---
	//		This writes only the NID of the current treetop to the file. Does not erase the file.
	void gather_Treetop_NID(std::string p_Construct)
	{
		Base.gather_Treetop_NID(get_Construct_ID(p_Construct));
	}

	void write_Treetop_NID_To_Other_Input(std::string p_Construct_From, std::string p_Construct_To)
	{
		Base.write_Treetop_NID_To_Other_Input(get_Construct_ID(p_Construct_From), get_Construct_ID(p_Construct_To));
	}

	void gather_Treetops(std::string p_Construct)
	{
		Base.gather_Treetops(get_Construct_ID(p_Construct));
	}


	//    ---======================================================================---
	//   ---========================================================================---
	//  ---==   Output the Construct input, output, scaffolds, node network, etc.   ==---
	//   ---========================================================================---
	//    ---======================================================================---

	//    ---==  output_Constructs  ==---
	//		Outputs the Constructs currently registered.
	void output_Constructs()
	{
		Base.output_Constructs();
	}

	void output_Construct_Config(std::string p_Construct)
	{
		Base.output_Config(get_Construct_ID(p_Construct));
	}

	//      ---==================================---
	//     ---====================================---
	//    ---======================================---
	//   ---========================================---
	//  ---==   Generic commands for the engine.   ==---
	//   ---========================================---
	//    ---======================================---
	//     ---====================================---
	//      ---==================================---



	//    ---==  clear_output  ==---
	int clear_Output(std::string p_Construct)
	{
		return Base.clear_Output(get_Construct_ID(p_Construct));
	}


	//    ---==  output_newline  ==---
	int output_Newline(std::string p_Construct)
	{
		return Base.output_Newline(get_Construct_ID(p_Construct));
	}	
	
	int write_Text(std::string p_Construct, std::string p_Text)
	{
		return Base.write_Text(get_Construct_ID(p_Construct), p_Text);
	}


	void save(std::string p_FName)
	{
		Base.save(p_FName);
	}

	void load(std::string p_FName)
	{
		Base.load(p_FName);
	}
};/** \addtogroup Construct_Text_Server
 *  @{
 */

/** \class c_Construct_Text_Server
    \brief This is a handshake based text interface for the engine. 

    
    File-Based Command Control System for Asynchronous Standalone Neural-Net Engine Control:

    Text-Based Command Execution:
    - Commands are represented as text strings that specify actions or operations to be performed by the system or process.
    - Each command is associated with a specific functionality or operation within the system.

    File I/O:
    - Input and output operations are performed using files as the medium of communication.
    - Commands are read from input files, and outputs, returns, and status indicators are written to output files, though some commands do output to the console.
    - This method facilitates asynchronous communication between systems, as they can read from and write to files independently.

    Handshake Protocol:
    - A handshake protocol is used to establish communication or synchronize actions between systems.
    - In this context, a flag file serves as a mechanism for signaling the readiness or completion of certain operations, namely that the user has written a command sequence to 'Control_Panel.ssv' that is ready to be interpreted..
    - The content of the flag file is used to indicate the status of the control panel, allowing the system to either wait or act accordingly.

    Flag File:
    - A flag file is a small file used to signal the status or state of the system.
    - It typically contains simple data or metadata, such as a single value or indicator, to convey information. In the NT4 text interface it is a boolean value.
    - Flag files are used as synchronization primitives to coordinate activities between systems.

    Control Panel:
    - The control panel represents a set of commands or instructions that can be executed by the system or process.
    - It is stored in a separate file (e.g., Control_Panel.ssv), which contains a sequence of commands or directives to be processed.

    Interpretation and Execution:
    - The system interprets commands read from the control file (e.g., Control_Panel.ssv) and executes them sequentially.
    - Command execution may involve performing operations on data, manipulating the state of the system, or interacting with external resources.

    Status Checking and Control Flow:
    - The system periodically checks the status of a flag file (e.g., Control_Panel_Flag.ssv) to determine if there are new commands to execute or if certain operations have completed.
    - Based on the status indicated by the flag file, the system may initiate specific actions, continue processing, or wait for further instructions.

    Startup and 'autoexec.ssv':
    - For 'booting up' the system interprets the commands found in 'autoexec.ssv' sequentially. This allows for shell scripting a startup sequence.

    Custom Commands:
    - A script file placed in "./Scripts/" can be called by simply entering the filename as you would a command token. A file can call other files so you can create dependency hell for yourself if you wish, but with the added complexity of ML.
    
    \var string const RETURN_FILE defines the file in which returns write their data at this level of the API.
*/

const std::string RETURN_FILE = "./Output/returned.ssv";
class c_Construct_Text_Server
{
    //The construct to hook into.
    NT4::c_Construct_API API;
    
    //Current server tick.
    int Tick;

    //Exit flag to allow for exit after startup if the user puts 'exit' into the autoexec file, needed for CLI capabilities.
    bool flg_Exit;

private:


    //    ---==  write_to_output  ==---
    int write_to_output(std::string p_FName, uint64_t p_Data)
    {
        //std::cout << "\n\n __COMMAND__| write_to_output |";
        //std::cout << " - FName \"" << p_FName << "\" Data:" << p_Data;
        std::ofstream tmp_Out(p_FName, std::ios::app);

        // Check if the flag file exists and can be opened
        if (tmp_Out.is_open())
        {
            tmp_Out << p_Data;
        }

        tmp_Out.close();


        return 1;
    }

    //    ---==  write_to_output  ==---
    int write_to_output(std::string p_FName, std::string p_Data)
    {
        //std::cout << "\n\n __COMMAND__| write_to_output |";

        std::ofstream tmp_Out(p_FName, std::ios::app);

        // Check if the flag file exists and can be opened
        if (tmp_Out.is_open())
        {
            tmp_Out << p_Data;
        }

        tmp_Out.close();


        return 1;
    }




    int eval_Command(std::string p_Command, std::ifstream* p_File)
    {
        //==--  Basic Command List  --=//
        // 
        //Meta commands for the engine rather than the nodes and internal structures.
        if (p_Command == "exit") { return -1; }

        //Data Loading and Preparation:
        if (p_Command == "reset_Input") { reset_Input(p_File); return 1; }
        if (p_Command == "reset_Output") { reset_Output(p_File); return 1; }
        if (p_Command == "set_Input") { set_Input(p_File); return 1; }
        if (p_Command == "set_Input_uint") { set_Input_uint(p_File); return 1; }
        if (p_Command == "set_2D_Input_uint") { set_2D_Input_uint(p_File); return 1; }
        if (p_Command == "set_3D_Input_uint") { set_3D_Input_uint(p_File); return 1; }
        if (p_Command == "load_Input") { load_Input(p_File); return 1; }
        if (p_Command == "load_Input_uint") { load_Input_uint(p_File); return 1; }
        
        if (p_Command == "chrono_Shift") { chrono_Shift(p_File); return 1; }
        if (p_Command == "add_Chrono") { add_Chrono(p_File); return 1; }

        if (p_Command == "round_Up_Input") { round_Up_Input(p_File); return 1; }
        if (p_Command == "pull_From_Lower_Connections") { pull_From_Lower_Connections(p_File); return 1; }
        if (p_Command == "pull_From_Lower_Connection") { pull_From_Lower_Connection(p_File); return 1; }
        if (p_Command == "pull_Chrono_From_Lower_Connection") { pull_Chrono_From_Lower_Connection(p_File); return 1; }

        //Construct manipulation
        if (p_Command == "register_Construct") { register_Construct(p_File); return 1; }
        if (p_Command == "create_Construct_Connection") { create_Construct_Connection(p_File); return 1; }
        if (p_Command == "output_Construct_Connections") { output_Construct_Connections(p_File); return 1; }
        if (p_Command == "pull_From_Upper_Index") { pull_From_Upper_Index(p_File); return 1; }

        //Saving and loading the whole thing.
        if (p_Command == "save") { save(p_File); return 1; }
        if (p_Command == "load") { load(p_File); return 1; }

        //Config
        if (p_Command == "save_Config") { save_Config(p_File); return 1; }
        if (p_Command == "update_Config") { update_Config(p_File); return 1; }

        if (p_Command == "set_Base_Charge") { set_Base_Charge(p_File); return 1; }
        if (p_Command == "set_Modifier_Charge") { set_Modifier_Charge(p_File); return 1; }
        if (p_Command == "set_Action_Potential_Threshold") { set_Action_Potential_Threshold(p_File); return 1; }
        if (p_Command == "set_Charging_Tier") { set_Charging_Tier(p_File); return 1; }

        //Node Manipulations
        if (p_Command == "bp_O") { bp_O(p_File); return 1; }

        //Evaluation
        if (p_Command == "query") { query(p_File); return 1; }

        //Network Encoding
        if (p_Command == "encode") { encode(p_File); return 1; }

        //File Output:
        if (p_Command == "clear_Output") { clear_Output(p_File); return 1; }
        if (p_Command == "write_Newline") { output_Newline(p_File); return 1; }
        if (p_Command == "write_Text"){ write_Text(p_File); return 1; }
        if (p_Command == "echo"){ echo(p_File); return 1; }

        //Network Output Gathering
        if (p_Command == "write_Given_Trace") { gather_Given_Trace(p_File); return 1; }
        if (p_Command == "write_Given_Trace_uint") { write_Given_Pattern_As_Number(p_File); return 1; }
        if (p_Command == "write_All_Traces") { gather_All_Traces(p_File); return 1; }
        if (p_Command == "write_All_Traces_uint") { gather_All_Traces_uint(p_File); return 1; }

        if (p_Command == "write_Node_Info") { gather_Given_Node(p_File); return 1; }
        if (p_Command == "write_Node_Info_As_Numbers") { gather_Given_Node_uint(p_File); return 1; }

        if (p_Command == "write_All_Nodes") { gather_All_Nodes(p_File); return 1; }
        if (p_Command == "write_All_Nodes_As_Numbers") { gather_All_Nodes_uint(p_File); return 1; }

        if (p_Command == "write_Output") { gather_Output(p_File); return 1; }
        if (p_Command == "write_Output_uint") { gather_Output_uint(p_File); return 1; }

        if (p_Command == "write_Treetop_Node") { gather_Treetop_Node(p_File); return 1; }
        if (p_Command == "write_Treetop_Node_Numbers") { gather_Treetop_Node_uint(p_File); return 1; }
        if (p_Command == "write_Treetop_NID_Only") { gather_Treetop_NID(p_File); return 1; }
        if (p_Command == "write_Treetop_NID") { get_Treetop_NID(p_File); return 1; }
        //if (p_Command == "write_Treetop_NID_To_Other_Input") { write_Treetop_NID_To_Other_Input(p_File); return 1; }

        //Console Output:
        if (p_Command == "output_Node_Raw") { output_Node_Raw(p_File); return 1; }
        if (p_Command == "output_Treetop_Node_Raw") { output_Treetop_Node_Raw(p_File); return 1; }
        if (p_Command == "output_Node_Network") { output_Node_Network(); return 1; }
        if (p_Command == "output_Node_Symbol") { output_Backpropagated_Symbol_NID(p_File); return 1; }
        if (p_Command == "output_Node_Symbol_uint") { output_Backpropagated_Symbol_NID_uint(p_File); return 1; }
        if (p_Command == "output_Symbols") { output_Backpropagated_Symbols(); return 1; }
        if (p_Command == "output_Input") { output_Input(p_File); return 1; }
        if (p_Command == "output_Input_uint") { output_Input_uint(p_File); return 1; }
        if (p_Command == "output_Output") { output_Output(p_File); return 1; }
        if (p_Command == "output_Output_uint") { output_Output_uint(p_File); return 1; }
        if (p_Command == "output_Scaffold_Char") { output_Scaffold_Char(p_File); return 1; }
        if (p_Command == "output_Scaffold_Symbols") { output_Scaffold_Symbols(p_File); return 1; }
        if (p_Command == "output_Scaffold_Symbols_uint") { output_Scaffold_Symbols_uint(p_File); return 1; }
        if (p_Command == "output_Node") { output_Node(p_File); return 1; }
        if (p_Command == "output_Constructs") { output_Constructs(); return 1; }

        //==--  Advanced Command List  --=//
        if (p_Command == "output_Node_Char") { output_Node_Char(p_File); return 1; }
        if (p_Command == "output_Scaffold") { output_Scaffold(p_File); return 1; }

        //Console Output:
        // 
        //Evaluation
        if (p_Command == "query_Spacial") { query_Spacial(p_File); return 1; }
        if (p_Command == "query_Given_Index") { query_Given_Index(p_File); return 1; }
        if (p_Command == "query_Given_Legs") { query_Given_Legs(p_File); return 1; }
        if (p_Command == "gather_Treetops") { gather_Treetops(p_File); return 1; }
        

        //Neural Network Construction and Initialization:
        if (p_Command == "set_State_Nodes_Index") { set_State_Nodes_Index(p_File); return 1; }

        //Node Manipulations
        if (p_Command == "set_Type") { set_Type(p_File); return 1; }
        if (p_Command == "add_Axon_Index") { add_Axon_Index(p_File); return 1; }
        if (p_Command == "set_Dendrites") { set_Dendrites(p_File); return 1; }
        if (p_Command == "does_Upper_Tier_Connection_Exist") { does_Upper_Tier_Connection_Exist(p_File); return 1; }
        if (p_Command == "does_Lower_Connection_Exist") { does_Lower_Connection_Exist(p_File); return 1; }
        if (p_Command == "bind_State") { bind_State(p_File); return 1; }

        //Network Manipulations
        if (p_Command == "get_Upper_Tier_Node") { get_Upper_Tier_Node(p_File); return 1; }
        if (p_Command == "does_State_Node_Exist") { does_State_Node_Exist(p_File); return 1; }
        if (p_Command == "get_State_Node") { get_State_Node(p_File); return 1; }
        if (p_Command == "does_Upper_Tier_Connection_Exist_Network") { does_Upper_Tier_Connection_Exist_Network(p_File); return 1; }
        if (p_Command == "new_Node") { new_Node(); return 1; }
        if (p_Command == "new_State_Node") { new_State_Node(p_File); return 1; }
        if (p_Command == "create_Connections") { create_Connections(p_File); return 1; }

        //Network Evaluation and Inference:
        if (p_Command == "submit_Set") { submit_Set(p_File); return 1; }

        //See if they submitted a command, these scripts are retrieved from the ./Scripts/ dir.
        std::string tmp_Command = "./Scripts/" + p_Command;
        interpret_File(tmp_Command);

        return 0;
    }


    // Load Control_Panel.ssc & issue commands
    int interpret_File(std::string p_LFName)
    {
        std::ifstream LF(p_LFName);

        std::string tmp_In = "";
        int tmp_Count = 0;

        if (LF.is_open())
        {
            while (!LF.eof())
            {
                tmp_In = "";

                LF >> tmp_In;

                if (tmp_In == "") { continue; }

                //std::cout << "\n - [ " << tmp_Count << " ]: " << tmp_In;
                tmp_Count++;


                int tmp_Result = 0;
                tmp_Result = eval_Command(tmp_In, &LF);
                
                if (tmp_Result == -1) { return -1; }
            }

            return 1;
        }
        else
        {
            
            return 0;
        }


        return 1;
    }


    //Control_Panel_Flag.ssv - Used to signal that there is a live message to read. Set by the user or an external program after inputs and controls are set and ready to have a function executed.
    int check_Control_Panel_Flag()
    {
        std::ifstream flagFile("Control_Panel_Flag.ssv");
        std::string flagValue = "";

        // Check if the flag file exists and can be opened
        if (flagFile.is_open())
        {
            flagFile >> flagValue;

            // Read the value from the flag file
            if (flagValue != "")
            {
                // Check if the value is 1
                if (flagValue == "1")
                {
                    flagFile.close();
                    return 1;
                }
                else
                {
                    flagFile.close();
                }
            }
            else
            {
                flagFile.close();
            }
        }
        else
        {
            std::cerr << "\nUnable to open flag file.\n";
        }

        return 0;
    }

    int execute_Control_Panel_Buffer()
    {

        int tmp_Result = 0;
        //tmp_Result = interpret_Control_Panel();
        tmp_Result = interpret_File("Control_Panel.ssv");

        if (tmp_Result)
        {
            std::ofstream clsFinishFlagFile("Control_Panel_Finished.ssv", std::ios::ate);

            // Check if the flag file exists and can be opened
            if (clsFinishFlagFile.is_open())
            {
                clsFinishFlagFile << "1";
            }

            clsFinishFlagFile.close();

        }

        if (tmp_Result == 0)
        {
            std::cerr << "\n\n   ERROR: Unable to interpret the control panel file...  \n";

            return 0;
        }

        if (tmp_Result == -1)
        {
            std::ofstream clsFinishFlagFile("Control_Panel_Finished.ssv", std::ios::ate);

            // Check if the flag file exists and can be opened
            if (clsFinishFlagFile.is_open())
            {
                clsFinishFlagFile << "1";
            }

            clsFinishFlagFile.close();

            return -1;
        }


        std::ofstream file_Object("Control_Panel_Flag.ssv", std::ios::ate);

        //Make sure the file was opened.
        if (!file_Object.is_open())
        {
            std::cerr << "\n\n   ERROR: Unable to interpret the file_Object file for truncation!...  \n";
        }

        file_Object.close();

        return 1;
    }


    int view_File(std::string p_FileName)
    {
        std::ifstream InputFile(p_FileName);

        std::string tmp_In = "";
        int tmp_Count = 0;

        if (InputFile.is_open())
        {
            while (!InputFile.eof())
            {
                InputFile >> tmp_In;
                std::cout << "\n - [ " << tmp_Count << " ]: " << tmp_In;
                tmp_Count++;

                //Neuralman.output_Input();
            }

            std::cout << "\n " << p_FileName << " loaded successfully.\n";

            return 1;
        }
        else
        {
            std::cerr << "\n Unable to open " << p_FileName << " ...\n";

            return 0;
        }
    }

public:

    //The default of the ../ is so that is navigates up from the scripts folder when finding boot status. It's so dumb I find it funny so now this engine's default autoexec file is "./scripts/../autoexec.ssv" lmao. If it doesn't work on other systems I'll have to change it but on windows it works (o.O)
    c_Construct_Text_Server(std::string p_Autoexec = "../autoexec.ssv")
    {
        Tick = 0;
        flg_Exit = false;

        std::cout << "\n\n   (~.~) BOOTING UP  ";
        //See if they submitted a command, these scripts are retrieved from the ./Scripts/ dir.
        std::string tmp_Autoexec_FName = "./Scripts/" + p_Autoexec;
        std::cout << "\n\n   (o.o) LOADING BOOT FILE " << tmp_Autoexec_FName << "  \n\n";

        int tmp_Boot_Status = interpret_File(tmp_Autoexec_FName);

        //Load the boot sequence 
        if (tmp_Boot_Status)
        {
            std::cout << "\n\n   \\(^-^)/ SUCCESSFULLLY BOOTED  \n\n";
        }
        else
        {
            std::cout << "\n\n   (;_;) < FAILED TO BOOT PROPERLY  \n\n";
        }

        if (tmp_Boot_Status == -1) { flg_Exit = true; }
    }


    void save_Config(std::ifstream * p_File)
    {
        std::cout << "\n --> save_Config CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        API.save_Config(tmp_Construct);
    }

    void update_Config(std::ifstream* p_File)
    {
        std::cout << "\n --> update_Config CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        API.update_Config(tmp_Construct);
    }

    //Hyperparams
    void set_Base_Charge(std::ifstream* p_File)
    {
        std::cout << "\n --> set_Base_Charge |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        float tmp_Base_Charge = 0.0;

        *p_File >> tmp_Base_Charge;

        API.set_Base_Charge(tmp_Construct, tmp_Base_Charge);
    }

    void set_Modifier_Charge(std::ifstream* p_File)
    {
        std::cout << "\n --> set_Modifier_Charge |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        float tmp_Modifier_Charge = 0.0;

        *p_File >> tmp_Modifier_Charge;

        API.set_Modifier_Charge(tmp_Construct, tmp_Modifier_Charge);
    }

    void set_Action_Potential_Threshold(std::ifstream* p_File)
    {
        std::cout << "\n --> set_Action_Potential_Threshold |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        float tmp_Action_Potential_Threshold = 0.0;

        *p_File >> tmp_Action_Potential_Threshold;

        API.set_Action_Potential_Threshold(tmp_Construct, tmp_Action_Potential_Threshold);
    }

    void set_Charging_Tier(std::ifstream* p_File)
    {
        std::cout << "\n --> set_Charging_Tier |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        int  tmp_Charging_Tier = 0;

        *p_File >> tmp_Charging_Tier;

        API.set_Charging_Tier(tmp_Construct, tmp_Charging_Tier);
    }

    //        ---==================---
    //       ---====================---
    //      ---======================---
    //     ---========================---
    //    ---==   NT4 Deep Control   ==---
    //     ---========================---
    //      ---======================---
    //       ---====================---
    //        ---==================---

    void create_Construct_Connection(std::ifstream* p_File)
    {
        std::cout << "\n --> create_Construct_Connection |";

        std::string tmp_Construct_From = "";

        *p_File >> tmp_Construct_From;

        std::cout << " " << tmp_Construct_From << " |";
        
        std::string tmp_Construct_To = "";

        *p_File >> tmp_Construct_To;

        std::cout << " " << tmp_Construct_To << " |";

        API.create_Construct_Connection(tmp_Construct_From, tmp_Construct_To);
    }

    void output_Construct_Connections(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Construct_Connections |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        API.output_Construct_Connections(tmp_Construct);
    }

    //Used for encoding.
    void round_Up_Input(std::ifstream* p_File)
    {
        std::cout << "\n --> round_Up_Input |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        API.round_Up_Input(tmp_Construct);
    }

    void pull_From_Lower_Connection(std::ifstream* p_File)
    {
        std::cout << "\n --> pull_From_Lower_Connection |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        int tmp_Lower_Connection = 0;

        *p_File >> tmp_Lower_Connection;

        API.pull_From_Lower_Connection(tmp_Construct, tmp_Lower_Connection);
    }
    

    void pull_Chrono_From_Lower_Connection(std::ifstream* p_File)
    {
        std::cout << "\n --> pull_Chrono_From_Lower_Connection |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        API.pull_Chrono_From_Lower_Connection(tmp_Construct);
    }

    //Used for eval, pulls the output from lower to upper.
    void pull_From_Lower_Connections(std::ifstream* p_File)
    {
        std::cout << "\n --> pull_From_Lower_Connections |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        API.pull_From_Lower_Connections(tmp_Construct);
    }

    void pull_From_Upper_Index(std::ifstream* p_File)
    {
        std::cout << "\n --> pull_From_Upper_Index |";

        std::string tmp_Construct_To = "";

        *p_File >> tmp_Construct_To;

        std::string tmp_Construct_From = "";

        *p_File >> tmp_Construct_From;

        int tmp_Index = 0;

        *p_File >> tmp_Index;

        API.pull_From_Upper_Index(tmp_Construct_To, tmp_Construct_From, tmp_Index);
    }

    //      ---==========---
    //     ---============---
    //    ---==   Node   ==--- 
    //     ---============---
    //      ---==========---

    /** Sets the type of a given node.

        set_Type NID TYPE
    \param uint64_t NID The Node ID (NID) of the node being manipulated.
    \param uint64_t TYPE The type you are assigning the node to: (0: State), (1: Branch), (2: Treetop), (3: State/Treetop)
    \retval None This function doesn't return any values.

    This type is used for determining how to handle the node. You may want to set one to a treetop that way you can then write a charging function that has a different behavior for treetop nodes.

    Example Usage:

    Setting the type of node 66 to the value of 2 flagging it as a treetop node. Before and after setting the type we use output_Node_Raw to view the results. This assumes node 66 has two dendrites { 7, 14 }.

        output_Node_Raw 66
        set_Type 66 2
        output_Node_Raw 66

    Output:

        Node_ID (NID) 66 RC: 1 Type: 0  State { 0 } --- Dendrites:  [7]  [14]  --- Axon_Hillock_Count: 0
        Node_ID (NID) 66 RC: 1 Type: 2  State { 0 } --- Dendrites:  [7]  [14]  --- Axon_Hillock_Count: 0

    Error Handling:

    - No error handling is implemented in this function. 

    Additional Notes:

    - Calling this function with an invalid node will cause a crash. 
    - You can set the type to any value you want, this allows for extending functionality, but can cause a crash if you set it to an invalid type and the node is mishandled.
    */
    void set_Type(std::ifstream* p_File)
    {
        std::cout << "\n --> set_Type NID TYPE |";

        int tmp_NID = 0;

        *p_File >> tmp_NID;

        int tmp_Type = 0;

        *p_File >> tmp_Type;

        API.set_Type(tmp_NID, tmp_Type);

        //std::cout << " [|x|]";
    }



    /** Adds a given NID to an Axon on the given Hillock. Note this is selecting a hillock not assigning an axonal ID, if the index doesn't exist then exist it with resize_Axon_Hillocks()

        add_axon_index NID Axon_NID HILLOCK_INDEX
    \param uint64_t NID The Node ID (NID) of the node being manipulated.
    \param uint64_t AXON_NID The NID of the node that the axon will reference.
    \param int INDEX The hillock the axon is put onto, not the axon ID.
    \retval None This function doesn't return any values.

    The nodes keep track of which dendrite their upper connections are connected to by encoding them into respective "axon hillocks". Basically we take whichever dendrite index the connection is connected to and create an axonic group that represents those connections to legs of that index. This allows for advanced search of the networks including time-series and more.

    Example Usage:

    Adding an axonic connection to node 42 on axon hillock 5 of node 16 to represent that it is Dendrite[5] on the node above. We will use output_Node_Raw after setting the axon to show the result. This assumes no previous axonic connections or dendrites and it is a quanta bound state node with the state set to the uint64_t value 99.

        output_Node_Raw 16
        add_Axon_Index 16 42 5
        output_Node_Raw 16

    Output:

        Node_ID (NID) 16 RC: 1 Type: 0  State { 99 } --- Dendrites:  --- Axon_Hillock_Count: 0
        Node_ID (NID) 16 RC: 1 Type: 0  State { 99 } --- Dendrites:  --- Axon_Hillock_Count: 6  Axons[0] <0>:  Axons[1] <0>:  Axons[2] <0>:  Axons[3] <0>:  Axons[4] <0>:  Axons[5] <1>: [0] 42

    Error Handling:

    - No error handling is implemented in this function. 

    Additional Notes:

    - Calling this function with an invalid node will cause a crash. 
    - Invalid axon IDs will not cause an immediate crash, but any function which touches the axons will crash when attemting to reference the invalid axon NIDs.
    */
    void add_Axon_Index(std::ifstream* p_File)
    {
        std::cout << "\n --> add_axon_index NID Axon_NID HILLOCK_INDEX |";

        uint64_t tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";

        uint64_t tmp_Axon_NID = 0;

        *p_File >> tmp_Axon_NID;

        std::cout << " " << tmp_Axon_NID << " |";

        int tmp_Index = 0;

        *p_File >> tmp_Index;

        std::cout << " " << tmp_Index << " |";

        API.add_Axon_Index(tmp_NID, tmp_Axon_NID, tmp_Index);

        //std::cout << " [|x|]";
    }



    /** Sets the dendrites of the node.

        set_Dendrites NID COUNT DENDRITE_IDS 
    \param uint64_t NID The Node ID of the node being manipulated.
    \param int COUNT The number of dendrites in the array DENDRITE_IDS 
    \param uint64_t DENDRITE_IDS  An array of NIDs that represent the dendritic connections.
    \retval None This function doesn't return any values.

    The choice of encoding method will determine dendrite count. This is left with a dynamic leg count though so that bespoke networks can be created with ease. It is dangerous, but that is up to the user to handle.

    Example Usage:

    Setting the dendrites of imaginary node 43 to NIDs 2 & 3 representing the connections to "lower" tier nodes making up the sub-symbols of the current node's represented pattern. Before and after setting them we output the node. This assumes no axonic connections.
        
        output_Node_Raw 43
        set_Dendrites 43 2 2 3
        output_Node_Raw 43

    Output:

        Node_ID (NID) 43 RC: 1 Type: 2  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
        Node_ID (NID) 43 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 2 [1] 3 --- Axon_Hillock_Count: 0

    Error Handling:

    - No error handling is implemented in this function. 

    Additional Notes:

    - This assumes the node has no dendrites yet, if it does you be dangling and jangling.
    - Calling this function with an invalid node will cause a crash. 
    - Calling it and assigning dendrites invalid NID IDs will cause a crash when bp_O, create_Connection, does_Lower_Ter_Connection_Exist, or any other operation which touches the dendrites.
    */
    void set_Dendrites(std::ifstream* p_File)
    {
        std::cout << "\n --> set_Dendrites NID COUNT DENDRITES  |";

        uint64_t tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";

        int tmp_Count = 0;

        *p_File >> tmp_Count;

        std::cout << " " << tmp_Count << " |";

        uint64_t * tmp_Dendrites = NULL;
        tmp_Dendrites = new uint64_t [tmp_Count];

        for (int cou_Index = 0; cou_Index < tmp_Count; cou_Index++)
        {
            *p_File >> tmp_Dendrites[cou_Index];

            std::cout << " " << tmp_Dendrites[cou_Index] << " |";
        }

        API.set_Dendrites(tmp_NID, tmp_Count, tmp_Dendrites);

        if (tmp_Dendrites != NULL) { delete [] tmp_Dendrites; tmp_Dendrites = NULL; }

        //std::cout << " [|x|]";
    }


    /** Searches the axons to see if an upper tier connection exists, if found returns the NID, if not returns 0.

        does_Upper_Tier_Connection_Exist NODE_COUNT NODES 
    \param int NODE_COUNT The number of nodes to use in the check for an upper tier node symbol.
    \param uint64_t NODES  The array of NIDs to look for.
    \retval uint64_t NID This function return the NID of a node matching the description, returns 0 if none are found.

    This is used during encoding and performing a query. It traverses the connections in the given NID's first axon hillock. For each of these connections it does a does_Lower_Connection_Exist to see if that node matches. By searching the first legs we keep the search limited to only those with the possiblity to match the search string of connections. We know this is the case because if the first node in a string of nodes has an upper tier connection then that gives us a connection to a node that at least shares index[0] with our current lower-tier node and by checking every other dendrite index of the upper tier node against the respective index in the passed node array we can know for sure if our current pattern exists yet. After checking all of the upper tier connections on axon hillock 0 if we come up with no confirmed connections we know that the current arrangement of nodes hasn't been encoded into a higher tier node symbol yet.

    Example Usage:

    We will use the example containing a set of nodes { 5 6 7 }, node 5 has 2 axonic connections with the second having the correct configuration of legs meaning we found it. This second node has the NID 75, we know node 75 has the correct connection so we output it manually to show the node data.

        output_Raw_Node 75
        does_Upper_Tier_Connection_Exist 3 5 6 7

    Output:

        Node_ID (NID) 75 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 5 [1] 6 [2] 7 --- Axon_Hillock_Count: 0

    Contents of the RETURN_FILE:
    
        75

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - Calling this function with an invalid node will cause a crash.
    */
    uint64_t does_Upper_Tier_Connection_Exist(std::ifstream* p_File)
    {
        std::cout << "\n --> does_Upper_Tier_Connection_Exist NODE_COUNT NODES  |";

        uint64_t tmp_Return_NID = 0;

        int tmp_Count = 0;

        *p_File >> tmp_Count;

        std::cout << " " << tmp_Count << " |";

        uint64_t* tmp_Nodes = NULL;
        tmp_Nodes = new uint64_t[tmp_Count];

        for (int cou_Index = 0; cou_Index < tmp_Count; cou_Index++)
        {
            *p_File >> tmp_Nodes[cou_Index];

            std::cout << " " << tmp_Nodes[cou_Index] << " |";
        }

        tmp_Return_NID = API.does_Upper_Tier_Connection_Exist(tmp_Count, tmp_Nodes);

        if (tmp_Nodes != NULL) { delete [] tmp_Nodes; tmp_Nodes = NULL; }

        write_to_output(RETURN_FILE, tmp_Return_NID);

        return tmp_Return_NID;

        //std::cout << " [|x|]";
    }


    /** Checks if the given node has dendrites that match the given nodes in the given order.

        does_Lower_Connection_Exist NID NODE_COUNT NODES 
    \param uint64_t NID The Node ID of the node being manipulated.
    \param uint64_t NODE_COUNT The number of nodes to use in the check for an upper tier node symbol.
    \param uint64_t NODES  The array of NIDs to look for.
    \retval bool This function returns a 1 (true) or 0 (false) depending on whether the dendrites match the given nodes or not.

    This takes a given node and a set of node IDs (NIDs) to check. It checks each dendrite leg against the given node list to see if they all match or not. If one is found that doesn't match it return 0 immediately. Used during encoding to find out whether a compound higher tier symbol has been encoded yet.

    Example Usage:

    We will check node 75 which has the dendrites { 5, 6, 7 } to see if it matches the given dendrite set { 5, 6, 8 }, which we know it does not. Then we will output a newline in the output file and check node 76 which in this example has the dendrites { 5, 6, 8 } which match the given set outputting 1 to the RETURN_FILE. Before checking each node we'll output it to show the dendrites so you can see them yourself.

        output_Node_Raw 75
        does_Lower_Connection_Exist 75 3 5 6 8
        newline returns
        output_Node_Raw 76
        does_Lower_Connection_Exist 76 3 5 6 8

    Output:
    
        Node_ID (NID) 75 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 5 [1] 6 [2] 7 --- Axon_Hillock_Count: 0
        Node_ID (NID) 76 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 5 [1] 6 [2] 8 --- Axon_Hillock_Count: 0

    Contents of the RETURN_FILE:

        0
        1

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - Calling this function with an invalid node will cause a crash.
    - If the given node count exceeds the dendrite count you will cause it to crash. This is due to the function assuming the count will not exceed the number of defined dendrites and iterates trustfully through it. This is by design as this function will be called many often and is a potential bottleneck.
    */
    bool does_Lower_Connection_Exist(std::ifstream* p_File)
    {
        std::cout << "\n --> does_Lower_Connection_Exist NID NODE_COUNT NODES  |";

        bool tmp_Return_Result = 0;

        uint64_t tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";

        int tmp_Count = 0;

        *p_File >> tmp_Count;

        std::cout << " " << tmp_Count << " |";

        uint64_t* tmp_Nodes = NULL;
        tmp_Nodes = new uint64_t[tmp_Count];

        for (int cou_Index = 0; cou_Index < tmp_Count; cou_Index++)
        {
            *p_File >> tmp_Nodes[cou_Index];

            std::cout << " " << tmp_Nodes[cou_Index] << " |";
        }

        tmp_Return_Result = API.does_Lower_Connection_Exist(tmp_NID, tmp_Count, tmp_Nodes);

        if (tmp_Nodes != NULL) { delete [] tmp_Nodes; tmp_Nodes = NULL; }

        write_to_output(RETURN_FILE, tmp_Return_Result);

        return tmp_Return_Result;

        //std::cout << " [|x|]";
    }



    /** Binds a node to a quanta of data, the state of the input, as uint64_t.

        bind_State NID STATE
    \param uint64_t NID The Node ID of the node being manipulated.
    \param uint64_t NID The state of the input, the current quanta, or element, of information being encoded.
    \retval None This function doesn't return any values.

    At the interface between the networks internal node structure and the exterior information space exists the state tier, this is the interface where outside information binds to nodes to allow for communication coherently across the internal/external space. Outside you have the information to be encoded, this information is composed of differentiated information, the smallest piece of coherent information that the abstractions are built upon is the quanta. This quanta is a pixel, a character, an integer, a scalar value. A quantifiable and discrete piece of information which forms the basis of the patterns of information you will be encoding/decoding from the neural matrix. This doesn't have to be low level abstraction wise, only that is has a hash or scalar abstraction that can be cast to uint64. It could represent the hash of a full 3D body scan as easily as a scalar value from a thermal sensor.
    
    This function binds the state to the node to form the interface, an absolutely crucial function to the distributed symbol neural networks.

    Example Usage:

    We will bind the uint state 1234321 to node 10, outputting the node before and after the operation using 'output_Node_Raw 10'.

        output_Node_Raw 10
        bind_State 10 1234321
        output_Node_Raw 10

    Output:

        Node_ID (NID) 10 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
        Node_ID (NID) 10 RC: 1 Type: 0  State { 1234321 } --- Dendrites:  --- Axon_Hillock_Count: 0

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - Calling this function with an invalid node will cause a crash.
    */
    void bind_State(std::ifstream* p_File)
    {
        std::cout << "\n __COMMAND__| bind_State NID STATE |";

        uint64_t tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";
        
        uint64_t tmp_State = 0;

        *p_File >> tmp_State;

        std::cout << " " << tmp_State << " |";

        API.bind_State(tmp_NID, tmp_State);

        //std::cout << " [|x|]";
    }



    /** Initiates a backpropagation (feedbackward info cascade ! weight adjustment) that outputs the pattern represented by this node.

        bp_O NID
    \param uint64_t NID The Node ID of the node who's information symbol is being output.
    \retval None This function doesn't return any values.

    The patterns that are encoded, the traces, are encoded in a deterministic and hierarchical manner. This allows us the oppurtunity to craft algorithms to "walk" the structure down and retrieve the original input pattern stored in the relationships of the nodes on the various tiers, or layers, or abstraction.

    This function outputs the full symbol represented by the node given. It walks the tree to output the pattern perfectly as it was originally encoded.

    Example Usage:

    In this example we have encoded the pattern "64 128 256" into a many to one construct. In this example the nodes 1-9 have already been created so our first node will be NID 10. This results in 4 nodes created, 3 state tier nodes { 10, 11, 12 } and 1 upper tier treetop node { 13 }. We will output all the nodes, then demonstrate the bp_O.

        output_Node_Raw 10
        output_Node_Raw 11
        output_Node_Raw 12
        output_Node_Raw 13
        bp_O 13

    Output:

        Node_ID (NID) 10 RC: 1 Type: 0  State { 64 } --- Dendrites:  --- Axon_Hillock_Count: 1  Axons[0] <1>: 13
        Node_ID (NID) 11 RC: 1 Type: 0  State { 128 } --- Dendrites:  --- Axon_Hillock_Count: 2  Axons[0] <0>:  Axons[1] <1>: 13
        Node_ID (NID) 12 RC: 1 Type: 0  State { 256 } --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] <0>:  Axons[1] <0>:  Axons[2] <1>: 13
        Node_ID (NID) 13 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 10 [1] 11 [2] 12 --- Axon_Hillock_Count: 0
        <=- 13 * [double(64), 64]  [double(128), 128]  [double(256), 256] -=>

    - Note that the 'double(n)' in the real output is the actual cast value and not the typecast definition.

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - Calling this function with an invalid node will cause a crash.
    - If you crash when calling this and the node is valid then check your dendrites.
    */
    void bp_O(std::ifstream* p_File)
    {
        std::cout << "\n __COMMAND__| bp_O NID |";

        uint64_t tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";

        API.bp_O(tmp_NID);

        //std::cout << " [|x|]";
    }



    /** Outputs the ugly raw info dump for the node.

        output_Node_Raw NID
    \param uint64_t NID The Node ID of the node who's information symbol is being output.
    \retval None This function doesn't return any values.

    This is pretty basic, outputs the node.

    Here is the breakdown of the components output:

    -Entire output node raw dump:

        Node_ID (NID): %NID% RC: %RC% Type: %Type% State { %State% } --- Dendrites: [%Dendrite_ID%] %Dendrites[%Dendrite_ID%]% --- Axon_Hillock_Count: %Axon_Hillock_Count% Axons[%Axon_Hillock_ID%] <%Axon_Count_For_Hillock%>: [%Axon_ID%] Axons[%Axon_Hillock_ID%][%Axon_ID%]

    - The NID is the node ID within the network of nodes.

        Node_ID (NID): %NID% 

    - The RC is the reinforcement counter, the reinforcement value, the neuroplasticity analogue, the post-synaptic-cleft density approximation.

        RC: %RC% 

    - The type of node, see set_Node_Type for more information.

        Type: %Type% 

    - The pattern of input quanta that the node represents, the hierarchically encoded sensory trace, the abstract symbol built from the recomposition of the input states into the complete encoded pattern.

        State { %State% } 

    - The "lower" connections to nodes that form sub-symbols of the current node's symbol.

        Dendrites: [%Dendrite_ID%] %Dendrites[%Dendrite_ID%]% 

    - The number of axon hillocks on this node, the number of axonal hillocks is determined by the position of upper tier connections. If an upper tier axonic connection makes contact with dendritic index 4 then this lower node will have 5 axon hillocks so that number 4 can hold this connection preserving the information of the upper tier connection index without having to query the other node to get the respective position. This is used during the function which check for upper tier nodes and during some charging methodologies.

        Axon_Hillock_Count: %Axon_Hillock_Count% 
        
    - If the node contains axonic connections they will be iteratively printed here. For each hillock the number of axons on it will be printed followed by the individual axonic connections.

        Axons[%Axon_Hillock_ID%] <%Axon_Count_For_Hillock%>: [%Axon_ID%] Axons[%Axon_Hillock_ID%][%Axon_ID%]


    Example Usage:

    In this example we have encoded the pattern "64 128 256" into a many to one construct. In this example the nodes 1-9 have already been created so our first node will be NID 10. This results in 4 nodes created, 3 state tier nodes { 10, 11, 12 } and 1 upper tier treetop node { 13 }. We will output all the nodes using this function to show state, treetop, dendritically connected, and axonically connected nodes..

        output_Node_Raw 10
        output_Node_Raw 11
        output_Node_Raw 12
        output_Node_Raw 13

    Output:

        Node_ID (NID) 10 RC: 1 Type: 0  State { 64 } --- Dendrites:  --- Axon_Hillock_Count: 1  Axons[0] <1>: 13
        Node_ID (NID) 11 RC: 1 Type: 0  State { 128 } --- Dendrites:  --- Axon_Hillock_Count: 2  Axons[0] <0>:  Axons[1] <1>: 13
        Node_ID (NID) 12 RC: 1 Type: 0  State { 256 } --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] <0>:  Axons[1] <0>:  Axons[2] <1>: 13
        Node_ID (NID) 13 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 10 [1] 11 [2] 12 --- Axon_Hillock_Count: 0

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - Calling this function with an invalid node will cause a crash.
    */
    void output_Node_Raw(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Node_Raw NID |";

        uint64_t tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";

        API.output_Node_Raw(tmp_NID);

        //std::cout << " [|x|]";
    }



    void output_Treetop_Node_Raw(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Treetop_Node_Raw CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.output_Treetop_Node_Raw(tmp_Construct);

        //std::cout << " [|x|]";
    }



    /** Casts the node address to char() and outputs it.

        output_Node_Char NID
    \param uint64_t NID The Node ID of the node who's NID is being output as a char.
    \retval None This function doesn't return any values.

    This function may seem pointless at first, but it is used in conjunction with the CAN scaffolds and others to output a compact visualizatin of a series of nodes by their NID. Though there is overlap when typecasting NIDs the variation is enough that the human can see differences in different permutations of encoded input.

    Example Usage:
    
    In this example we have encoded the pattern "64 128 256" into a many to one construct. In this example the nodes 0 - 175 have already been created so our first node will be NID 176. The node bound to state 128 already exists with a NID 65. This results in 3 nodes created, 2 state tier nodes { 176, 177 } and 1 upper tier treetop node { 178 }. We will output all the nodes using this function to show a small example of the potential output used to convey variance int he NID structure at a glance.

        output_Node_Char 176
        output_Node_Char 65
        output_Node_Char 177
        output_Node_Char 178

    Output:

        A

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - Calling this function with an invalid node will cause a crash.
    */
    void output_Node_Char(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Node_Char NID |";

        uint64_t tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";

        API.output_Node_Char(tmp_NID);

        //std::cout << " [|x|]";
    }





    //    ---==================---
    //   ---====================---
    //  ---==   Node_Network   ==---
    //   ---====================---
    //    ---==================---
  
	/** Used to differentiate a new construct, allocates a state tree to handle a state-node space.


    /** Creates a new node in the shared node network.

        new_Node
    \retval uint64_t This returns the NID of the newly created nodes.

    When the node is created it is stored in a linked list. This new node is then added to the node registration fractal tree. This allows for storing the node network in a linked list for when we want to iterate over them, and for searching with a predictable search time for nodes in the linked list no matter its length.

    Example Usage:

    In this example we register a new node using new_Node and then check the output file for the NID of the newly created node. Currently the node network is at 249 nodes meaning the new one will have a NID of 250.

        new_Node

    Output:

    Contents of the RETURN_FILE:

        250

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    uint64_t new_Node()
    {
        std::cout << "\n --> new_Node |";

        uint64_t tmp_Return_NID = API.new_Node();

        write_to_output(RETURN_FILE, tmp_Return_NID);

        return tmp_Return_NID;

        //std::cout << " [|x|]";
    }


    /** Creates a new node, binds it to a state, sets the type to 0 or 3 depending, and adds the node to the state tree with the state registered. 

        new_State_Node CONSTRUCT_ID STATE
    \param uint64_t CONSTRUCT_ID This is the Construct to use when creating the state node.
    \param uint64_t STATE The state to bind to the node.
    \retval uint64_t Returns the NID of the newly minted state node.

    By registering the node with the fractal state tree we can have predictable search times no matter how big the tree gets. 

    Example Usage:

    In this example we have 3 constructs registered and we use 'new_State_Node 2 121' to create a state node for construct [2], in this example construct [2] currently has 28 nodes registered making the return value 29 as that is the new nodes NID.

        new_State_Node 2 121

    Output:

    Contents of the RETURN_FILE:

        29

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - Assumes the construct is already registered with a valid index.
    */
    uint64_t new_State_Node(std::ifstream* p_File)
    {
        std::cout << "\n --> new_State_Node CONSTRUCT_ID STATE |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";
        
        uint64_t tmp_State = 0;

        *p_File >> tmp_State;

        std::cout << " " << tmp_State << " |";

        uint64_t tmp_Return_NID = API.new_State_Node(tmp_Construct, tmp_State);

        write_to_output(RETURN_FILE, tmp_Return_NID);

        return tmp_Return_NID;

        //std::cout << " [|x|]";
    }


    /** Creates a connection between nodes.

        create_Connections TO_NID COUNT FROM_NIDS 
    \param uint64_t TO_NID This is the node that all the lower nodes connect to, the one that receives the dendritic connections.
    \param uint64_t NODE_COUNT The number of nodes to connect to the upper tier node.
    \param uint64_t NODES  The array of node NIDs that are the lower nodes, they receive the axonic connections.
    \retval None This function doesn't return any values.

    p_To forms dendritic connections to p_From, and on p_From you have the axonic connections. This function uses set_Dendrites on the upper tier node and sets the axon for the lower nodes to create the two way connection. The doubly linked tiered nodes.

    Example Usage:

    In this example we have an upper tier node we created with the NID 100, and 5 lower nodes with NIDs { 10, 20, 30, 40, 50 }. We assume no nodes have any connections as of yet. We will be outputting the nodes before and after.

        output_Node_Raw 10
        output_Node_Raw 20
        output_Node_Raw 30
        output_Node_Raw 40 
        output_Node_Raw 50
        output_Node_Raw 100

        create_Connections 100 5 10 20 30 40 50

        output_Node_Raw 10
        output_Node_Raw 20
        output_Node_Raw 30
        output_Node_Raw 40
        output_Node_Raw 50
        output_Node_Raw 100

    Output:

        Node_ID (NID) 10 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
        Node_ID (NID) 20 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
        Node_ID (NID) 30 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
        Node_ID (NID) 40 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
        Node_ID (NID) 50 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
        Node_ID (NID) 100 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0

        Node_ID (NID) 10 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 1  Axons[0] <1>: 100
        Node_ID (NID) 20 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 2  Axons[0] <0>:  Axons[1] <1>: 100
        Node_ID (NID) 30 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] <0>:  Axons[1] <0>:  Axons[2] <1>: 100
        Node_ID (NID) 40 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] <0>:  Axons[1] <0>:  Axons[2] <0>:   Axons[2] <1>: 100
        Node_ID (NID) 50 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] <0>:  Axons[1] <0>:  Axons[2] <0>:   Axons[2] <0>:   Axons[2] <1>: 100
        Node_ID (NID) 100 RC: 1 Type: 0  State { 0 } --- Dendrites: [0] 10 [1] 20 [2] 30 [3] 40 [4] 50  --- Axon_Hillock_Count: 0
        

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - This does nothing for setting or binding states, or setting node types, this function is purely to create these connections.
    - Passing invalid nodes will cause it to crash when it tries to call the NULL object to create either dendrite or axon connections.
    */
    void create_Connections(std::ifstream* p_File)
    {
        std::cout << "\n --> create_Connections TO_NID COUNT FROM_NIDS  |";

        uint64_t tmp_To_NID = 0;

        *p_File >> tmp_To_NID;

        std::cout << " " << tmp_To_NID << " |";

        int tmp_Count = 0;

        *p_File >> tmp_Count;

        std::cout << " " << tmp_Count << " |";

        uint64_t* tmp_Nodes = NULL;
        tmp_Nodes = new uint64_t[tmp_Count];

        for (int cou_Index = 0; cou_Index < tmp_Count; cou_Index++)
        {
            *p_File >> tmp_Nodes[cou_Index];

            std::cout << " " << tmp_Nodes[cou_Index] << " |";
        }

        API.create_Connections(tmp_To_NID, tmp_Count, tmp_Nodes);

        if (tmp_Nodes != NULL) { delete [] tmp_Nodes; tmp_Nodes = NULL; }

        //std::cout << " [|x|]";
    }


    /** Checks if an upper tier node exists, functionally the same as does_Upper_Tier_Connection_Exist on the node, but this includes error handling.

        does_Upper_Tier_Connection_Exist_Network NODE_COUNT NODES 
    \param int NODE_COUNT The number of nodes to use in the check for an upper tier node symbol.
    \param uint64_t NODES  The array of NIDs to look for.
    \retval uint64_t NID This function return the NID of a node matching the description, returns 0 if none are found.

    This is used during encoding and performing a query. It traverses the connections in the given NID's first axon hillock. For each of these connections it does a does_Lower_Connection_Exist to see if that node matches. By searching the first legs we keep the search limited to only those with the possiblity to match the search string of connections. We know this is the case because if the first node in a string of nodes has an upper tier connection then that gives us a connection to a node that at least shares index[0] with our current lower-tier node and by checking every other dendrite index of the upper tier node against the respective index in the passed node array we can know for sure if our current pattern exists yet. After checking all of the upper tier connections on axon hillock 0 if we come up with no confirmed connections we know that the current arrangement of nodes hasn't been encoded into a higher tier node symbol yet.

    Example Usage:

    We will use the example containing a set of nodes { 5 6 7 }, node 5 has 2 axonic connections with the second having the correct configuration of legs meaning we found it. This second node has the NID 75, we know node 75 has the correct connection so we output it manually to show the node data.

        output_Raw_Node 75
        does_Upper_Tier_Connection_Exist_Network 3 5 6 7

    Output:

        Node_ID (NID) 75 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 5 [1] 6 [2] 7 --- Axon_Hillock_Count: 0

    Contents of the RETURN_FILE:
    
        75

    Error Handling:

    - This function makes sure that the first node on the submitted node set is not NULL before calling does_Upper_Tier_Connection_Exist. This command is safer than the direct node 'does_Upper_Tier_Connection_Exist'.

    Additional Notes:

    - None
    */
    uint64_t does_Upper_Tier_Connection_Exist_Network(std::ifstream* p_File)
    {
        std::cout << "\n --> does_Upper_Tier_Connection_Exist_Network NODE_COUNT NODES  |";

        uint64_t tmp_Return_NID = 0;

        uint64_t tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";

        int tmp_Count = 0;

        *p_File >> tmp_Count;

        std::cout << " " << tmp_Count << " |";

        uint64_t* tmp_Nodes = NULL;
        tmp_Nodes = new uint64_t[tmp_Count];

        for (int cou_Index = 0; cou_Index < tmp_Count; cou_Index++)
        {
            *p_File >> tmp_Nodes[cou_Index];

            std::cout << " " << tmp_Nodes[cou_Index] << " |";
        }

        tmp_Return_NID = API.does_Upper_Tier_Connection_Exist_Network(tmp_Count, tmp_Nodes);

        if (tmp_Nodes != NULL) { delete [] tmp_Nodes; tmp_Nodes = NULL; }

        write_to_output(RETURN_FILE, tmp_Return_NID);

        return tmp_Return_NID;

        //std::cout << " [|x|]";
    }


    /** Gets an upper tier node based on the given legs, will create it if not found.

        get_Upper_Tier_Node NODE_COUNT NODES 
    \param int NODE_COUNT The number of nodes to use in the check for an upper tier node symbol.
    \param uint64_t NODES  The array of NIDs to look for.
    \retval uint64_t NID The node that represents the symbol containing the lower nodes passed to this function. Passes the NID back whether found or newly minted.

    This function uses 'does_Upper_Tier_Node_Exist' to find if the node exists or not. If the node is not found then this function creates the node, assigns the connections, and passes the prepared NID back.

    Example Usage:

    We will use the example containing a set of nodes { 5 6 7 }, in our example node 75 matches this configuration. We output it manually to show the node data proving this and we show the returned NID in the returned data file.

        output_Raw_Node 75
        get_Upper_Tier_Node 3 5 6 7

    Output:

        Node_ID (NID) 75 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 5 [1] 6 [2] 7 --- Axon_Hillock_Count: 0

    Contents of the RETURN_FILE:

        75

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - If you get a crash when calling this then it is likely one or more of your submitted NIDs are not valid.
    */
    uint64_t get_Upper_Tier_Node(std::ifstream* p_File)
    {
        std::cout << "\n --> get_Upper_Tier_Node NODE_COUNT NODES  |";

        uint64_t tmp_Return_NID = 0;

        uint64_t tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";

        int tmp_Count = 0;

        *p_File >> tmp_Count;

        std::cout << " " << tmp_Count << " |";

        uint64_t* tmp_Nodes = NULL;
        tmp_Nodes = new uint64_t[tmp_Count];

        for (int cou_Index = 0; cou_Index < tmp_Count; cou_Index++)
        {
            *p_File >> tmp_Nodes[cou_Index];

            std::cout << " " << tmp_Nodes[cou_Index] << " |";
        }

        tmp_Return_NID = API.get_Upper_Tier_Node(tmp_Count, tmp_Nodes);

        if (tmp_Nodes != NULL) { delete [] tmp_Nodes; tmp_Nodes = NULL; }

        write_to_output(RETURN_FILE, tmp_Return_NID);

        return tmp_Return_NID;

        //std::cout << " [|x|]";
    }


    /** If a state node exists in the given construct index then return it, otherwise return 0.

        does_State_Node_Exist CONSTRUCT_ID STATE
    \param int CONSTRUCT_ID The construct that encapsulates the state space to search.
    \retval uint64_t NID The node that represents the state passed to this function. Passes the NID back if found, if not found it passes back 0.

    Checks the state tree of a given construct to see if the state is registered and bound to a node within that state space.

    Example Usage:

    We have a state node registered to construct 3 with the state 123. This state node is NID 50. We run 'does_State_Node_Exist 2 123' which returns the NID 50 as it found the node bound to the state '123' registered within construct 2's fractal state tree.

        does_State_Node_Exist 2 123

    Output:

    Contents of the RETURN_FILE:

        50

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - This assumes the [CONSTRUCT_ID] is valid
    */
    uint64_t does_State_Node_Exist(std::ifstream* p_File)
    {
        std::cout << "\n --> does_State_Node_Exist CONSTRUCT_ID STATE |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        uint64_t tmp_State = 0;

        *p_File >> tmp_State;

        std::cout << " " << tmp_State << " |";

        uint64_t tmp_Return_NID = API.does_State_Node_Exist(tmp_Construct, tmp_State);

        write_to_output(RETURN_FILE, tmp_Return_NID);

        return tmp_Return_NID;

        //std::cout << " [|x|]";
    }


    /** Checks to see if a node in the given Construct is bound to the given state, if not the node is created & the NID returned, if found the NID is returned..

        get_State_Node CONSTRUCT_ID STATE
    \param int CONSTRUCT_ID The construct that encapsulates the state space to search.
    \param uint64_t NID The state of the input, the current quanta, or element, of information being encoded.
    \retval uint64_t NID The node that represents the state passed to this function. Passes the NID back whether found or newly minted.

    Describe behavior and side-effects. What it basically does and if it touches any globals.

    Example Usage:

    Here we have a state that hasn't been encoded yet, this '999'. We run 'get_State_Node 2 999' which returns the NID of the newly minted and state bound node now stored and registered with construct 2's state fractal tree. In this example the NID of the new node is 150. We see this NID in the return file.

        does_State_Node_Exist 2 999

    Output:

    Contents of the RETURN_FILE:

        150

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - This assumes the [CONSTRUCT_ID] is valid
    */
    uint64_t get_State_Node(std::ifstream* p_File)
    {
        std::cout << "\n --> get_State_Node CONSTRUCT_ID STATE |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        uint64_t tmp_State = 0;

        *p_File >> tmp_State;

        std::cout << " " << tmp_State << " |";

        uint64_t tmp_Return_NID = API.get_State_Node(tmp_Construct, tmp_State);

        write_to_output(RETURN_FILE, tmp_Return_NID);

        return tmp_Return_NID;

        //std::cout << " [|x|]";
    }


    /** Iterates through every node and outputs their bp_O()

        output_BP
    \retval None This function doesn't return any values.

    This is for outputting the entire network to the console.

    Example Usage:

    in this example we have a single trace encoded which is composed of 5 integers, { 11, 22, 33, 44, 55 }. This results in 6 nodes which we will see in the output. 5 state tier nodes, one for each input integer, and one higher tier node. Remember, NID 0 exists, but it is the NULL node not to be used.

        output_BP

    Output:

        <=- 0 [0] -=>
        <=- 1 [11] -=>
        <=- 2 [22] -=>
        <=- 3 [33] -=>
        <=- 4 [44] -=>
        <=- 5 [55] -=>
        <=- 6 * [11]  [22]  [33]  [44]  [55] -=>

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void output_Backpropagated_Symbols()
    {
        std::cout << "\n --> output_Backpropagated_Symbols |";

        API.output_Backpropagated_Symbols(2);

        //std::cout << " [|x|]";
    }


    /** Finds given NID and outputs the bp_O().

        output_BP_NID NID
    \param uint64_t NID The Node ID (NID) of the node being manipulated.
    \retval None This function doesn't return any values.

    Uses the fractal NID tree to search the node linked list for the given NID. Once found it uses the ->bp_O() to output the pattern the node represents.

    Example Usage:

    Here NID 55 represents the compound symbol '32 64 128 64 32'.

        bp_NID 5

    Output:

        <=- 55 * [32]  [64]  [128]  [64]  [32] -=>

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void output_Backpropagated_Symbol_NID(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Backpropagated_Symbol_NID   NID |";

        uint64_t tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";

        API.output_Backpropagated_Symbol_NID(tmp_NID);

        //std::cout << " [|x|]";
    }


    void output_Backpropagated_Symbol_NID_uint(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Backpropagated_Symbol_NID_uint   NID |";

        uint64_t tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";

        API.output_Backpropagated_Symbol_NID_uint(tmp_NID);

        //std::cout << " [|x|]";
    }

    //    ---=========---
    //   ---===========---
    //  ---==   CAN   ==---
    //   ---===========---
    //    ---=========---

    //   ---=============================================---
    //  ---==   Encoding and querying the constructs.   ==---
    //   ---=============================================---

	/** Encodes the current input of the given Construct.

        encode CONSTRUCT_ID
    \param int CONSTRUCT_ID The construct that encapsulates the state space to use when encoding.
    \retval None This function doesn't return any values.

    This encodes the p_Input data, if the nodes aren't found they are created, used for training. How it does this is determined by what type of construct it is. Different constructs can have different structures depending on whether they are many to one, 2d pyramidal, 3d pyramidal, stiched based, etc.

    To encode a construct you must first have input loaded into it. Once the input is loaded then calling this will encode the input pattern into a construct. The way to use this is to first get input to the construct, then you tell it to encode the input, then you can use gather, output, and other functions to access the results.:

         Get Input: set_Input | set_Input_uint | load_Input
         Do something with the Input: encode
         Get your Output: gather_X | output_X 

    Example Usage:

    - First we create a construct of the type Many_To_One named ExaCon for Example Construct.
    - Then we use set_Input_uint to load the uint array { 10, 15, 20 } into ExaCon's input.
    - After the input is set we call encode on ExaCon, which is construct ID [0].
    - We then use output_Scaffold to view the encoded trace.
    - This example is a Many_To_One, which means all state nodes (Tier[0]) are connected to a single upper tier (Tier[1]) treetop node.
        
        register_Construct Many_To_One ExaCon
        set_Input_uint 0 5 3 10 15 20
        encode 0
        output_Scaffold 0
        output_Node_Network
        gather_All_Nodes 0

    Output:

         __COMMAND__| output_Scaffold CONSTRUCT_ID |
          --==   CAN_Scaffold   ==--
         <- Tier[0] ->
           [0]  <> 1
           [1]  <> 2
           [2]  <> 3
         <- Tier[1] ->
           [0]  <> 4

         __COMMAND__| output_node_network |
         Node_ID (NID): 0  RC: 1 Type: 0 State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
         Node_ID (NID): 1  RC: 2 Type: 0 State { 10 } --- Dendrites:  --- Axon_Hillock_Count: 1 Axons[0] <1>:  [0] 4
         Node_ID (NID): 2  RC: 2 Type: 0 State { 15 } --- Dendrites:  --- Axon_Hillock_Count: 2 Axons[0] <0>:  Axons[1] <1>:  [0] 4
         Node_ID (NID): 3  RC: 2 Type: 0 State { 20 } --- Dendrites:  --- Axon_Hillock_Count: 3 Axons[0] <0>:  Axons[1] <0>:  Axons[2] <1>:  [0] 4
         Node_ID (NID): 4  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 1 [1] 2 [2] 3 --- Axon_Hillock_Count: 0

    - Here is another example, except this time we're encoding the phrase "the quick brown fox jumped over the lazy dog" to show language being encoded.

        register_Construct Many_To_One ExaCon
        set_Input 0 the quick brown fox jumps over the lazy dog
        encode 0
        output_Scaffold 0
        gather_All_Nodes 0

    Output:

        0 1 0 0 1
        1 3 0 32 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 t
        2 3 0 33 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 h
        3 4 0 34 0 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 0 0 0 0 1 28 1 e
        4 9 0 40 0 0 0 1 28 0 0 0 0 0 1 28 0 0 0 0 0 1 28 0 0 0 1 28 0 0 0 0 0 1 28 0 0 0 0 1 28 0 0 0 1 28 0 0 0 0 1 28 1
        5 2 0 5 0 0 0 0 1 28 1 q
        6 3 0 22 0 0 0 0 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 u
        7 2 0 7 0 0 0 0 0 0 1 28 1 i
        8 2 0 8 0 0 0 0 0 0 0 1 28 1 c
        9 2 0 9 0 0 0 0 0 0 0 0 1 28 1 k
        10 2 0 11 0 0 0 0 0 0 0 0 0 0 1 28 1 b
        11 3 0 30 0 0 0 0 0 0 0 0 0 0 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 r
        12 5 0 42 0 0 0 0 0 0 0 0 0 0 0 0 1 28 0 0 0 0 1 28 0 0 0 0 0 0 0 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 o
        13 2 0 14 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 w
        14 2 0 15 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 n
        15 2 0 17 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 f
        16 2 0 19 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 x
        17 2 0 21 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 j
        18 2 0 23 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 m
        19 2 0 24 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 p
        20 2 0 25 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 s
        21 2 0 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 v
        22 2 0 36 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 l
        23 2 0 37 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 a
        24 2 0 38 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 z
        25 2 0 39 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 y
        26 2 0 41 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 d
        27 2 0 43 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 g
        28 2 43 1 2 3 4 5 6 7 8 9 4 10 11 12 13 14 4 15 12 16 4 17 6 18 19 20 4 12 21 3 11 4 1 2 3 4 22 23 24 25 4 26 12 27 0 43 the quick brown fox jumps over the lazy dog

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - Whitespace is weird when doing text input through set_Input! It reads from the text file using "file >> tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action.
    */
    void encode(std::ifstream* p_File)
    {
        std::cout << "\n --> encode CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.encode(tmp_Construct);

        //std::cout << " [|x|]";
    }


    
    //		
        //Passes the values to an Construct to encode.
    /** Queries the network with the current input set for the given construct, evaluates the input set and stores the results in the output traces, gathered using 'gather_Output'.

        query CONSTRUCT_ID
    \param int CONSTRUCT_ID The construct that encapsulates the state space to search.
    \retval None This function doesn't return any values, the data resulting from this function is handled through traces.

    This sets up the scaffold as encode does, but it doesn't create nodes if they aren't found, they remain NULL in the scaffold, this we call a NULLCAN

    Used for querying the network, you input, fill the NULLCAN, charge the network, then gather the outputs. Does not create new nodes, only finds if they already exist or not, does not "train" only "evaluates".

    Suggested for use before encoding (if using learning mode and not locked_to_initial_training_mode) otherwise it will also find the current trace as the perfect match.

    To query a construct you must first have input loaded into it. Once the input is loaded then calling this will query the input pattern for a given construct. The way to use this is to first get input to the construct, then you tell it to evaluate the input, then you can use gather, output, and other functions to access the results.:

         Get Input: set_Input | set_Input_uint | load_Input
         Do something with the Input: query
         Get your Output: gather_X | output_X

    Example Usage:

    This example is a Many_To_One, which means all state nodes (Tier[0]) are connected to a single upper tier (Tier[1]) treetop node.

    You may notice that all the names are lowercase, this is because 'R' and 'r' are different symbols, so making them all lowercase keeps them using the same 'letters'.

    First we create a construct of the type Many_To_One named ExaCon for Example Construct.
    
        register_Construct Many_To_One ExaCon

    Then we use set_Input + encode to load several character names into the network and encode them as a base set, see encode for further details.
    
        set_Input 0 randolph carter /end/ encode 0
        set_Input 0 harley warren /end/ encode 0
        set_Input 0 herbert west /end/ encode 0
        set_Input 0 dr. allen halsey /end/ encode 0
        set_Input 0 erich zann /end/ encode 0
        set_Input 0 edward norrys /end/ encode 0
        set_Input 0 king kuranes /end/ encode 0

    After we have the base character names we can begin searching them. We set the input to the string 'i' to search names that have 'i' in them.
    
        set_Input 0 i

    To call this function and the correct construct we use 'query 0', this fills the NULLCAN and handles the neural cascades.
    
        query 0

    We then use 'output_Scaffold' to view the NULLCAN showing the tiny CAN holding the current queries, 'gather_Output 0' to output the resulting traces to the output file for Construct [0] (default ".\Output\CONSTRUCT_NAME.Output.ssv").
    
        output_Scaffold 0
        gather_Output 0

    To show different searches we do several searches with a newline in the output between them.

    Search for 'a':

        output_Newline 0
        set_Input 0 a
        query 0
        output_Scaffold 0
        gather_Output 0

    Search for 'h':
    
        output_Newline 0
        set_Input 0 h
        query 0
        output_Scaffold 0
        gather_Output 0

    Search for 'e':

        output_Newline 0
        set_Input 0 e
        query 0
        output_Scaffold 0
        gather_Output 0

    Search for 'eai':

        output_Newline 0
        set_Input 0 eai
        query 0
        output_Scaffold 0
        gather_Output 0

    Here is the above code in completion if you want to copy/paste:

        register_Construct Many_To_One ExaCon
        set_Input 0 randolph carter /end/ encode 0
        set_Input 0 harley warren /end/ encode 0
        set_Input 0 herbert west /end/ encode 0
        set_Input 0 dr. allen halsey /end/ encode 0
        set_Input 0 erich zann /end/ encode 0
        set_Input 0 edward norrys /end/ encode 0
        set_Input 0 king kuranes /end/ encode 0
        set_Input 0 i
        query 0
        output_Scaffold 0
        gather_Output 0
        output_Newline 0
        set_Input 0 a
        query 0
        output_Scaffold 0
        gather_Output 0
        output_Newline 0
        set_Input 0 h
        query 0
        output_Scaffold 0
        gather_Output 0
        output_Newline 0
        set_Input 0 e
        query 0
        output_Scaffold 0
        gather_Output 0
        output_Newline 0
        set_Input 0 eai
        query 0
        output_Scaffold 0
        gather_Output 0

    Output:

    CAN Scaffold for the 'i' search

        __COMMAND__| output_Scaffold CONSTRUCT_ID |
         --==   CAN_Scaffold   ==--
        <- Tier[0] ->
          [0]  <> 22
        <- Tier[1] ->
          [0] NULL

    CAN Scaffold for the 'a' search

        __COMMAND__| output_Scaffold CONSTRUCT_ID |
         --==   CAN_Scaffold   ==--
        <- Tier[0] ->
          [0]  <> 2
        <- Tier[1] ->
          [0] NULL

    CAN Scaffold for the 'h' search

        __COMMAND__| output_Scaffold CONSTRUCT_ID |
         --==   CAN_Scaffold   ==--
        <- Tier[0] ->
          [0]  <> 8
        <- Tier[1] ->
          [0] NULL

    CAN Scaffold for the 'e' search

        __COMMAND__| output_Scaffold CONSTRUCT_ID |
         --==   CAN_Scaffold   ==--
        <- Tier[0] ->
          [0]  <> 12
        <- Tier[1] ->
          [0] NULL

    CAN Scaffold for the 'eai' search

         __COMMAND__| output_Scaffold CONSTRUCT_ID |
          --==   CAN_Scaffold   ==--
         <- Tier[0] ->
           [0]  <> 12
           [1]  <> 2
           [2]  <> 22
         <- Tier[1] ->
           [0] NULL

    Contents of ".\Output\ExaCon.Output.ssv"

    Results of 'i' search

        29 10 2 12 king kuranes
        24 10 2 10 erich zann

    Results of 'a' search

        13 20 2 15 randolph carter
        16 20 2 13 harley warren
        25 10 2 13 edward norrys
        21 20 2 16 dr. allen halsey
        24 10 2 10 erich zann
        29 10 2 12 king kuranes

    Results of 'h' search

        16 10 2 13 harley warren
        19 10 2 12 herbert west
        24 10 2 10 erich zann
        13 10 2 15 randolph carter
        21 10 2 16 dr. allen halsey

    Results of 'e' search

        24 10 2 10 erich zann
        25 10 2 13 edward norrys
        19 30 2 12 herbert west
        16 20 2 13 harley warren
        21 20 2 16 dr. allen halsey
        29 10 2 12 king kuranes
        13 10 2 15 randolph carter

    Results of 'eai' search

        24 30 2 10 erich zann
        25 20 2 13 edward norrys
        19 30 2 12 herbert west
        16 40 2 13 harley warren <- the charge is 40 because it has 2 'a' characters, and 2 'e' characters.
        21 40 2 16 dr. allen halsey
        29 30 2 12 king kuranes
        13 30 2 15 randolph carter

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:
    - Use characters or numbers that you know won't appear in the dataset to create a "greenscreen" over your input for the network. This is due to the NULLCAN, where a node that isn't found is set to NULL on the CAN scaffold, and subsequently is skipped during charging as there is nothing to charge. Alternatively just use the query_Given_Legs command.
    - Whitespace is weird when doing text input through set_Input! It reads from the text file using "file >> tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action.
    */
    void query(std::ifstream* p_File)
    {
        std::cout << "\n --> query CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.query(tmp_Construct);
    }

    /** Queries the network with the current input set of the given Construct, but the input index determines what leg is charged. Meaning if an input at index [3] is charged then only upper tier nodes connected on axon hillock [3] will be charged.

        query_Spacial CONSTRUCT_ID
    \param int CONSTRUCT_ID The construct that encapsulates the state space to search.
    \retval None This function doesn't return any values, the data resulting from this function is handled through traces.

    This query is used when the position of the input relative to the rest matters. Such as in time series searches, or context dependent inputs. The input position determines which connections get charged, this allows for searching nodes based on both the state of the input and the position.

    This would be useful for things such as time-series prediction, such as stock data or an environmental variable. 

    Example Usage:

    - Example 1.

    If we were trying to predict temperatures based on the previous temperatures and their fluctuations we might use this function. For example, if we have the current set of temperatures as { 50, 55, 60 } then we would want to know what comes after 60. First though we'll encode a sample history to search through.

    Here's the sample history:

        50 55 60 65 70 70 65 60 55 50

    We'll do this by encoding 3 temperatures at a time starting at the beginning of the sample history.

        register_Construct Many_To_One ExaCon
        set_Input_uint 0 5 3 50 55 60
        encode 0
        set_Input_uint 0 5 3 55 60 65
        encode 0
        set_Input_uint 0 5 3 60 65 70
        encode 0
        set_Input_uint 0 5 3 65 70 70
        encode 0
        set_Input_uint 0 5 3 70 70 65
        encode 0
        set_Input_uint 0 5 3 70 65 60
        encode 0
        set_Input_uint 0 5 3 65 60 55
        encode 0
        set_Input_uint 0 5 3 60 55 50
        encode 0

    Assuming we encoded 3 temperatures at a time we can create a prediction by setting the first two indexes and searching "forward".

    So we input the set { 55, 60 } for the first two numbers, then search using this query_Spacial.

        set_Input_uint 0 5 2 55 60
        query_Spacial 0
        gather_Output_uint 0

    This means that only patterns with 55 as position [0], and 60 as position [1] will be found. This means those found will have position [2] as the "next" temperature.

    Output:

        6 20 2 3 55 60 65
        12 10 2 3 65 60 55

    We may choose to evaluate them through simple averaging the predicted index (number [2]). Or, alternatively we can weight them based on charge, or both.

    In this case we can choose the trace with the charge of 20 for our prediction, which is { 55, 60, 65 }

    A pure average would return 60, so trace selection is an important aspect that goes beyond this simple example. The choice on how to select the traces and filter them can make or break an algorithm.

    So we take our current input and add the new trace to get a prediction:

        55 60 ?? <- Current, the ?? is the index we are searching for, the prediction.
        55 60 65 <- Found
        =
        55 60 65 <- Resulting predicted pattern.

    - Example 2.

    For an example that hopefully illistrates the purpose of this function we can walk through searching for a string when you know only a couple characters and their position in the string. Pretend you are sleuthing around online hunting down pedo scum, suddenly discord dings, a message! One of your contacts has a lead, a screenshot from a twitch stream with the kingpin distributor you've been tracking for a while now. He's in this twitch chat, you know that avatar, but there's a problem. The chat animations have caused a cloud of emoji to be doubleing over the name right as the screenshot was taken. You have only the second and third characters, 'aw', but it is a lead.

    So we have the clue to work on [ '?' 'a' 'w' '?' ]. We know 'aw' are the second and third character, and the first char is a mystery, as are the rest if they even exist, which is liklely given how short that username would be.

    Luckily you have a dataset of usernames to look through, we'll train these into the network (obviously we are using a completely insufficient number but we aren't including 10k usernames here), then search the network using our clue.

    One thing to note, we have these usernames from sites we've scraped, and they have characters not allowed in the name. This means we can take our knowledge of how the network works and use this by inputting characters that cannot appear in usernames like a "greenscreen" in the string. The network during query doesn't create nodes, and if the username network never has these illegal characters encoded to a node then we will sure we are only searching for our intended characters, as no nodes will be in the scaffold for the invalid ones to charge.

    Code for our initial dataset, notice some names such as Flawless1337 do not have the 'aw' in the right spot:

        register_Construct Many_To_One ExaCon
        set_Input 0 SawBones9000 /end/ encode 0
        set_Input 0 MawOfD00M /end/ encode 0
        set_Input 0 PawPatriot1337 /end/ encode 0
        set_Input 0 DawgWalker2000 /end/ encode 0
        set_Input 0 TawTacticLol /end/ encode 0
        set_Input 0 RawRampage2001 /end/ encode 0
        set_Input 0 KawKungFuMaster /end/ encode 0
        set_Input 0 LawlessLegion1337 /end/ encode 0
        set_Input 0 Jawbreaker9001 /end/ encode 0
        set_Input 0 VawVandal2000 /end/ encode 0
        set_Input 0 AwkwardWarrior /end/ encode 0
        set_Input 0 Flawless1337 /end/ encode 0
        set_Input 0 StrawHat2000` /end/ encode 0
        set_Input 0 ClawClasherLol /end/ encode 0
        set_Input 0 GnawingGamer2001 /end/ encode 0
        set_Input 0 HacksawHavoc /end/ encode 0
        set_Input 0 Jawdropper2000 /end/ encode 0
        set_Input 0 MawMauler1337 /end/ encode 0
        set_Input 0 YawYawkerLol /end/ encode 0
        set_Input 0 ZawZapper2001 /end/ encode 0

    After the dataset we setup the query and submit it, using the 'illega' character of '_' to create "NULLCAN" nodes, which are positions in the current active node (CAN) scaffold, the datastructure which corrdinates encoding and charging, which don't have a node, therefore are "NULLCAN" nodes.

        set_Input 0 _aw
        query_Spacial 0

    Gather the output traces into the "./Output/ExaCon.ssv" file.

        gather_Output 0

    Put a newline in the output file so we can tell the difference between the two queries we are doing. Two queries to compare this function to the 'normal' query.

        output_Newline 0

    The input is still set to "_aw" so we don't have to reinput our string. We can instead call 'query 0' because the prep work is all done. We then gather the output as normal with 'gather_Output 0'.

        query 0
        gather_Output 0

    Output:

    Contents of "./Output/ExaCon.Output.ssv":

    Compare the first set returned with this query_Spacial function here:

        11 20 2 12 SawBones9000
        16 20 2  9 MawOfD00M
        24 20 2 14 PawPatriot1337
        30 20 2 14 DawgWalker2000
        34 20 2 12 TawTacticLol
        38 20 2 14 RawRampage2001
        42 20 2 15 KawKungFuMaster
        43 20 2 17 LawlessLegion1337
        46 20 2 14 Jawbreaker9001
        49 20 2 13 VawVandal2000
        62 10 2 12 HacksawHavoc
        63 20 2 14 Jawdropper2000
        64 20 2 13 MawMauler1337
        66 20 2 12 YawYawkerLol
        68 20 2 13 ZawZapper2001

    To this set returned with the nondifferentiated query function:

        11 20 2 12 SawBones9000
        16 20 2  9 MawOfD00M
        24 30 2 14 PawPatriot1337
        30 30 2 14 DawgWalker2000
        34 30 2 12 TawTacticLol
        38 40 2 14 RawRampage2001 <- Notice the high charge of [40] due to the frequency of 'a' characters with the 'aw' sub-string.
        42 30 2 15 KawKungFuMaster
        43 20 2 17 LawlessLegion1337
        46 30 2 14 Jawbreaker9001
        49 40 2 13 VawVandal2000
        62 40 2 12 HacksawHavoc
        63 20 2 14 Jawdropper2000
        64 30 2 13 MawMauler1337
        66 40 2 12 YawYawkerLol
        68 30 2 13 ZawZapper2001
        52 20 2 12 Flawless1337
        58 30 2 14 ClawClasherLol
        60 30 2 16 GnawingGamer2001
        55 30 2 13 StrawHat2000`
        51 40 2 14 AwkwardWarrior

    Full code for the previous example if you wish to copy/paste:

        register_Construct Many_To_One ExaCon
        set_Input 0 SawBones9000 /end/ encode 0
        set_Input 0 MawOfD00M /end/ encode 0
        set_Input 0 PawPatriot1337 /end/ encode 0
        set_Input 0 DawgWalker2000 /end/ encode 0
        set_Input 0 TawTacticLol /end/ encode 0
        set_Input 0 RawRampage2001 /end/ encode 0
        set_Input 0 KawKungFuMaster /end/ encode 0
        set_Input 0 LawlessLegion1337 /end/ encode 0
        set_Input 0 Jawbreaker9001 /end/ encode 0
        set_Input 0 VawVandal2000 /end/ encode 0
        set_Input 0 AwkwardWarrior /end/ encode 0
        set_Input 0 Flawless1337 /end/ encode 0
        set_Input 0 StrawHat2000` /end/ encode 0
        set_Input 0 ClawClasherLol /end/ encode 0
        set_Input 0 GnawingGamer2001 /end/ encode 0
        set_Input 0 HacksawHavoc /end/ encode 0
        set_Input 0 Jawdropper2000 /end/ encode 0
        set_Input 0 MawMauler1337 /end/ encode 0
        set_Input 0 YawYawkerLol /end/ encode 0
        set_Input 0 ZawZapper2001 /end/ encode 0
        set_Input 0 _aw
        query_Spacial 0
        gather_Output 0
        output_Newline 0
        query 0
        gather_Output 0

    - Example 3.

    There may be times when you have a set number of inputs and you want to search for any patterns with that state in that spot. For example, you have your input set from your greenhouse sensors, oxygen, carbon dioxide, temperature, humidity, etc.

    Each of these is an row in your input list:

    -# Oxygen
    -# Carbon Dioxide
    -# Temperature
    -# Humidity
    -# Etc

    They are read in as a string of values 1 - 5, "O2 Co2 Temp Hum Etc", and example with values may be "2 4 2 1 3" to give an idea what an input list might look like to the neural network.

    So you encode each list, each snapshot, once every hour or so as your standard datakeeping, in fact it is automated. We'll use these made up snapshots for an example dataset:

        register_Construct Many_To_One ExaCon <- Don't forget to register the construct.
        set_Input 0 3 2 4 1 5 /end/ encode 0
        set_Input 0 2 3 3 2 4 /end/ encode 0
        set_Input 0 4 1 2 5 3 /end/ encode 0
        set_Input 0 5 4 3 2 1 /end/ encode 0
        set_Input 0 1 5 2 4 3 /end/ encode 0
        set_Input 0 3 2 1 4 5 /end/ encode 0
        set_Input 0 4 3 2 5 1 /end/ encode 0
        set_Input 0 1 4 3 2 5 /end/ encode 0
        set_Input 0 2 3 4 1 5 /end/ encode 0
        set_Input 0 5 1 2 3 4 /end/ encode 0
        set_Input 0 3 4 2 1 5 /end/ encode 0
        set_Input 0 2 1 3 5 3 /end/ encode 0
        set_Input 0 4 5 1 2 3 /end/ encode 0
        set_Input 0 1 2 3 4 5 /end/ encode 0
        set_Input 0 3 2 5 1 4 /end/ encode 0
        set_Input 0 2 3 4 5 1 /end/ encode 0
        set_Input 0 4 5 2 3 1 /end/ encode 0
        set_Input 0 5 1 3 2 4 /end/ encode 0
        set_Input 0 1 4 5 3 2 /end/ encode 0
        set_Input 0 3 2 4 5 1 /end/ encode 0
        set_Input 0 2 1 5 3 3 /end/ encode 0
        set_Input 0 4 3 1 2 5 /end/ encode 0
        set_Input 0 5 4 2 1 3 /end/ encode 0
        set_Input 0 1 5 4 3 2 /end/ encode 0
        set_Input 0 3 2 1 5 4 /end/ encode 0
    
    Now, your boss comes in one day and says they need some data for a research project. They want every snapshop that has a humity value of 3 (everything here is 1 - 5 in range for simplicity) and a O2 of 2.

    So you formulate your input string, using the greenscreen illegal character mask again, where the first and last are set to '2' and '3' respectively: "2 _ _ _ 3". There is a major issue with this that may not be apparent right away, the spaces are counted as valid symbols by the network. So we need to invalidate them as well to remove them from the query, "2_______3"

    This is because the input array is treated as an array of characters, with the caveat that extra whitespace is ignored and condensed down to a single space, ' ', which can be odd if not expected.

        set_Input 0 2_______3 /end/

    Then use this query_Spacial function & gather the output:

        query_Spacial 0
        gather_Output 0

    Which gives us the output:

         8 10 2 9 2 3 3 2 4
        15 10 2 9 2 3 4 1 5
        18 20 2 9 2 1 3 5 3 <- The charge here is [20] because both of the nodes were found in the right location.
        22 10 2 9 2 3 4 5 1
        27 20 2 9 2 1 5 3 3
         9 10 2 9 4 1 2 5 3
        11 10 2 9 1 5 2 4 3
        19 10 2 9 4 5 1 2 3
        29 10 2 9 5 4 2 1 3

    To further this example we will search for a temperature with a value of 1, and humidity of 4 to see what was going on when it was a wee bit chilly with high humidity.

    First we output a newline to the file to separate our searches, then we set the input. After setting the input we can then query_Spacial and gather_Output as normal.

        output_Newline 0
        set_Input 0 ____1___4 /end/
        query_Spacial 0
        gather_Output 0

    This gives the following output:

        12 10 2 9 3 2 1 4 5
        19 10 2 9 4 5 1 2 3
        28 10 2 9 4 3 1 2 5
        31 20 2 9 3 2 1 5 4 <- This appears to be the only really good match.
         8 10 2 9 2 3 3 2 4
        16 10 2 9 5 1 2 3 4
        21 10 2 9 3 2 5 1 4
        24 10 2 9 5 1 3 2 4

    Using this you can selectively search your traces.

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - Use characters or numbers that you know won't appear in the dataset to create a "greenscreen" over your input for the network. This is due to the NULLCAN, where a node that isn't found is set to NULL on the CAN scaffold, and subsequently is skipped during charging as there is nothing to charge. Alternatively just use the query_Given_Legs command.
    - Whitespace is weird when doing text input through set_Input! It reads from the text file using "file >> tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action.
    */
    void query_Spacial(std::ifstream* p_File)
    {
        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.query_Spacial(tmp_Construct);

        //std::cout << " [|x|]";
    }

    /** Queries the network with the current input set, however, every input node is charged using the given index.

        query_Given_Index CONSTRUCT_ID INDEX
    \param int CONSTRUCT_ID The construct that encapsulates the state space to search.
    \param int INDEX This is the index to use when charging, if you are searching for patterns that have any of the input nodes in index [2] then you would use this parameter to specify leg [2].
    \retval None This function doesn't return any values, the data resulting from this function is handled through traces.

    If INDEX is [3] then all nodes in the input set will be charging using axon hillock [3].

    This is used when you have multiple inputs to the same index that you want to check. For example, maybe you want to check for traces grouped around one end the temperature scale rather than a single value.
    
    Example Usage:

    - Example 1.

    Following up on the idea of checking a range of thermometer readings from the description we have this example. If your temperature gauge registers 1 -5 then in this example you might want to look up the super-symbols, the encoded traces, the upper tier nodes, that have 4 & 5 encoded onto the index corresponding to temperature on your greenhouse input array.

    Here is an example input set from our example greenhouse sensors, oxygen, carbon dioxide, temperature, humidity, etc.

    Each of these is an row in your input list:

    -# Oxygen
    -# Carbon Dioxide
    -# Temperature <- We'll be searching this index for the temperature ranges using this function query_Given_Index
    -# Humidity
    -# Etc

    They are read in as a string of values 1 - 5, "O2 Co2 Temp Humidity Etc", and example with values may be "2 4 2 1 3" to give an idea what an input list might look like to the neural network.

    So you encode each list, for this example we'll say your greenhouse controller automatically logs these input lists. We'll use some of this log data for an example dataset:

        register_Construct Many_To_One ExaCon <- Don't forget to register the construct.
        set_Input 0 3 2 4 1 5 /end/ encode 0
        set_Input 0 2 3 3 2 4 /end/ encode 0
        set_Input 0 4 1 2 5 3 /end/ encode 0
        set_Input 0 5 4 3 2 1 /end/ encode 0
        set_Input 0 1 5 2 4 3 /end/ encode 0
        set_Input 0 3 2 1 4 5 /end/ encode 0
        set_Input 0 4 3 2 5 1 /end/ encode 0
        set_Input 0 1 4 3 2 5 /end/ encode 0
        set_Input 0 2 3 4 1 5 /end/ encode 0
        set_Input 0 5 1 2 3 4 /end/ encode 0
        set_Input 0 3 4 2 1 5 /end/ encode 0
        set_Input 0 2 1 3 5 3 /end/ encode 0
        set_Input 0 4 5 1 2 3 /end/ encode 0
        set_Input 0 1 2 3 4 5 /end/ encode 0
        set_Input 0 3 2 5 1 4 /end/ encode 0
        set_Input 0 2 3 4 5 1 /end/ encode 0
        set_Input 0 4 5 2 3 1 /end/ encode 0
        set_Input 0 5 1 3 2 4 /end/ encode 0
        set_Input 0 1 4 5 3 2 /end/ encode 0
        set_Input 0 3 2 4 5 1 /end/ encode 0
        set_Input 0 2 1 5 3 3 /end/ encode 0
        set_Input 0 4 3 1 2 5 /end/ encode 0
        set_Input 0 5 4 2 1 3 /end/ encode 0
        set_Input 0 1 5 4 3 2 /end/ encode 0
        set_Input 0 3 2 1 5 4 /end/ encode 0

    Now we need to find the temperatures, the { 4, 5 }. We do this by setting the input appropriately. 

    To formulate the input strings we create an input string from out input indexes with no whitespace between them, this is because each one is the smallest unit of information so we don't risk losing any by placing characters next to each other. Being single digit values 1-5 we can do that with this string based input:

        45

    This 45 is represented as a string internally so each digit is a separate integer value even though a human reads it as forty-five.

    Then formulate it into the set_Input string for the construct 0 (ExaCon as defined using 'register_Construct Many_To_One ExaCon' above) we are working with:

        set_Input 0 45 /end/

    Finally we query the network with 'query_Given_Index' to search the network for all traces containing one of { 4, 5 } on leg 4, which corresponds to 4. Temperature, so index/leg/dendrite/axon_hillock #4. You might wonder why we are setting it to index 4 and not 2 like one would expect. This is because we have to count each whitespace as an index in the input string, "1 2 3 4 5" equals '1' + ' ' + '2' + ' ' + '3' + ' ' + '4' + ' ' + '5'. 
    
    Here is the query string:
    
        query_Given_Index 0 4

    Then use 'gather_Output' to get the output:

        gather_Output 0

    Output:

    Contents of "./Output/ExaCon.Output.ssv":

         7 10 2 9 3 2 4 1 5
        15 10 2 9 2 3 4 1 5
        22 10 2 9 2 3 4 5 1
        26 10 2 9 3 2 4 5 1
        30 10 2 9 1 5 4 3 2
        21 10 2 9 3 2 5 1 4
        25 10 2 9 1 4 5 3 2
        27 10 2 9 2 1 5 3 3

    - Example 2.

    This example builds on the above one to search for temperatures matching 1, 2, & 3.

        set_Input 0 123 /end/

    Then the query and gather:

        query_Given_Index 0 4
        gather_Output 0

    Output:

    Contents of "./Output/ExaCon.Output.ssv":
    
        12 10 2 9 3 2 1 4 5
        19 10 2 9 4 5 1 2 3
        28 10 2 9 4 3 1 2 5
        31 10 2 9 3 2 1 5 4
         9 10 2 9 4 1 2 5 3
        11 10 2 9 1 5 2 4 3
        13 10 2 9 4 3 2 5 1
        16 10 2 9 5 1 2 3 4
        17 10 2 9 3 4 2 1 5
        23 10 2 9 4 5 2 3 1
        29 10 2 9 5 4 2 1 3
         8 10 2 9 2 3 3 2 4
        10 10 2 9 5 4 3 2 1
        14 10 2 9 1 4 3 2 5
        18 10 2 9 2 1 3 5 3
        20 10 2 9 1 2 3 4 5
        24 10 2 9 5 1 3 2 4

    - Example 3.

    In this example we basically redo the same environmental search again, but this time we'll use the uint interface.

    Start with encoding, but with uint and the syntax that requires (set_Input_uint CONSTRUCT_ID COUNT INPUT ):

        register_Construct Many_To_One ExaCon <- Don't forget to register the construct.
        set_Input_uint 0 5 3 2 4 1 5 encode 0
        set_Input_uint 0 5 2 3 3 2 4 encode 0
        set_Input_uint 0 5 4 1 2 5 3 encode 0
        set_Input_uint 0 5 5 4 3 2 1 encode 0
        set_Input_uint 0 5 1 5 2 4 3 encode 0
        set_Input_uint 0 5 3 2 1 4 5 encode 0
        set_Input_uint 0 5 4 3 2 5 1 encode 0
        set_Input_uint 0 5 1 4 3 2 5 encode 0
        set_Input_uint 0 5 2 3 4 1 5 encode 0
        set_Input_uint 0 5 5 1 2 3 4 encode 0
        set_Input_uint 0 5 3 4 2 1 5 encode 0
        set_Input_uint 0 5 2 1 3 5 3 encode 0
        set_Input_uint 0 5 4 5 1 2 3 encode 0
        set_Input_uint 0 5 1 2 3 4 5 encode 0
        set_Input_uint 0 5 3 2 5 1 4 encode 0
        set_Input_uint 0 5 2 3 4 5 1 encode 0
        set_Input_uint 0 5 4 5 2 3 1 encode 0
        set_Input_uint 0 5 5 1 3 2 4 encode 0
        set_Input_uint 0 5 1 4 5 3 2 encode 0
        set_Input_uint 0 5 3 2 4 5 1 encode 0
        set_Input_uint 0 5 2 1 5 3 3 encode 0
        set_Input_uint 0 5 4 3 1 2 5 encode 0
        set_Input_uint 0 5 5 4 2 1 3 encode 0
        set_Input_uint 0 5 1 5 4 3 2 encode 0
        set_Input_uint 0 5 3 2 1 5 4 encode 0

    For the input search string we use the uint format of stating the number of elements and our inputs, so 'set_Input 45 /end/' becomes 'set_Input_uint 2 4 5':

        set_Input 0 2 4 5

    The different input methods result in different input indexes for the values, meaning our query is different. The uint version gives us the intuitive index of [2] for our temperature because each number is a sequential input, rather than input - space - input:

        query_Given_Index 0 2

    We gather using the uint interface so it outputs the integers to the textfile properly:

        gather_Output_uint 0

    Output:

    Contents of "./Output/ExaCon.Output.ssv":

         6 10 2 5 3 2 4 1 5
        14 10 2 5 2 3 4 1 5
        21 10 2 5 2 3 4 5 1
        25 10 2 5 3 2 4 5 1
        29 10 2 5 1 5 4 3 2
        20 10 2 5 3 2 5 1 4
        24 10 2 5 1 4 5 3 2
        26 10 2 5 2 1 5 3 3

    - Example Meta-Explanation:

    The difference in the node IDs is due to the string interface not encoding the ' ' as the second character. With the input set of 'n n n n n', and each 'n' being a value 1-5, this means the second index in the string will be ' ' and read in as NID[2]. You can compare the patterns between the string version and the uint version to see the data is the same, but the node IDs are off by one:

    String version 'set_Input':

         7 10 2 9 3 2 4 1 5
        15 10 2 9 2 3 4 1 5
        22 10 2 9 2 3 4 5 1
        26 10 2 9 3 2 4 5 1
        30 10 2 9 1 5 4 3 2
        21 10 2 9 3 2 5 1 4
        25 10 2 9 1 4 5 3 2
        27 10 2 9 2 1 5 3 3

    uint Version 'set_Input_uint':

         6 10 2 5 3 2 4 1 5
        14 10 2 5 2 3 4 1 5
        21 10 2 5 2 3 4 5 1
        25 10 2 5 3 2 4 5 1
        29 10 2 5 1 5 4 3 2
        20 10 2 5 3 2 5 1 4
        24 10 2 5 1 4 5 3 2
        26 10 2 5 2 1 5 3 3


    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - Use characters or numbers that you know won't appear in the dataset to create a "greenscreen" over your input for the network. This is due to the NULLCAN, where a node that isn't found is set to NULL on the CAN scaffold, and subsequently is skipped during charging as there is nothing to charge. Alternatively just use the query_Given_Legs command.
    - Whitespace is weird when doing text input through set_Input! It reads from the text file using "file >> tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action.
    */
    void query_Given_Index(std::ifstream* p_File)
    {
        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        int tmp_Index = 0;

        *p_File >> tmp_Index;

        std::cout << " " << tmp_Index << " |";

        API.query_Given_Index(tmp_Construct, tmp_Index);

        //std::cout << " [|x|]";
    }

    /** Queries the network using the current input set of the given Construct, however, an array of legs is passed that signifies whether or not each individual leg is to be charged and every input queried to all axon_hillocks/legs set to fire. 

        query_Given_Legs CONSTRUCT_ID LEG_COUNT LGS 
    \param int CONSTRUCT_ID The construct that encapsulates the state space to search.
    \param int LEG_COUNT The number of legs you are passing.
    \param bool LEGS  The array of legs as boolean values used to determine whether or not to charge nodes connected on that axon_hillock/dendrite_index.
    \retval None This function doesn't return any values, the data resulting from this function is handled through traces.

    This function works by taking this set of 'legs' which is a boolean array. It then takes every input of the construct and puts them in a pool of unorganized nodes. It then steps through the boolean array checking whether that step needs to be charged or not. If it needs charged the program then steps through every node in the pool having it charge any axons on the current index, which would be the axon_hillock to the node.

    So if we are on the second leg in the array then we would step through each node, go check the axon_hillock population count, and if any are found we charge them into the charging buffers. 
    
    This means you will search for the set of inputs you give, not in order but individually, on the legs you specify.

    Example Usage:

    - Example 1.

    In this example we'll use the scenario of running a game server such as Minecraft and needing to track down some hackers. You have the chatlogs which are immense, and you have the user account database. One of your mods remembers that the hacker had an x or z in the first character or four of their name.

    Using this function we can search for { 'X', 'Z', 'x','z' } on the first 4 characters of each name. So to start we need to encode the database of names by formatting them with the set_Input command:

        register_Construct Many_To_One ExaCon /end/ encode 0
        set_Input 0 PotatoChipCrunch /end/ encode 0
        set_Input 0 NotARealIdentity /end/ encode 0
        set_Input 0 BabyDollXOXO /end/ encode 0
        set_Input 0 SpaceCowboy /end/ encode 0
        set_Input 0 NinjaGuy22 /end/ encode 0
        set_Input 0 ElectroExile /end/ encode 0
        set_Input 0 ArcaneAdventurer /end/ encode 0
        set_Input 0 Xx_KawaiiAngel_xX /end/ encode 0
        set_Input 0 FireDragon99 /end/ encode 0
        set_Input 0 ProUser2024 /end/ encode 0
        set_Input 0 MySpaceStar /end/ encode 0
        set_Input 0 RealNameJane /end/ encode 0
        set_Input 0 xXx_P0t4t0Ch1p_xXx /end/ encode 0
        set_Input 0 PixelPilgrim /end/ encode 0
        set_Input 0 d4t4b4s3Qu33n /end/ encode 0
        set_Input 0 NeonNomad /end/ encode 0
        set_Input 0 ByteBandit23 /end/ encode 0
        set_Input 0 DataMinerX /end/ encode 0
        set_Input 0 -R4v3n-Cl4w- /end/ encode 0
        set_Input 0 G1tGuD /end/ encode 0
        set_Input 0 d00d!3_H4xx0r /end/ encode 0
        set_Input 0 -MysticMoon- /end/ encode 0
        set_Input 0 Vyrail_Vyxian /end/ encode 0
        set_Input 0 xX_D@rk_P@ssw0rd_Xx /end/ encode 0
        set_Input 0 8BitCh4rm3r /end/ encode 0
        set_Input 0 $p4c3C@d3t /end/ encode 0
        set_Input 0 W1z4rd0f0s /end/ encode 0
        set_Input 0 C0mm@nd_L1n3_H3ro /end/ encode 0
        set_Input 0 ScriptKiddieSupreme /end/ encode 0

    Now that we have the database to search we can formulate the input query, punch it, and gather the output.

        set_Input 0 XZxz /end/
        query_Given_Legs 0 4 1 1 1 1
        gather_Output 0

    Output:

    Contents of "./Output/ExaCon.Output.ssv":

        44 20 2 17 Xx_KawaiiAngel_xX
        59 30 2 18 xXx_P0t4t0Ch1p_xXx <- Notice how this one had 3 matches to the character pool 'XZxz' in the searched string "xXx_"
        78 20 2 19 xX_D@rk_P@ssw0rd_Xx
        60 10 2 12 PixelPilgrim
        86 10 2 10 W1z4rd0f0s

    - Example 2.

    Building on the previous example we have another mod say he saw one of them with a '-' or '_' so we'll expand the search:

        set_Input 0 Xx-_ /end/
        query_Given_Legs 0 4 1 1 1 1
        output_Newline 0
        gather_Output 0

    Output:

    Contents of "./Output/ExaCon.Output.ssv":

        44 30 2 17 Xx_KawaiiAngel_xX
        59 40 2 18 xXx_P0t4t0Ch1p_xXx <- With the addition of the '_' to the pool of states we find that this "xXx_" now has a match on all characters evaluated. Making the charge 40.
        78 30 2 19 xX_D@rk_P@ssw0rd_Xx
        60 10 2 12 PixelPilgrim
        68 10 2 12 -R4v3n-Cl4w-
        73 10 2 12 -MysticMoon-

    - Example 3.

    If we examine the last example we find the charges are dependent on the number of matches. 
    
    The query treats the input as a pool of states, rather than an input string. This means that an input with repeated characters or states will evalaute them each time it encounters them.

    Using this you can "weigh" inputs manually. If we want to weight the '-' character we cna input it multiple times like this:

        set_Input 0 Xx-----_ /end/ <- We input the '-' character 5 times.
        output_Newline 0
        query_Given_Legs 0 4 1 1 1 1
        gather_Output 0

    Output:

    Contents of "./Output/ExaCon.Output.ssv":

        44 30 2 17 Xx_KawaiiAngel_xX
        59 40 2 18 xXx_P0t4t0Ch1p_xXx
        78 30 2 19 xX_D@rk_P@ssw0rd_Xx
        60 10 2 12 PixelPilgrim
        68 50 2 12 -R4v3n-Cl4w-
        73 50 2 12 -MysticMoon-

    Notice how the last two have charges of 50 vs the previous example where they had 10? With Many_To_One constructs the upper tier node charge is directly proportionate to how many inputs are linked to it (and modified by weights and such but you get the point).

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void query_Given_Legs(std::ifstream* p_File)
    {
        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        int tmp_Count = 0;

        *p_File >> tmp_Count;

        std::cout << " " << tmp_Count << " |";

        int* tmp_Legs = NULL;
        tmp_Legs = new int[tmp_Count];

        for (int cou_Index = 0; cou_Index < tmp_Count; cou_Index++)
        {
            *p_File >> tmp_Legs[cou_Index];

            std::cout << " " << tmp_Legs[cou_Index] << " |";
        }

        API.query_Given_Legs(tmp_Construct, tmp_Count, tmp_Legs);

        if (tmp_Legs != NULL) { delete [] tmp_Legs; tmp_Legs = NULL; }

        //std::cout << " [|x|]";
    }


    //Disabled this doxygen for the moment, I suspect this function was accidentally brought to the surface while high.
    /* This allows for passing unordered sets of node IDs to be charged. 

        submit_Set CONSTRUCT_ID COUNT INPUT_UINT 
    \param int CONSTRUCT_ID The construct who's charging buffer and output will be used.
    \param COUNT The number of node IDs (NIDs) being passed.
    \param INPUT_UINT  The array of NIDs to charge.
    \retval None This function doesn't return any values.

    This function takes a set of NIDs and then directly submits them to the charging buffers, no input, query, scaffold, etc. If you have the ID of the node(s) and want to directly charge them you can use this function.

    Example Usage:

    To start with we encode a sample dataset, output the node network to get the node IDs to use, and then we can submit_Nodes and gather the output.

    Output:

        output

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void submit_Set(std::ifstream* p_File)
    {
        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        int tmp_Count = 0;

        *p_File >> tmp_Count;

        std::cout << " " << tmp_Count << " |";

        uint64_t* tmp_Input = NULL;
        tmp_Input = new uint64_t[tmp_Count];

        for (int cou_Index = 0; cou_Index < tmp_Count; cou_Index++)
        {
            *p_File >> tmp_Input[cou_Index];

            std::cout << " " << tmp_Input[cou_Index] << " |";
        }

        API.submit_Set(tmp_Construct, tmp_Count, tmp_Input);

        if (tmp_Input != NULL) { delete[] tmp_Input; tmp_Input = NULL; }

        //std::cout << " [|x|]";
    }


    /** Gets the treetop node for a given construct and puts it in the output file for that construct.

        get_Treetop CONSTRUCT_ID

    \param CONSTRUCT_ID The construct you want the treetop from.
    \retval uint64_t Treetop  The treetop is output to the return.ssv file.

    This returns the treetop node for a given construct and outputs it to the RETURN_FILE. If you instead want it to output to the construct output then you use gather_Output_Node instead of this function.

    This treetop is the top node in the current CAN Scaffold. So if you encode "yargi blargi" then this treetop node in a Many_To_One construct would be on tier [1] of the CAN Scaffold at index [0] that represents "yargi blargi".

    Example Usage:

    First we encode a string into a Many_To_One:

        register_Construct Many_To_One ExaCon
        set_Input 0 Pull Your Circuit Breaker /end/
        encode 0

    Then we can get output the scaffold so you can see it, and then get the treetop:

        output_Scaffold 0
        get_Treetop 0

    Output:

         --==   CAN_Scaffold   ==--
        <- Tier[0] ->
          [0]  <> 1
          [1]  <> 2
          [2]  <> 3
          [3]  <> 3
          [4]  <> 4
          [5]  <> 5
          [6]  <> 6
          [7]  <> 2
          [8]  <> 7
          [9]  <> 4
          [10]  <> 8
          [11]  <> 9
          [12]  <> 7
          [13]  <> 10
          [14]  <> 2
          [15]  <> 9
          [16]  <> 11
          [17]  <> 4
          [18]  <> 12
          [19]  <> 7
          [20]  <> 13
          [21]  <> 14
          [22]  <> 15
          [23]  <> 13
          [24]  <> 7
        <- Tier[1] ->
          [0]  <> 16

    Contents of "./Output/returned.ssv":

        16

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - This function is for prototyping for those planning on converting to C++ data handling logic rather than using output.ssv.
    */
    uint64_t get_Treetop_NID(std::ifstream* p_File)
    {
        std::cout << "\n --> get_Treetop_NID CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        uint64_t tmp_Return_Node = API.get_Treetop_NID(tmp_Construct);

        write_to_output(RETURN_FILE, tmp_Return_Node);

        return tmp_Return_Node;

        //std::cout << " [|x|]";
    }

    void write_Treetop_NID_To_Other_Input(std::ifstream* p_File)
    {
        std::cout << "\n --> write_Treetop_NID_To_Other_Input CONSTRUCT_ID_FROM CONSTRUCT_ID_TO |";

        std::string tmp_Construct_From = "";
        std::string tmp_Construct_To = "";

        *p_File >> tmp_Construct_From;

        std::cout << " " << tmp_Construct_From << " |";

        *p_File >> tmp_Construct_To;

        std::cout << " " << tmp_Construct_To << " |";

        API.write_Treetop_NID_To_Other_Input(tmp_Construct_From, tmp_Construct_To);
    }

    void chrono_Shift(std::ifstream* p_File)
    {
        std::cout << "\n --> chrono_Shift CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.chrono_Shift(tmp_Construct);
    }

    void add_Chrono(std::ifstream* p_File)
    {
        std::cout << "\n --> add_Chrono CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        uint64_t tmp_Chrono = 0;

        *p_File >> tmp_Chrono;

        std::cout << " " << tmp_Chrono << " |";

        API.add_Chrono(tmp_Construct, tmp_Chrono);
    }


    /** Gets a single trace from a given node, puts it in the output file for the given construct.

        gather_Given_Trace CONSTRUCT_ID NID

    \param CONSTRUCT_ID This is the ID of construct who's output file will have the trace written to it.
    \param NID The ID of the node from which the pattern, or trace, will be extracted usin the backpropagation functions.
    \retval None This function doesn't return any values, output is done through the output file of the given construct.

    Searches the network for the given NID and if found it outputs the pattern represented by the node to the output file of the specified construct.

    This is used when you want to retrieve encoded information.

    Example Usage:

    First we encode some information.

        register_Construct Many_To_One ExaCon
        set_Input 0 THE GAME /end/
        encode 0
        output_Scaffold 0

    Output:

         --==   CAN_Scaffold   ==--
        <- Tier[0] ->
          [0]  <> 1
          [1]  <> 2
          [2]  <> 3
          [3]  <> 4
          [4]  <> 5
          [5]  <> 6
          [6]  <> 7
          [7]  <> 3
        <- Tier[1] ->
          [0]  <> 8

    Then we can extract it by using the NID from above:

        gather_Given_Trace 0 8

    Contents of "./Output/ExaCon.Output.ssv":

        8 0 2 8 THE GAME

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void gather_Given_Trace(std::ifstream* p_File)
    {
        std::cout << "\n| gather_Given_Trace   CONSTRUCT_ID   NID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";
        
        int tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";

        API.gather_Given_Trace(tmp_Construct, tmp_NID);

        //std::cout << " [|x|]";
    }



    void write_Given_Pattern_As_Number(std::ifstream* p_File)
    {
        std::cout << "\n| write_Given_Pattern_As_Number |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " CONSTRUCT_ID " << tmp_Construct << " |";
        
        int tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " NID " << tmp_NID << " |";

        API.write_Given_Pattern_As_Number(tmp_Construct, tmp_NID);

        //std::cout << " [|x|]";
    }


    //---==  gather_All_Traces [CONSTRUCT]  ==---//
    //
    /** Gathers all the traces through a given construct.

        gather_All_Traces CONSTRUCT_ID
    \param CONSTRUCT_ID This is the construct who's output file will be used to store the results of the query.
    \retval None This function doesn't return any values, it stores the results in the output file of the given construct.

    This iterates over the network and calls gather_Given_Trace for every node.

    Example Usage:

    We encode some data into our newly minted construct, and then get the traces from it:

        register_Construct Many_To_One ExaCon
        set_Input 0 ABRACADABRA /end/ encode 0
        set_Input 0 FIREBALL /end/ encode 0
        gather_All_Traces 0

    Output:

    Contents of "./Output/ExaCon.Output.ssv":

        0 0 1 1
        1 0 7 1 A
        2 0 4 1 B
        3 0 4 1 R
        4 0 2 1 C
        5 0 2 1 D
        6 0 2 11 ABRACADABRA
        7 0 2 1 F
        8 0 2 1 I
        9 0 2 1 E
        10 0 3 1 L
        11 0 2 8 FIREBALL

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void gather_All_Traces(std::ifstream* p_File)
    {
        std::cout << "\n --> gather_All_Traces   CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.gather_All_Traces(tmp_Construct);

        //std::cout << " [|x|]";
    }


    void gather_All_Traces_uint(std::ifstream* p_File)
    {
        std::cout << "\n --> gather_All_Traces_uint   CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.gather_All_Traces_uint(tmp_Construct);

        //std::cout << " [|x|]";
    }


    /** Used to wipe the input array of a given construct.

        reset_Input CONSTRUCT_ID
    \param CONSTRUCT_ID The construct who's input we are to wipe.
    \retval None This function doesn't return any values.

    For oopsies and when you need to prep a construct for new input. 

    Example Usage:

    Let's setup a construct, set the input, output the input (lel), wipe the input, and output it again to confirm:

        register_Construct Many_To_One ExaCon
        set_Input 0 This is amazing wheee /end/ encode 0
        output_Input 0

    Output:

         --==   CAN_Input   ==--
        [0] > T <
        [1] > h <
        [2] > i <
        [3] > s <
        [4] >   <
        [5] > i <
        [6] > s <
        [7] >   <
        [8] > a <
        [9] > m <
        [10] > a <
        [11] > z <
        [12] > i <
        [13] > n <
        [14] > g <
        [15] >   <
        [16] > w <
        [17] > h <
        [18] > e <
        [19] > e <
        [20] > e <

    Now wipe the output and check it again!:

        wipe_Input 0
        output_Input 0

    Output:

        --==   CAN_Input   ==--

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void reset_Input(std::ifstream* p_File)
    {
        std::cout << "\n --> reset_Input CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.reset_Input(tmp_Construct);

        //std::cout << " [|x|]";
    }

    void reset_Output(std::ifstream* p_File)
    {
        std::cout << "\n --> reset_Output CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.reset_Output(tmp_Construct);

        //std::cout << " [|x|]";
    }


    /** Sets the index for the given Construct state_Node_Tree

        set_State_Nodes_Index CONSTRUCT_ID INDEX
    \param CONSTRUCT_ID The construct who's state node tree you are setting.
    \param INDEX The index you are setting the state tree to.
    \retval None This function doesn't return any values.

    Sets the index for the given Construct state_Node_Tree in the c_Node_Network::State_Nodes  fractal state tree array. This keeps the state spaces separate and discrete. Most networks you don't want to share state nodes. Some you do, that's where this function comes in, allows you to point a construct to the state tree you want.

    It is important to remember that the state tree indices and the constructs don't line up. Construct[1] likely doesn't have State_Tree[1]!

    Example Usage:

    Create 2 constructs to work with, we'll be pointing ConExa's State Tree at ExaCon's State Tree:

        register_Construct Many_To_One ExaCon
        register_Construct Many_To_One ConExa

    Set the ConExa to ExaCon:

        set_State_Nodes_Index 1 1

    Encode a string into ExaCon & output the scaffold, then encode a similar one in ConExa & output the scaffold. Comparing these you can see the shared nodes underneath.

        set_Input 0 Control_String Variable /end/
        encode 0
        output_Scaffold 0

        set_Input 1 Control_String New_Data /end/
        encode 1
        output_Scaffold 1

    All constructs share the underlying node network, so those NIDs are unique to the entire network, not just a single construct. This means when you see the same node in both scaffolds you are seeing the exact same node.

    Output:

    Construct[0]:

         --==   CAN_Scaffold   ==--
        <- Tier[0] ->
          [0]  <> 1
          [1]  <> 2
          [2]  <> 3
          [3]  <> 4
          [4]  <> 5
          [5]  <> 2
          [6]  <> 6
          [7]  <> 7
          [8]  <> 8
          [9]  <> 4
          [10]  <> 5
          [11]  <> 9
          [12]  <> 3
          [13]  <> 10
          [14]  <> 11
          [15]  <> 12
          [16]  <> 13
          [17]  <> 5
          [18]  <> 9
          [19]  <> 13
          [20]  <> 14
          [21]  <> 6
          [22]  <> 15
        <- Tier[1] ->
          [0]  <> 16

    Construct[1]:

         --==   CAN_Scaffold   ==--
        <- Tier[0] ->
          [0]  <> 1
          [1]  <> 2
          [2]  <> 3
          [3]  <> 4
          [4]  <> 5
          [5]  <> 2
          [6]  <> 6
          [7]  <> 7
          [8]  <> 8
          [9]  <> 4
          [10]  <> 5
          [11]  <> 9
          [12]  <> 3
          [13]  <> 10
          [14]  <> 11
          [15]  <> 17
          [16]  <> 15
          [17]  <> 18
          [18]  <> 7
          [19]  <> 19
          [20]  <> 13
          [21]  <> 4
          [22]  <> 13
        <- Tier[1] ->
          [0]  <> 20

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - State tree indices and the constructs don't line up. Construct[1] likely doesn't have State_Tree[1]!
    */
    void set_State_Nodes_Index(std::ifstream* p_File)
    {
        std::cout << "\n --> set_State_Nodes_Index CONSTRUCT_ID INDEX |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";
        
        int tmp_Index = 0;

        *p_File >> tmp_Index;

        std::cout << " " << tmp_Index << " |";

        API.set_State_Nodes_Index(tmp_Construct, tmp_Index);

        //std::cout << " [|x|]";
    }


    //    ---==  set_input [CONSTRUCT_ID] [INPUT_STRING]  ==---
    /** This command sets the input of a given construct to the given input string.

        set_input CONSTRUCT_ID INPUT_STRING
    \param CONSTRUCT_ID The construct who's input you wish to set.
    \param INPUT_STRING The input string, either terminates from endl, or the token '/end/'
    \retval None This function doesn't return any values.

    The sub-string '/end/' can be used as a string terminator. This is useful when you want to string multiple commands together, otherwise anything after the input command would be considered input. 'set_Input 0 Example_Text encode 0' would end up setting construct [0]'s input to 'Example_Text encode 0' and nothing would be encoded.

    Use this function to set the input of the construct you'll be either encoding or evaluating, or both.
    
    Use characters or numbers that you know won't appear in the dataset to create a "greenscreen" over your input for the network. This is due to the NULLCAN, where a node that isn't found is set to NULL on the CAN scaffold, and subsequently is skipped during charging as there is nothing to charge. Alternatively just use the query_Given_Legs command.
    
    Whitespace is weird when doing text input through set_Input! It reads from the text file using "file >> tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action.

    Example Usage:

    - Example 1.

    We'll register a construct, then set the input, then output the input so we can see it.

        register_Construct Many_To_One ExaCon
        set_Input 0 Careful lads, I think there's a sni- /end/
        output_Input 0

    Output:

         --==   CAN_Input   ==--
        [0] > C <
        [1] > a <
        [2] > r <
        [3] > e <
        [4] > f <
        [5] > u <
        [6] > l <
        [7] >   <
        [8] > l <
        [9] > a <
        [10] > d <
        [11] > s <
        [12] > , <
        [13] >   <
        [14] > I <
        [15] >   <
        [16] > t <
        [17] > h <
        [18] > i <
        [19] > n <
        [20] > k <
        [21] >   <
        [22] > t <
        [23] > h <
        [24] > e <
        [25] > r <
        [26] > e <
        [27] > ' <
        [28] > s <
        [29] >   <
        [30] > a <
        [31] >   <
        [32] > s <
        [33] > n <
        [34] > i <
        [35] > - <

    - Example 2.

    We're going to show what happens if you forget the '/end/' on a compound statement with set_Input in it.

        register_Construct Many_To_One ExaCon
        set_Input 0 Example_Text encode 0
        output_Input 0

    Gives the output:

         --==   CAN_Input   ==--
        [0] > E <
        [1] > x <
        [2] > a <
        [3] > m <
        [4] > p <
        [5] > l <
        [6] > e <
        [7] > _ <
        [8] > T <
        [9] > e <
        [10] > x <
        [11] > t <
        [12] >   <
        [13] > e <
        [14] > n <
        [15] > c <
        [16] > o <
        [17] > d <
        [18] > e <
        [19] >   <
        [20] > 0 <

    Whereas including the '/end/' closing tag:

        set_Input 0 Example_Text /end/ encode 0
        output_Input 0

    Gives the output:

         --==   CAN_Input   ==--
        [0] > E <
        [1] > x <
        [2] > a <
        [3] > m <
        [4] > p <
        [5] > l <
        [6] > e <
        [7] > _ <
        [8] > T <
        [9] > e <
        [10] > x <
        [11] > t <

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int set_Input(std::ifstream* p_File)
    {
        std::cout << "\n --> set_Input CONSTRUCT_ID INPUT |";

        std::string tmp_In = "";
        std::string tmp_In_Full = "";
        int tmp_Count = 0;

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        bool flg_Gather_Input = true;

        while (flg_Gather_Input)
        {
            tmp_In = "";
            *p_File >> tmp_In;

            std::cout << " " << tmp_In;

            if (tmp_In == "/end/")
            {
                flg_Gather_Input = false;
                continue;
            }

            if (tmp_In != "")
            {

                tmp_Count++;

                if (tmp_In_Full != "")
                {
                    tmp_In_Full = tmp_In_Full + " " + tmp_In;
                }
                else
                {
                    tmp_In_Full = tmp_In;
                }
            }

            if (flg_Gather_Input)
            {
                flg_Gather_Input = (!p_File->eof());
            }
        }
        API.set_Input(tmp_Construct, tmp_In_Full);

        //std::cout << " [|x|]";

        return 1;
    }

    /** Sets the input of a given construct to the given array of uint64_t values.

        set_Input_uint CONSTRUCT_ID COUNT INPUT 

    \param CONSTRUCT_ID The construct who's input will be getting set.
    \param COUNT The number of elements to expect in the Input  array.
    \param INPUT  The uint64_t array that will be read into the input of the given construct.
    \retval None This function doesn't return any values.

    This function is used when you have arrays of unsigned integer values to work with. Used for handling nodes with multi-sensory constructs and others that use nodes as their I/O states.

    Example Usage:

    - Example 1.

    Imagine we have an array of unsigned integers representing the number of deaths a team has in a video game. Say 4 players:

        register_Construct Many_To_One ExaCon
        set_Input_uint 0 4 3 10 12 87
        output_Input_uint 0

    Output:

         --==   CAN_Input   ==--
        [0] > 3 <
        [1] > 10 <
        [2] > 12 <
        [3] > 87 <

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void set_Input_uint(std::ifstream* p_File)
    {
        std::cout << "\n --> set_Input_uint CONSTRUCT_ID COUNT INPUT  |";

        int tmp_Depth = 0;
        uint64_t* tmp_In_Full = NULL;

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        //Get the depth
        *p_File >> tmp_Depth;

        std::cout << " " << tmp_Depth << " |";

        tmp_In_Full = new uint64_t[tmp_Depth];

        for (int cou_Index = 0; cou_Index < tmp_Depth; cou_Index++)
        {
            tmp_In_Full[cou_Index] = 0;
            *p_File >> tmp_In_Full[cou_Index];

            std::cout << " " << tmp_In_Full[cou_Index] << " |";
        }

        API.set_Input_uint(tmp_Construct, tmp_Depth, tmp_In_Full);

        //std::cout << " [|x|]";
    }


    void set_2D_Input_uint(std::ifstream* p_File)
    {
        std::cout << "\n --> set_2D_Input_uint |";

        int tmp_X_Depth = 0;
        int tmp_Y_Depth = 0;
        uint64_t** tmp_In_Full = NULL;

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " CONSTRUCT_ID " << tmp_Construct << " |";

        //Get the depth
        *p_File >> tmp_X_Depth;

        std::cout << " X_COUNT " << tmp_X_Depth << " |";

        //Get the depth
        *p_File >> tmp_Y_Depth;

        std::cout << " Y_COUNT " << tmp_Y_Depth << " |";

        tmp_In_Full = new uint64_t*[tmp_X_Depth];
        for (int cou_X = 0; cou_X < tmp_X_Depth; cou_X++)
        {
            tmp_In_Full[cou_X] = new uint64_t[tmp_Y_Depth];

            for (int cou_Y = 0; cou_Y < tmp_Y_Depth; cou_Y++)
            {
                tmp_In_Full[cou_X][cou_Y] = 0;
                *p_File >> tmp_In_Full[cou_X][cou_Y];

                //---std::cout << " " << tmp_In_Full[cou_X][cou_Y] << " |";

                //std::cout << "\n I - [ " << cou_X << " ][ " << cou_Y << " ]: >" << tmp_In_Full[cou_X][cou_Y] << "<";
            }
        }

        API.set_2D_Input_uint(tmp_Construct, tmp_X_Depth, tmp_Y_Depth, tmp_In_Full);

        //std::cout << " [|x|]";
    }


    void set_3D_Input_uint(std::ifstream* p_File)
    {
        std::cout << "\n --> set_3D_Input_uint |";

        int tmp_X_Depth = 0;
        int tmp_Y_Depth = 0;
        int tmp_Z_Depth = 0;
        uint64_t*** tmp_In_Full = NULL;

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " Construct " << tmp_Construct << " |";

        //Get the depth
        *p_File >> tmp_X_Depth;

        std::cout << " X_Depth " << tmp_X_Depth << " |";

        //Get the depth
        *p_File >> tmp_Y_Depth;

        std::cout << " Y_Depth " << tmp_Y_Depth << " |";

        //Get the depth
        *p_File >> tmp_Z_Depth;

        std::cout << " Z_Depth " << tmp_Z_Depth << " |";

        tmp_In_Full = new uint64_t**[tmp_X_Depth];
        for (int cou_X = 0; cou_X < tmp_X_Depth; cou_X++)
        {
            tmp_In_Full[cou_X] = new uint64_t*[tmp_Y_Depth];

            for (int cou_Y = 0; cou_Y < tmp_Y_Depth; cou_Y++)
            {
                tmp_In_Full[cou_X][cou_Y] = new uint64_t [tmp_Z_Depth];

                for (int cou_Z = 0; cou_Z < tmp_Z_Depth; cou_Z++)
                {
                    tmp_In_Full[cou_X][cou_Y][cou_Z] = 0;
                    *p_File >> tmp_In_Full[cou_X][cou_Y][cou_Z];

                    //std::cout << " " << tmp_In_Full[cou_X][cou_Y][cou_Z] << " |";

                    //std::cout << "\n I - [ " << cou_X << " ][ " << cou_Y << " ][ " << cou_Z << " ]: >" << tmp_In_Full[cou_X][cou_Y][cou_Z] << "<";
                }
            }
        }

        API.set_3D_Input_uint(tmp_Construct, tmp_X_Depth, tmp_Y_Depth, tmp_Z_Depth, tmp_In_Full);

        //std::cout << " [|x|]";
    }




    /** Outputs the scaffold as node IDs.

        output_Scaffold CONSTRUCT_ID
    \param CONSTRUCT_ID The ID of the construct who's scaffold we'll be outputting.
    \retval None This function doesn't return any values.

    When a trace, or input pattern, is encoded into the network we use a current active node scaffold (CAN) to do so. This CAN Scaffold can be output for human analysis, this splays the symbol open to your gaze, all sub-symbols and bound states there to play with.

    Example Usage:

    We'll encode a string into a many to one and output the scaffold:

        register_Construct Many_To_One ExaCon
        set_Input 0 supersymbol
        encode 0
        output_Scaffold 0

    Output:

         --==   CAN_Scaffold   ==--
        <- Tier[0] ->
          [0]  <> 1
          [1]  <> 2
          [2]  <> 3
          [3]  <> 4
          [4]  <> 5
          [5]  <> 1
          [6]  <> 6
          [7]  <> 7
          [8]  <> 8
          [9]  <> 9
          [10]  <> 10
        <- Tier[1] ->
          [0]  <> 11

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void output_Scaffold(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Scaffold CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        std::cout << "\n";
        API.output_Scaffold(tmp_Construct);
        std::cout << "\n";

        //std::cout << " [|x|]";
    }


    /** Outputs the input of the given construct to the console.

        output_Input CONSTRUCT_ID

    \param CONSTRUCT_ID The construct who's input we shall output.
    \retval None This function doesn't return any values.

    Pretty simple, outputs the input array of the given construct to the console.

    Example Usage:

    Let us create a construct, then set the input, then output the input which shall be 'kaput'.

        register_Construct Many_To_One ExaCon
        set_Input 0 kaput /end/
        output_Input 0

    Output:

         --==   CAN_Input   ==-
        [0] > k <
        [1] > a <
        [2] > p <
        [3] > u <
        [4] > t <

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void output_Input(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Input CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.output_Input(tmp_Construct);

        //std::cout << " [|x|]";
    }


    /** Outputs the input of the given construct to the console, but as uint.

        output_Input_uint CONSTRUCT_ID

    \param CONSTRUCT_ID The construct who's input we shall output.
    \retval None This function doesn't return any values.

    Outputs the input array of the given construct to the console with the values displayed as uint64_t.

    Example Usage:

    Let us create a construct, then set the input, then output the input:

        register_Construct Many_To_One ExaCon
        set_Input_uint 0 3 8999 9000 9001
        output_Input_uint 0

    Output:

         --==   CAN_Input   ==--
        [0] > 8999 <
        [1] > 9000 <
        [2] > 9001 <

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void output_Input_uint(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Input_uint CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.output_Input_uint(tmp_Construct);
    }


    /** The output trace set is output.

        output_Output CONSTRUCT_ID

    \param CONSTRUCT_ID This is the construct which has the output trace set output to the console.
    \retval None This function doesn't return any values.

    Takes the current output traces from a given construct and outputs them to the console. So after a query this allows you to output the results.

    Example Usage:

    Here we'll register a construct, encode two input sets, query it, and then finally show the useage of this function.

    Register, encode:

        register_Construct Many_To_One ExaCon
        set_Input 0 01234 /end/
        encode 0
        set_Input 0 56789 /end/
        encode 0

    Set input, query, then show this functions TRUE POWER:

        set_Input 0 45 /end/
        query 0
        output_Output 0

    Output:

         --==   Output_Traces [2]   ==--
         Trace[0]:  Pat_Depth: 5
        --  Charge: 10 RC: 2 Treetop: 6 Pattern:  0 1 2 3 4
         Trace[1]:  Pat_Depth: 5
        --  Charge: 10 RC: 2 Treetop: 12 Pattern:  5 6 7 8 9
          --==   /Output_Traces   ==--

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void output_Output(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Output |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.output_Output(tmp_Construct);
    }


    /** The output trace set is output as uint64_t.

        output_Output_uint CONSTRUCT_ID

    \param CONSTRUCT_ID This is the construct which has the output trace set output to the console with the values displayed as uint64_t.
    \retval None This function doesn't return any values.

    Takes the current output traces from a given construct and outputs them to the console. So after a query this allows you to output the results. The results are displayed as uint64_t and not string.

    Example Usage:

    Here we'll register a construct, encode two uint64_t input arrays, query it, and then finally show the useage of this function.

    Register, encode:

        register_Construct Many_To_One ExaCon
        set_Input_uint 0 5 0 1 2 3 4
        encode 0
        set_Input_uint 0 5 5 6 7 8 9
        encode 0

    Set input, query, then show this functions TRUE POWER:

        set_Input_uint 0 3 4 5 6
        query 0
        output_Output_uint 0

    Output:

         --==   Output_Traces [2]   ==--
         Trace[0]:  Pat_Depth: 5
        --  Charge: 10 RC: 2 Treetop: 6 Pattern:  0 1 2 3 4
         Trace[1]:  Pat_Depth: 5
        --  Charge: 20 RC: 2 Treetop: 12 Pattern:  5 6 7 8 9 <- Notice this one has a charge of 20, otherwise it looks the same as the string query.

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void output_Output_uint(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Output_uint |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.output_Output_uint(tmp_Construct);
    }


    /** Outputs the scaffold as characters typecase from the ID.

        output_Scaffold_Char CONSTRUCT_ID
    \param CONSTRUCT_ID The ID of the construct who's scaffold we'll be outputting.
    \retval None This function doesn't return any values.

    When a trace, or input pattern, is encoded into the network we use a current active node scaffold (CAN) to do so. This CAN Scaffold can be output for human analysis, each node represented as a 'random' character, making it so that at a glance you can tell variance in node structures, and changes if watching a life network.

    Each address is typecast to a char to give a pseudo-unique look to each node. For monke brain.

    Example Usage:

    We'll encode a string into a many to one and output the scaffold:

        register_Construct Many_To_One ExaCon
        set_Input 0 supersymbol
        encode 0
        output_Scaffold_Char 0

    Output:

         - [ 0 ]: output_Scaffold_Char

        (0000014828425EC0)
        @0p
        

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    void output_Scaffold_Char(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Scaffold_Char |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        std::cout << "\n";
        API.output_Scaffold_Char(tmp_Construct);
        std::cout << "\n";

        //std::cout << " [|x|]";
    }

    void output_Scaffold_Symbols(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Scaffold_Symbols |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        std::cout << "\n";
        API.output_Scaffold_Symbols(tmp_Construct);
        std::cout << "\n";

        //std::cout << " [|x|]";
    }

    void output_Scaffold_Symbols_uint(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Scaffold_Symbols_uint |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        std::cout << "\n";
        API.output_Scaffold_Symbols_uint(tmp_Construct);
        std::cout << "\n";

        //std::cout << " [|x|]";
    }





    //      ---====================---
    //     ---======================---
    //    ---========================---
    //   ---==========================---
    //  ---==   NT4 specific hooks   ==---
    //   ---==========================---
    //    ---========================---
    //     ---======================---
    //      ---====================---



    //    ---======================================---
    //   ---========================================---
    //  ---==   Used to register new constructs.   ==---
    //   ---========================================---
    //    ---======================================---


    /** Registers a Construct with the neural net engine of the given architecture and name desired.

        register_Construct TYPE NAME

    \param TYPE The node network architecture, Many_To_One, pyramidal, etc.
    \retval int Outputs the ID of the newly constructed construct to "./Output/returns.ssv".

    Registers a construct with the engine. 
    This calls "register_Construct" with the c_Node_Network object NNet in the c_Construct, which:
    - Creates an instance of a CAN scaffold of the type specified.
    - Creates a fractal state tree for the construct.
    - The name is registered in an array.
    - These are all encapsulated in a "construct".

    Currently these are the types of constructs available:
    - Many_To_One

    Many_To_One:

        This type is only 2 tiers, the state tier, and one treetop node per trace. You encode all the state nodes, then submit them as one to "get_Upper_Tier_Node".

    Example Usage:

    We'll register 3 constructs, then output the constructs:

        register_Construct Many_To_One ExaCon
        register_Construct Many_To_One ConExa
        register_Construct Many_To_One ExaMSC

        output_constructs

    Output:

        __COMMAND__| output_constructs |
        [0]: ExaCon
        [1]: ConExa
        [2]: ExaMSC

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int register_Construct(std::ifstream* p_File)
    {
        std::cout << "\n --> register_Construct |";

        //int add_Construct(std::string p_Construct_Name)

        std::string tmp_Construct_Type = "";

        *p_File >> tmp_Construct_Type;

        std::cout << " " << tmp_Construct_Type << " |";

        std::string tmp_Construct_Name = "";

        *p_File >> tmp_Construct_Name;

        std::cout << " " << tmp_Construct_Name << " |";

        return API.register_Construct(tmp_Construct_Type, tmp_Construct_Name);

        //std::cout << " [|x|]";
    }



    //    ---=====================---
    //   ---=======================---
    //  ---==   Input handling.   ==---
    //   ---=======================---
    //    ---=====================---

    /** Loads the input file associated with the given construct into the input array.

        load_Input CONSTRUCT_ID
        
    \param CONSTRUCT_ID This is the construct for whom the input will be loaded.
    \retval None This function doesn't return any values.

    Be warned, this function treats the entire file as one input, it ignored newlines. Iterating through it loads each whitespace separated token into a string, "tmp_Full = tmp_Full + ' ' + tmp_Current_Token"

    Example Usage:

    To start with we register our construct:

        register_Construct Many_To_One ExaCon

    We create the input file for it and put our sample data into the file:

    Contents of "./Input/ExaCon.Input.ssv":

        yo ho ho
        and
        a
        bottle
        of
        rum

    Now using load_Input we can load this into the construct:

        load_Input 0
    
    And we can see the results:

        | load_Input |
         - [ 0 ]: yo
         - [ 1 ]: ho
         - [ 2 ]: ho
         - [ 3 ]: and
         - [ 4 ]: a
         - [ 5 ]: bottle
         - [ 6 ]: of
         - [ 7 ]: rum

    You can see how it treats the tokens with different kinds of whitespace, newlines and spaces treated the same. (Looking at "yo ho ho")

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int load_Input(std::ifstream* p_File)
    {
        std::cout << "\n --> load_Input |";

        //Outputs the input for the Construct.
        //output_Input(int p_Construct)

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        return API.load_Input(tmp_Construct);

        //std::cout << " [|x|]";
    }

    /** Loads the input file associated with the given construct into the input array as uint.

        load_Input_uint CONSTRUCT_ID
        
    \param CONSTRUCT_ID This is the construct for whom the input will be loaded.
    \retval None This function doesn't return any values.

    The first number in the input file should be the count of elements. The function will create a temporary array to hold these and load them.

    Example Usage:

    To start with we register our construct:

        register_Construct Many_To_One ExaCon

    We create the input file for it and put our sample data into the file:

    Contents of "./Input/ExaCon.Input.ssv":

        4 10 20
        20 40

    Now using load_Input we can load this into the construct:

        load_Input_uint 0
    
    And we can see the results:

        | load_Input_uint |
         Count: 4
         - [ 0 ]: 10
         - [ 1 ]: 20
         - [ 2 ]: 20
         - [ 3 ]: 40

    You can see how it treats the tokens with different kinds of whitespace, newlines and spaces treated the same. (Looking at "yo ho ho")

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int load_Input_uint(std::ifstream* p_File)
    {
        std::cout << "\n --> load_Input_uint |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        return API.load_Input_uint(tmp_Construct);

        //std::cout << " [|x|]";
    }


    //    ---==========================================================================---
    //   ---============================================================================---
    //  ---==   Different ways of gathering nodes, individually, and the entire set.   ==---
    //   ---============================================================================---
    //    ---==========================================================================---

    /** This outputs the patterns as string when given a node ID (NID).

        gather_Given_Node CONSTRUCT_ID NID

    \param CONSTRUCT_ID The ID of the construct to use for gathering the node, the output will go to the output file associated with the construct given.
    \param NID The node ID (NID) of the node who's pattern we will be gathering, or decoding.
    \retval string This function write the string represented by the given NID to an output file associated with the given Construct.

    This is used when you want to retrieve a pattern from a NID. 

    Example Usage:

    The first step is to encode a pattern, into a newly minted construct for this example though it doesn't have to be new, it can be an old heirloom construct passed down through the generations:

        register_Construct Many_To_One ExaCon
        set_Input 0 The Dream Quest of Unkown Kadath /end/
        encode 0
        output_Scaffold

    Which shows us:

    Output:

         --==   CAN_Scaffold   ==--
        <- Tier[0] ->
          [0]  <> 1
          [1]  <> 2
          [2]  <> 3
          [3]  <> 4
          [4]  <> 5
          [5]  <> 6
          [6]  <> 3
          [7]  <> 7
          [8]  <> 8
          [9]  <> 4
          [10]  <> 9
          [11]  <> 10
          [12]  <> 3
          [13]  <> 11
          [14]  <> 12
          [15]  <> 4
          [16]  <> 13
          [17]  <> 14
          [18]  <> 4
          [19]  <> 15
          [20]  <> 16
          [21]  <> 17
          [22]  <> 13
          [23]  <> 18
          [24]  <> 16
          [25]  <> 4
          [26]  <> 19
          [27]  <> 7
          [28]  <> 20
          [29]  <> 7
          [30]  <> 12
          [31]  <> 2
        <- Tier[1] ->
          [0]  <> 21

    From this we can see the upper tier node is '21'. So we tell it to retrieve that node, however, we create a new construct and get the node through that construct to show that as long as the construct is the same type we can retrieve patterns encoded into the nodes:

        register_Construct Many_To_One RandomCon
        gather_Given_Node 1 21

    For an output of:

    Contents of file "./Output/RandomCon.Output.ssv":

        21 2 32 1 2 3 4 5 6 3 7 8 4 9 10 3 11 12 4 13 14 4 15 16 17 13 18 16 4 19 7 20 7 12 2 0 32 The Dream Quest of Unkown Kadath

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int gather_Given_Node(std::ifstream* p_File)
    {
        std::cout << "\n --> gather_Given_Node   CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        int tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";

        API.gather_Given_Node(tmp_Construct, tmp_NID);


        //std::cout << " [|x|]";

        return 1;
    }


    /** This outputs the patterns as an array of uint64_t when given a node ID (NID).

        gather_Given_Node_uint CONSTRUCT_ID NID

    \param CONSTRUCT_ID The ID of the construct to use for gathering the node, the output will go to the output file associated with the construct given.
    \param NID The node ID (NID) of the node who's pattern we will be gathering, or decoding.
    \retval string This function write the string represented by the given NID to an output file associated with the given Construct.

    This is used when you want to retrieve a pattern from a NID as an array of uint64_t.

    Example Usage:

    In this example we will encode two lower tier constructs to get the NIDs, and feed them into an MSC and get a single treetop node that represents the super-symbol of all the input encoded into a single retrievable trace. We wil then use this to get the original input patterns back out.

    3 networks must be crafted with care, two raw tier constructs, and one higher multi-sensory construct (MSC):

        register_Construct Many_To_One ExaCon
        register_Construct Many_To_One ConExa
        register_Construct Many_To_One ExaMSC

    Now we'll encode the two raw constructs ExaCon and ConExa. ExaCon will be temperature, and ConExa will be oxygen:

        set_Input 0 Temperature: 2 /end/
        encode 0
        set_Input 1 Oxygen: 4 /end/
        encode 1

    Then we use gather_Treetop_Node function to get both treetops, and to output the raw node for each so we can see the full data to confirm this function works:

        gather_Treetop_NID 0
        output_Newline 0
        gather_Treetop_Node 0

        gather_Treetop_NID 1
        output_Newline 1
        gather_Treetop_Node 1

    Contents of "./Output/ExaCon.Output.ssv":

        12
        12 2 14 1 2 3 4 2 5 6 7 8 5 2 9 10 11 0 14 Temperature: 2

    Contents of "./Output/ConExa.Output.ssv":

        22
        22 2 9 13 14 15 16 17 18 19 20 21 0 9 Oxygen: 4

    Now that we have these { 12, 22 } we can move onto the multi-sensory construct:

        set_Input_uint 2 2 12 22
        encode 2

    Gather the output:

        gather_Treetop_NID 2
        output_Newline 2
        gather_Treetop_Node_uint 2

    Contents of "./Output/ExaMSC.Output.ssv":

        25
        25 2 2 23 24 0 2 12 22

    FINALLY we can use this function to get the information back out, starting by wiping the output files:

        clear_Output 0
        clear_Output 1
        clear_Output 2

    Now we get the pattern from our highest abstraction, the treetop from ExaMSC, NID number 25. Moving forward we will only use information retrieved from the network to reconstruct symbol #25, no previous trained knowledge we will use, only meta and structural:

        gather_Given_Node_uint 0 25

    Which gives us the file contents (in ExaCon! Which isn't the construct which encoded the pattern, to show the network is shared):

    Contents of "./Output/ExaCon.Output.ssv":

        25 2 2 23 24 0 2 12 22

    Looking at this trace we see { 2 12 22 } at the end, which means 2 elements, which are 12 & 22 repectively.

    We then output newline, gather the node 12, another newline, then the node 22. We use the default gather_Given_Node here to get the raw data, but we've shown the uint by using it to get this far:

        output_Newline 0
        gather_Given_Node 0 12
        output_Newline 0
        gather_Given_Node 0 22

    Results found in "./Output/ExaCon.Output.ssv":

        25 2 2 23 24 0 2 12 22
        12 2 14 1 2 3 4 2 5 6 7 8 5 2 9 10 11 0 14 Temperature: 2
        22 2 9 13 14 15 16 17 18 19 20 21 0 9 Oxygen: 4

    As you can see we have encoded and retrieved all patterns using this function for the MSC traces, and the gather_Given_Node for the raw.

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int gather_Given_Node_uint(std::ifstream* p_File)
    {
        std::cout << "\n --> gather_Given_Node_uint |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        int tmp_NID = 0;

        *p_File >> tmp_NID;

        std::cout << " " << tmp_NID << " |";

        API.gather_Given_Node_uint(tmp_Construct, tmp_NID);

        //std::cout << " [|x|]";

        return 1;
    }

    /** Gathers all of the nodes to the given constructs output.

        gather_All_Nodes CONSTRUCT_ID

    \param CONSTRUCT_ID The construct who's output will be used.
    \retval None This function doesn't return any values.

    Loops through each node and gathers them into the output file associated with the given construct.

    Example Usage:

    Register a construct and encode the string 'qwerty':

        register_Construct Many_To_One ExaCon
        set_Input 0 qwerty /end/
        encode 0

    Now use this function to gather all the nodes to the output file associated with the given construct:

        gather_All_Nodes 0


    Output:

    Contents of "./ExaCon.Output.ssv":

        0 1 0 0 1
        1 2 0 1 1 7 1 q
        2 2 0 2 0 1 7 1 w
        3 2 0 3 0 0 1 7 1 e
        4 2 0 4 0 0 0 1 7 1 r
        5 2 0 5 0 0 0 0 1 7 1 t
        6 2 0 6 0 0 0 0 0 1 7 1 y
        7 2 6 1 2 3 4 5 6 0 6 qwerty

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int gather_All_Nodes(std::ifstream* p_File)
    {
        std::cout << "\n --> gather_All_Nodes |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.gather_All_Nodes(tmp_Construct);

        //std::cout << " [|x|]";

        return 1;
    }


    /** Gathers all of the nodes to the given constructs output as an array of uint64_t.

        gather_All_Nodes_uint CONSTRUCT_ID

    \param CONSTRUCT_ID The construct who's output will be used.
    \retval None This function doesn't return any values.

    Loops through each node and gathers them into the output file associated with the given construct, the output states/patterns are uint64_t.

    Example Usage:

    Register a construct and encode the array { 499, 500, 501 }:

        register_Construct Many_To_One ExaCon
        set_Input_uint 0 3 499 500 501
        encode 0

    Now use this function to gather all the nodes to the output file associated with the given construct:

        gather_All_Nodes_uint 0


    Output:

    Contents of "./ExaCon.Output.ssv":

        0 1 0 0 1 0
        1 2 0 1 1 4 1 499
        2 2 0 2 0 1 4 1 500
        3 2 0 3 0 0 1 4 1 501
        4 2 3 1 2 3 0 3 499 500 501

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int gather_All_Nodes_uint(std::ifstream* p_File)
    {
        std::cout << "\n --> gather_All_Nodes_uint |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.gather_All_Nodes_uint(tmp_Construct);

        //std::cout << " [|x|]";

        return 1;
    }


    //    ---==================================================================---
    //   ---====================================================================---
    //  ---==   The output of a given Construct is read into the output file.   ==---
    //   ---====================================================================---
    //    ---==================================================================---

    
    /** Takes every trace in the given Construct output trace array and writes them to the output file associated with that construct., note the output state patterns are treated as char.

        gather_Output CONSTRUCT_ID

    \param CONSTRUCT_ID The construct who's output is being gathered, or being written to the output file.
    \retval None This function doesn't return any values.

    Writes the output from a construct to the output file associated with that construct so that you can get the results of queries and other functions which result in a construct having traces in the output array.

    Example Usage:

    First we register our construct & encode a series of +- strings:

        register_Construct Many_To_One ExaCon
        set_Input 0 --- /end/ encode 0
        set_Input 0 --+ /end/ encode 0
        set_Input 0 -+- /end/ encode 0
        set_Input 0 -++ /end/ encode 0
        set_Input 0 +-- /end/ encode 0
        set_Input 0 +-+ /end/ encode 0
        set_Input 0 ++- /end/ encode 0
        set_Input 0 +++ /end/ encode 0

    Now we set the input and query it for the '+' char:

        set_Input 0 + /end/
        query 0

    Then to see the result we use gather_Output:

        gather_Output 0

    Output:

         7 10 2 3 +--
         8 20 2 3 +-+
         9 20 2 3 ++-
        10 30 2 3 +++
         5 10 2 3 -+-
         6 20 2 3 -++
         4 10 2 3 --+

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int gather_Output(std::ifstream* p_File)
    {
        std::cout << "\n --> gather_Output |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.gather_Output(tmp_Construct);

        //std::cout << " [|x|]";

        return 1;
    }

    /** Takes every trace in the given Construct output trace array and writes them to the output file associated with that construct., note the output state patterns are treated as uint64_t.

        gather_Output_uint CONSTRUCT_ID

    \param CONSTRUCT_ID The construct who's output is being gathered, or being written to the output file.
    \retval None This function doesn't return any values.

    Writes the output from a construct to the output file associated with that construct so that you can get the results of queries and other functions which result in a construct having traces in the output array.

    Example Usage:

    First we register our construct & encode a series of 3 item arrays:

        register_Construct Many_To_One ExaCon
        set_Input_uint 0 3 11 11 11 encode 0
        set_Input_uint 0 3 11 11 99 encode 0
        set_Input_uint 0 3 11 99 11 encode 0
        set_Input_uint 0 3 11 99 99 encode 0
        set_Input_uint 0 3 99 11 11 encode 0
        set_Input_uint 0 3 99 11 99 encode 0
        set_Input_uint 0 3 99 99 11 encode 0
        set_Input_uint 0 3 99 99 99 encode 0

    Now we set the input and query it for the '+' char:

        set_Input_uint 0 1 99
        query 0

    Then to see the result we use gather_Output:

        gather_Output_uint 0

    Output:

         7 10 2 3 99 11 11
         8 20 2 3 99 11 99
         9 20 2 3 99 99 11
        10 30 2 3 99 99 99
         5 10 2 3 11 99 11
         6 20 2 3 11 99 99
         4 10 2 3 11 11 99

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int gather_Output_uint(std::ifstream* p_File)
    {
        std::cout << "\n --> gather_Output_uint |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.gather_Output_uint(tmp_Construct);

        //std::cout << " [|x|]";

        return 1;
    }


    //    ---=============================---
    //   ---===============================---
    //  ---==   Treetop node gathering.   ==---
    //   ---===============================---
    //    ---=============================---

    /** Gets the treetop node for a given construct and puts it in the output file for that construct as a raw node.

        gather_Treetop_Node CONSTRUCT_ID

    \param CONSTRUCT_ID The construct you want the treetop from.
    \retval c_Node Treetop  The treetop is output to the output file associated with the given construct.

    This returns the treetop node for a given construct and outputs it to the output file for the given construct.

    This treetop is the top node in the current CAN Scaffold. So if you encode "yargi blargi" then this treetop node in a Many_To_One construct would be on tier [1] of the CAN Scaffold at index [0] that represents "yargi blargi".

    Example Usage:

    First we encode a string into a Many_To_One:

        register_Construct Many_To_One ExaCon
        set_Input 0 Pull Your Circuit Breaker /end/
        encode 0

    Then we can get the treetop:

        gather_Treetop_Node 0

    Output:
    
    Contents of "./Output/ExaCon.Output.ssv":

        16 2 25 1 2 3 3 4 5 6 2 7 4 8 9 7 10 2 9 11 4 12 7 13 14 15 13 7 0 25 Pull Your Circuit Breaker

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int gather_Treetop_Node(std::ifstream* p_File)
    {
        std::cout << "\n --> gather_treetop_node |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        //Gathers the treetop node.
        API.gather_Treetop_Node(tmp_Construct);

        //std::cout << " [|x|]";

        return 1;
    }

    /** Gets the treetop node for a given construct and puts it in the output file for that construct as a raw node, the output pattern will be uint64_t.

        gather_Treetop_Node_uint CONSTRUCT_ID

    \param CONSTRUCT_ID The construct you want the treetop from.
    \retval c_Node Treetop  The treetop is output to the output file associated with the given construct.

    This returns the treetop node for a given construct and outputs it to the output file for the given construct.

    This treetop is the top node in the current CAN Scaffold. So if you encode { 111, 222, 333 } then this treetop node in a Many_To_One construct would be on tier [1] of the CAN Scaffold at index [0] that represents { 111, 222, 333 }.

    Example Usage:

    First we encode a string into a Many_To_One:

        register_Construct Many_To_One ExaCon
        set_Input_uint 0 3 111 222 333
        encode 0

    Then we can get the treetop:

        gather_Treetop_Node_uint 0

    Output:

    Contents of "./Output/ExaCon.Output.ssv":

        4 2 3 1 2 3 0 3 111 222 333 

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int gather_Treetop_Node_uint(std::ifstream* p_File)
    {
        std::cout << "\n --> gather_treetop_node_uint |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.gather_Treetop_Node_uint(tmp_Construct);

        //std::cout << " [|x|]";

        return 1;
    }

    /** This takes the current treetop node from the CAN Scaffold (if one exists) and outputs the NID to the output file.

        gather_Treetop_NID CONSTRUCT_ID

    \param CONSTRUCT_ID The construct to retrieve the treetop node ID (NID) from.
    \retval uint64_t This function appends the NID of the treetop to the output file for the given construct.

    This function is useful when you are encoding multi-sensory constructs. When you encode a raw tier construct (one that deals with raw "sensory" data from outside the neural graph through state tier binding) the treetop is an abstraction of that sensory input. This function allows you to get a handle on that abstraction, a reference to that super-symbol.

    With this super-symbol or higher level abstraction you can feed it into higher tier constructs to build abstractions of abstractions with multiple lower constructs feeding their treetops into a higher tier construct.

    Example Usage:

    In this example we will encode two lower tier constructs to get the NIDs, and just for fun we'll feed them into an MSC to get a single treetop node that represents the super-symbol of all the input encoded into a single retrievable trace.

    First we create 3 networks, our old fren ExaCon, the somewhat familiar ConExa, and the rarely seen ExaMSC.

        register_Construct Many_To_One ExaCon
        register_Construct Many_To_One ConExa
        register_Construct Many_To_One ExaMSC

    Now we'll encode the two raw constructs ExaCon and ConExa. ExaCon will be temperature, and ConExa will be oxygen:

        set_Input 0 Temperature: 5 /end/
        encode 0
        set_Input 1 Oxygen: 3 /end/
        encode 1

    Output:

    The first construct ExaCon, temperature:

         --==   CAN_Scaffold   ==--
        <- Tier[0] ->
          [0]  <> 1
          [1]  <> 2
          [2]  <> 3
          [3]  <> 4
          [4]  <> 2
          [5]  <> 5
          [6]  <> 6
          [7]  <> 7
          [8]  <> 8
          [9]  <> 5
          [10]  <> 2
          [11]  <> 9
          [12]  <> 10
          [13]  <> 11
        <- Tier[1] ->
          [0]  <> 12


    The second construct ConExa, oxygen:

         --==   CAN_Scaffold   ==--
        <- Tier[0] ->
          [0]  <> 13
          [1]  <> 14
          [2]  <> 15
          [3]  <> 16
          [4]  <> 17
          [5]  <> 18
          [6]  <> 19
          [7]  <> 20
          [8]  <> 21
        <- Tier[1] ->
          [0]  <> 22

    Then we use this function to get both treetops, and to output the raw node for each so we can see the full data to confirm this function works:

        gather_Treetop_NID 0
        output_Newline 0
        gather_Treetop_Node 0

        gather_Treetop_NID 1
        output_Newline 1
        gather_Treetop_Node 1

    Output:

    Contents of "./Output/ExaCon.Output.ssv":

        12
        12 2 14 1 2 3 4 2 5 6 7 8 5 2 9 10 11 0 14 Temperature: 5

    Contents of "./Output/ConExa.Output.ssv":

        22
        22 2 9 13 14 15 16 17 18 19 20 21 0 9 Oxygen: 3

    Now that we have these { 12, 22 } we can move onto the multi-sensory construct:

        set_Input_uint 2 2 12 22
        encode 2
        output_Scaffold 2

    Gather the output:

        gather_Treetop_NID 2
		output_Newline 2
		gather_Treetop_Node_uint 2

    Contents of "./Output/ExaMSC.Output.ssv":

        25
        25 2 2 23 24 0 2 12 22

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int gather_Treetop_NID(std::ifstream* p_File)
    {
        std::cout << "\n --> gather_Treetop_NID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        //Passes the values to an Construct to encode.
        API.gather_Treetop_NID(tmp_Construct);

        //std::cout << " [|x|]";

        return 1;
    }


    void gather_Treetops(std::ifstream* p_File)
    {
        std::cout << "\n --> gather_Treetops |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        API.gather_Treetops(tmp_Construct);
    }


    //    ---======================================================================---
    //   ---========================================================================---
    //  ---==   Output the Construct input, output, scaffolds, node network, etc.   ==---
    //   ---========================================================================---
    //    ---======================================================================---

    /** This iterates through every node outputting them to the console.

        output_Node_Network

    \retval None This function doesn't return any values.

    This function iterates over every node in the network and outputs the to the console for you to view. This is not the patterns represented by the nodes, but the node structures themselves.

    Example Usage:

    First we register the construct, then we encode a series of binary values just because:

        register_Construct Many_To_One ExaCon
        set_Input 0 000 /end/ encode 0
        set_Input 0 001 /end/ encode 0
        set_Input 0 010 /end/ encode 0
        set_Input 0 011 /end/ encode 0
        set_Input 0 100 /end/ encode 0
        set_Input 0 101 /end/ encode 0
        set_Input 0 110 /end/ encode 0
        set_Input 0 111 /end/ encode 0

    Now output the network:

        output_Node_Network

    Output:

        | output_Node_Network |
         Node_ID (NID): 0  RC: 1 Type: 0 State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
         Node_ID (NID): 1  RC: 13 Type: 0 State { 48 } --- Dendrites:  --- Axon_Hillock_Count: 3 Axons[0] <4>:  [0] 2 [1] 4 [2] 5 [3] 6 Axons[1] <4>:  [0] 2 [1] 4 [2] 7 [3] 8 Axons[2] <4>:  [0] 2 [1] 5 [2] 7 [3] 9
         Node_ID (NID): 2  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 1 [1] 1 [2] 1 --- Axon_Hillock_Count: 0
         Node_ID (NID): 3  RC: 13 Type: 0 State { 49 } --- Dendrites:  --- Axon_Hillock_Count: 3 Axons[0] <4>:  [0] 7 [1] 8 [2] 9 [3] 10 Axons[1] <4>:  [0] 5 [1] 6 [2] 9 [3] 10 Axons[2] <4>:  [0] 4 [1] 6 [2] 8 [3] 10
         Node_ID (NID): 4  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 1 [1] 1 [2] 3 --- Axon_Hillock_Count: 0
         Node_ID (NID): 5  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 1 [1] 3 [2] 1 --- Axon_Hillock_Count: 0
         Node_ID (NID): 6  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 1 [1] 3 [2] 3 --- Axon_Hillock_Count: 0
         Node_ID (NID): 7  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 3 [1] 1 [2] 1 --- Axon_Hillock_Count: 0
         Node_ID (NID): 8  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 3 [1] 1 [2] 3 --- Axon_Hillock_Count: 0
         Node_ID (NID): 9  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 3 [1] 3 [2] 1 --- Axon_Hillock_Count: 0
         Node_ID (NID): 10  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 3 [1] 3 [2] 3 --- Axon_Hillock_Count: 0

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int output_Node_Network()
    {
        std::cout << "\n --> output_Node_Network |";

        //Passes the values to an Construct to encode.
        API.output_Node_Network();

        //std::cout << " [|x|]";

        return 1;
    }

    //    ---==  output_node  ==---
    /** Outputs a given node as defined by the passed NID to the console.

        function_name params
    \param
    \retval None This function doesn't return any values.

    The node is output to the console for the user to read, the symbol is backpropagated out and presented as both uint64_t and char().

    Example Usage:

    First we'll register a construct, then set & encode a string, then output the scaffold so we can see the nodes:
    
		register_Construct Many_To_One ExaCon
        set_Input 0 T-800 /end/
		encode 0
		output_Scaffold 0
		
    Output:

         --==   CAN_Scaffold   ==--
        <- Tier[0] ->
          [0]  <> 1
          [1]  <> 2
          [2]  <> 3
          [3]  <> 4
          [4]  <> 4
        <- Tier[1] ->
          [0]  <> 5

    Looking at this we can see that the treetop node (Tier[1] Index[0] in this Many_To_One) is NID #5, so we can output node number 5:

        output_Node 5

    Output:

         | output_Node | 5 |
        NID: 5 Type: 2 Symbol: <=- 5 * [ T, 84 ]  [ -, 45 ]  [ 8, 56 ]  [ 0, 48 ]  [ 0, 48 ]  -=>

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int output_Node(std::ifstream* p_File)
    {
        std::cout << "\n --> output_Node |";

        int tmp_Node = 0;

        *p_File >> tmp_Node;

        std::cout << " " << tmp_Node << " |";

        API.output_Backpropagated_Symbol_NID(tmp_Node);

        //std::cout << " [|x|]";

        return 1;
    }

    /** Outputs the constructs currently registered.

        output_constructs
    \retval None This function doesn't return any values.

    Outputs the list of currently registered constructs to the console.

    Example Usage:

    We'll register some constructs, then output them:

        register_Construct Many_To_One First_Conman
        register_Construct Many_To_One Second_Conman
        register_Construct Many_To_One Third_Conman
        output_constructs

    Output:

        __COMMAND__| output_constructs |
        [0]: First_Conman
        [1]: Second_Conman
        [2]: Third_Conman

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int output_Constructs()
    {
        std::cout << "\n --> output_Constructs |";

        API.output_Constructs();

        //std::cout << " [|x|]";

        return 1;
    }



    //      ---==================================---
    //     ---====================================---
    //    ---======================================---
    //   ---========================================---
    //  ---==   Generic commands for the engine.   ==---
    //   ---========================================---
    //    ---======================================---
    //     ---====================================---
    //      ---==================================---

    //    ---==  clear_output  ==---
    /** Wipes and output file for a given construct, CLS for the output file.

        clear_Output CONSTRUCT_ID
    \param CONSTRUCT_ID The ID of the construct who's output file is getting deleted.
    \retval None This function doesn't return any values.

    Opens the output file associated with the given construct using truncate (ios::ate) to wipe the file.

    Used in scripting for manipulating the output files through the engine to wipe them, or manually, but this allows obtuse control through the engine.

    Example Usage:

    Here we setup a construct, encode a string, gather the treetop node into the output file, output the output, wipe the output using this function, then recheck the output file to make sure:

        register_Construct Many_To_One ExaCon
        set_Input 0 Night Gaunt /end/
        encode 0
        gather_Treetop_Node 0

    Output:

    Contents of "./Output/ExaCon.Output.ssv":

        11 2 11 1 2 3 4 5 6 7 8 9 10 5 0 11 Night Gaunt

    Now we use this function to wipe the file:

        clear_Output 0

    Output:
    Contents of "./Output/ExaCon.Output.ssv":

        

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int clear_Output(std::ifstream* p_File)
    {
        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        //Gathers the treetop node.
        API.clear_Output(tmp_Construct);

        //std::cout << " [|x|]";

        return 1;
    }

    /** You give it a construct ID and it outputs a newline to the output file associated with that construct.

        output_Newline CONSTRUCT_ID

    \param CONSTRUCT_ID The construct to whom the newline shall go, to the coffers of their output file the newline appends.
    \retval None This function doesn't return any values, it outputs \n to the output file.

    Used for formatting output when testing, playing, prototyping, experimenting, or scripting.

    Example Usage:

    For an example we will register an Construct, encode several items, then output them one by one with two newlines betwixt them:

        register_Construct Many_To_One ExaCon
        set_Input 0 Night Gaunt /end/
        encode 0
        gather_Treetop_Node 0

        output_Newline 0
        set_Input 0 Wubbajack /end/
        encode 0
        gather_Treetop_Node 0

        output_Newline 0
        set_Input 0 Ghoul /end/
        encode 0
        gather_Treetop_Node 0

    Output:

    Contents of the file "./Output/ExaCon.Output.ssv":

        11 2 11 1 2 3 4 5 6 7 8 9 10 5 0 11 Night Gaunt
        17 2 9 12 9 13 13 8 14 8 15 16 0 9 Wubbajack
        20 2 5 7 4 18 9 19 0 5 Ghoul

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int output_Newline(std::ifstream* p_File)
    {
        std::cout << "\n --> write_Newline   CONSTRUCT_ID |";

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        //Gathers the treetop node.
        API.output_Newline(tmp_Construct);

        //std::cout << " [|x|]";

        return 1;
    }


    int write_Text(std::ifstream* p_File)
    {
        std::cout << "\n --> write_Text   CONSTRUCT_ID   TEXT |";

        std::string tmp_In = "";
        std::string tmp_In_Full = "";
        int tmp_Count = 0;

        std::string tmp_Construct = "";

        *p_File >> tmp_Construct;

        std::cout << " " << tmp_Construct << " |";

        bool flg_Gather_Input = true;

        while (flg_Gather_Input)
        {
            tmp_In = "";
            *p_File >> tmp_In;

            std::cout << " " << tmp_In << " |";

            if (tmp_In == "/end/")
            {
                flg_Gather_Input = false;
                continue;
            }

            if (tmp_In != "")
            {

                tmp_Count++;

                if (tmp_In_Full != "")
                {
                    tmp_In_Full = tmp_In_Full + " " + tmp_In;
                }
                else
                {
                    tmp_In_Full = tmp_In;
                }
            }

            if (flg_Gather_Input)
            {
                flg_Gather_Input = (!p_File->eof());
            }
        }

        API.write_Text(tmp_Construct, tmp_In_Full);


        //std::cout << " [|x|]";

        return 1;
    }


    int echo(std::ifstream* p_File)
    {
        //---std::cout << "\n --> Echo |\n";

        std::string tmp_In = "";
        std::string tmp_In_Full = "";
        int tmp_Count = 0;

        bool flg_Gather_Input = true;

        while (flg_Gather_Input)
        {
            tmp_In = "";
            *p_File >> tmp_In;

            if (tmp_In == "/end/")
            {
                flg_Gather_Input = false;
                continue;
            }

            if (tmp_In != "")
            {

                tmp_Count++;

                if (tmp_In_Full != "")
                {
                    tmp_In_Full = tmp_In_Full + " " + tmp_In;
                }
                else
                {
                    tmp_In_Full = tmp_In;
                }
            }

            if (flg_Gather_Input)
            {
                flg_Gather_Input = (!p_File->eof());
            }
        }

        std::cout << "\n\n" << tmp_In_Full;
        std::cout << "\n";

        //std::cout << " [|x|]";

        return 1;
    }


    /** brief

        function_name params
    \param 
    \retval None This function doesn't return any values.
	
	Describe behavior and side-effects. What it basically does and if it touches any globals.
	
	Example Usage:
	
	    function_name params
	
	Output:
	
	    output
	
	Error Handling:
	
	- No error handling is implemented in this function.
	
	Additional Notes:
	
	- None.
    */
    void save(std::ifstream* p_File)
    {
        std::cout << "\n --> save |";

        std::string tmp_FName;

        *p_File >> tmp_FName;

        std::cout << " " << tmp_FName << " |";

        tmp_FName = "./cores/" + tmp_FName;
        std::cout << " " << tmp_FName << " |";

        API.save(tmp_FName);

        //std::cout << " [|x|]";
    }


    void load(std::ifstream* p_File)
    {
        std::cout << "\n --> load |";

        std::string tmp_FName;

        *p_File >> tmp_FName;

        std::cout << " " << tmp_FName << " |";

        tmp_FName = "./cores/" + tmp_FName;
        std::cout << " " << tmp_FName << " |";

        API.load(tmp_FName);

        //std::cout << " [|x|]";
    }


    /** The main loop for the neuro-server.

        run

    \retval None This function doesn't return any values.

    Call this to start the server in C++.

    This loop outputs a the message as a means of delay, then checks the flag file, and if anything is found it calls the interpreter.

    Error Handling:

    - No error handling is implemented in this function.

    Additional Notes:

    - None.
    */
    int run()
    {
        if (flg_Exit) 
        {
            std::cout << "\n --> exit |";
            std::cerr << "\n\n   (o~o) It's been fun anon...goodbye...  \n\n";
            return 1; 
        }

        int flg_Direction = 1;
        int tmp_Distance = -250;
        int tmp_MAX = 250;

        std::string tmp_Message = "______________________________IDLING______________________________";
        std::string tmp_Corrupt_Message = "";

        flg_Direction = 1;
        tmp_Distance = 0;
        while (1)
        {
            for (int cou_Time = 0; cou_Time < 250; cou_Time++)
            {
                tmp_Distance += flg_Direction;

                if (tmp_Distance >= tmp_MAX) { flg_Direction = -1; }
                if (tmp_Distance <= (tmp_MAX * -1)) { flg_Direction = 1; }

                for (int cou_Index = 0; cou_Index < (tmp_Message.length() + 9); cou_Index++)
                {
                    std::cout << char(8);
                }

                tmp_Corrupt_Message = tmp_Message;

                for (int cou_Index = 0; cou_Index < tmp_Distance; cou_Index++)
                {
                    tmp_Corrupt_Message[rand() % tmp_Message.length()] = char((std::rand() % 32) + 32);
                }

                std::cout << "STANDBY[" << tmp_Corrupt_Message << "]";
            }

            int tmp_Result = check_Control_Panel_Flag();

            //Check the control panel for an update
            if (tmp_Result)
            {
                //std::cout << "\n ~~~Calling control interpreter:";

                if (execute_Control_Panel_Buffer() == -1)
                {
                    std::cout << "\n --> exit |";
                    std::cerr << "\n\n   (o~o) It's been fun anon...goodbye...  \n\n";

                    return 1;
                }

                std::cout << "\n\n (o.O)";

                std::cout << tmp_Message;

            }

            Tick++;
        }
    }

    void rcon()
    {

    }
};

/** @}*/struct s_Out
{
    u_Data Data;
    u_Data Match;
    float Charge;
    float RC;
    bool flg_Use;
};

//Each reference frame is a parallel system state with a shared semiotic database. This allows for multiple parallel operations with the same core neural structure, used for pre-factor analysis, parallel projections, and other things where you want multiple separate operations persistently in parallel.
class c_Time_Series_Reference_Frame
{
public:

    std::vector<std::vector<u_Data>> Input;
    std::vector<std::vector<bool>> Input_Mask;
    std::vector<std::vector<u_Data>> Input_Interm;
    std::vector<std::vector<u_Data>> Output;

    double MSC_APT;
    double Chrono_APT;
    double MSC_MC;
    double Chrono_MC;

    std::vector<std::vector<std::vector<s_Out>>> Bulk;

    int Chrono_Depth;
    int Raw_Depth;

    //Used for the drawdown and comparing Bulk to the current Input_Interm
    int Chrono_Current;

    c_Time_Series_Reference_Frame()
    {
        Chrono_Depth = 0;
        Raw_Depth = 0;
        Chrono_Current = 0;

        MSC_APT = 0.95;
        Chrono_APT = 0.95;
        MSC_MC = 0.95;
        Chrono_MC = 0.95;
    }

    void set_MSC_APT(double p_APT)
    {
        MSC_APT = p_APT;
    }

    void set_Chrono_APT(double p_APT)
    {
        Chrono_APT = p_APT;
    }

    void set_MSC_MC(float p_MC)
    {
        MSC_MC = p_MC;
    }

    void set_Chrono_MC(float p_MC)
    {
        Chrono_MC = p_MC;
    }

    //This sets the first axis of the I/O tables to the depth of Chrono. 
    //You should use the shift_Chrono to read in input you plan on encoding.
    //This is just for initialization in most cases.
    void resize_IO_To_Chrono(int p_Chrono_Depth)
    {
        Chrono_Depth = p_Chrono_Depth;

        Input.resize(p_Chrono_Depth);
        Input_Mask.resize(p_Chrono_Depth);
        Output.resize(p_Chrono_Depth);
    }

    void resize_Raw_Frames(int p_Raw_Depth)
    {
        Raw_Depth = p_Raw_Depth;

        for (int cou_Chrono = 0; cou_Chrono < Chrono_Depth; cou_Chrono++)
        {
            Input[cou_Chrono].resize(Raw_Depth);
            Input_Mask[cou_Chrono].resize(Raw_Depth);
            Output[cou_Chrono].resize(Raw_Depth);
        }
    }

    std::vector<uint64_t> get_uint_Input(int p_Chrono)
    {
        std::vector<uint64_t> tmp_Data(Input[p_Chrono].size());

        for (int cou_D = 0; cou_D < Input[p_Chrono].size(); cou_D++)
        {
            tmp_Data[cou_D] = Input[p_Chrono][cou_D].U;
        }
        return tmp_Data;
    }

    void copy_Input()
    {
        Input_Interm.clear();

        Input_Interm.resize(Chrono_Depth * 2);

        for (int cou_Chrono = 0; cou_Chrono < Input_Interm.size(); cou_Chrono++)
        {
            Input_Interm[cou_Chrono].resize(Raw_Depth);
        }

        for (int cou_Chrono = 0; cou_Chrono < Chrono_Depth; cou_Chrono++)
        {
            for (int cou_Index = 0; cou_Index < Raw_Depth; cou_Index++)
            {
                Input_Interm[cou_Chrono][cou_Index].U = 0;
                Input_Interm[cou_Chrono][cou_Index] = Input[cou_Chrono][cou_Index];
            }
        }

        /*
        for (int cou_Chrono = 0; cou_Chrono < Input_Interm.size(); cou_Chrono++)
        {
            std::cout << "\nChrono[" << cou_Chrono << "]";

            for (int cou_Index = 0; cou_Index < Input_Interm[cou_Chrono].size(); cou_Index++)
            {
                std::cout << "\nInterm[" << cou_Chrono << "][" << cou_Index << "] " << Input_Interm[cou_Chrono][cou_Index].D;
            }
        }
        */
    }

    void output_Interm()
    {
        std::cout << "\n\n Interm:";
        for (int cou_Raw = 0; cou_Raw < Raw_Depth; cou_Raw++)
        {
            std::cout << "\n [" << cou_Raw << "] ";
            for (int cou_Chrono = 0; cou_Chrono < (Chrono_Depth * 2); cou_Chrono++)
            {
                if ((!(cou_Chrono % Chrono_Depth)) && (cou_Chrono != 0)) { std::cout << " ~ "; }
                std::cout << " " << Input_Interm[cou_Chrono][cou_Raw].D;
            }
        }
    }

    void  move_Interm_To_Output()
    {
        for (int cou_Chrono = Chrono_Depth; cou_Chrono < (Chrono_Depth * 2); cou_Chrono++)
        {
            for (int cou_Raw = 0; cou_Raw < Raw_Depth; cou_Raw++)
            {
                Output[cou_Chrono - Chrono_Depth][cou_Raw] = Input_Interm[cou_Chrono][cou_Raw];
            }
        }
    }

    void output_Bulk()
    {
        std::cout << "\n\n Bulk:";
        for (int cou_Chrono = 0; cou_Chrono < Bulk.size(); cou_Chrono++)
        {
            std::cout << "\n    Chrono[" << cou_Chrono << "]";
            for (int cou_Raw = 0; cou_Raw < Bulk[cou_Chrono].size(); cou_Raw++)
            {
                std::cout << "\n       Raw[" << cou_Raw << "]";
                for (int cou_O = 0; cou_O < Bulk[cou_Chrono][cou_Raw].size(); cou_O++)
                {
                    std::cout << "\n          O[" << cou_O << "]";
                    std::cout << " Bulk_Primitive: " << Bulk[cou_Chrono][cou_Raw][cou_O].Data.D;
                    std::cout << " Current: " << Input_Interm[Chrono_Current + cou_Chrono][cou_Raw].D;
                    std::cout << " Match: " << Bulk[cou_Chrono][cou_Raw][cou_O].Match.D;
                    std::cout << " Charge: " << Bulk[cou_Chrono][cou_Raw][cou_O].Charge;
                }
            }
        }
        std::cout << "\n\n _~_ Bulk Match:";

        double tmp_Count = 0;

        for (int cou_Raw = 0; cou_Raw < Raw_Depth; cou_Raw++)
        {
            std::cout << "\n ___  ___ Raw[" << cou_Raw << "]:";
            for (int cou_O = 0; cou_O < Bulk[0][cou_Raw].size(); cou_O++)
            {
                std::cout << "\n ___  ___  ___ Output[" << cou_O << "]";

                tmp_Count = 0;

                for (int cou_Chrono = 0; cou_Chrono < Chrono_Depth; cou_Chrono++)
                {
                    tmp_Count += Bulk[cou_Chrono][cou_Raw][cou_O].Match.D;
                }
                std::cout << " Match Count: " << tmp_Count;
            }
        }
    }

    void calculate_Match_Use()
    {
        double tmp_Count = 0;

        for (int cou_Raw = 0; cou_Raw < Raw_Depth; cou_Raw++)
        {
            //---std::cout << "\n ___  ___ Raw[" << cou_Raw << "]:";
            for (int cou_O = 0; cou_O < Bulk[0][cou_Raw].size(); cou_O++)
            {
                //---std::cout << "\n ___  ___  ___ Output[" << cou_O << "]";

                tmp_Count = 0;

                for (int cou_Chrono = 0; cou_Chrono < Chrono_Depth; cou_Chrono++)
                {
                    tmp_Count += Bulk[cou_Chrono][cou_Raw][cou_O].Match.D;
                }
                //---std::cout << " Match Count: " << tmp_Count;

                if (tmp_Count >= 1)
                {
                    for (int cou_Chrono = 0; cou_Chrono < Chrono_Depth; cou_Chrono++)
                    {
                        Bulk[cou_Chrono][cou_Raw][cou_O].flg_Use = 1;
                    }
                }
            }
        }
    }


    void output_IO()
    {
        for (int cou_Chrono = 0; cou_Chrono < Chrono_Depth; cou_Chrono++)
        {
            std::cout << "\n\n\n Chrono [" << cou_Chrono << "]: ";
            std::cout << "\n -.- {INPUT} ";
            for (int cou_I = 0; cou_I < Input[cou_Chrono].size(); cou_I++)
            {
                std::cout << "\n -.- -.- <" << cou_I << "> " << Input[cou_Chrono][cou_I].D;
            }
            std::cout << "\n -.- {OUTPUT} ";
            for (int cou_O = 0; cou_O < Output[cou_Chrono].size(); cou_O++)
            {
                std::cout << "\n -.- -.- <" << cou_O << "> " << Output[cou_Chrono][cou_O].D;
            }
        }
    }


    void output_IO_Stats()
    {
        std::cout << "\n IO_Stats:";
        std::cout << "\n ... Chrono_Depth: " << Chrono_Depth;
        for (int cou_Chrono = 0; cou_Chrono < Chrono_Depth; cou_Chrono++)
        {
            std::cout << "\n ... ... Input_Depth[" << cou_Chrono << "]: " << Input[cou_Chrono].size();
            std::cout << " ... Output_Depth[" << cou_Chrono << "]: " << Output[cou_Chrono].size();
        }
    }

};


















class c_Time_Series_Generator_Module
{
public:

    //The IO, bulk, interm, and other state members.
    std::vector<c_Time_Series_Reference_Frame> RF;

    //Depth of the Chrono array.
    int Chrono_Depth; 

    //The number of inputs to the MSC, the count of raw constructs.
    int Raw_Depth;

    int MSC_Depth;

    NT4::c_Construct_API NT4_Core;

    //Used for the drawdown and comparing Bulk to the current Input_Interm
    int Chrono_Current;

    //One per raw, used to generate the random predictions.
    std::vector<double> Range_High;
    std::vector<double> Range_Low;

    c_Time_Series_Generator_Module()
    {
        Chrono_Depth = 0;
        Raw_Depth = 0;
        MSC_Depth = 0;
        Chrono_Current = 0;
    }

    void init(int p_Chrono_Depth, int p_Raw_Depth, int p_RF_Depth)
    {
        RF.resize(p_RF_Depth);

        /*-*/std::cerr << "\n setup_Higher_Tier_Constructs";
        setup_Higher_Tier_Constructs();

        /*-*/std::cerr << "\n set_Chrono_Depth";
        set_Chrono_Depth(p_Chrono_Depth);

        /*-*/std::cerr << "\n set_Raw_Depth";
        set_Raw_Depth(p_Raw_Depth);

        /*-*/std::cerr << "\n setup_Raw_Tier_Constructs";
        setup_Raw_Tier_Constructs();

        /*-*/std::cerr << "\n update_MSC_Depth";
        update_MSC_Depth();

        /*-*/std::cerr << "\n create_Construct_Connections";
        create_Construct_Connections();

        output_Everything();
    }

    void setup_Higher_Tier_Constructs()
    {
        NT4_Core.register_Construct("Many_To_One", "MSC");

        NT4_Core.register_Construct("Many_To_One", "Chrono");
    }

    void create_Construct_Connections()
    {
        for (int cou_C = 0; cou_C < Raw_Depth; cou_C++)
        {
            NT4_Core.create_Construct_Connection(Raw_Name[cou_C], "MSC");
        }

        NT4_Core.create_Construct_Connection("MSC", "Chrono");

        NT4_Core.output_Constructs();
        NT4_Core.output_Construct_Connections("Chrono");
        NT4_Core.output_Construct_Connections("MSC");
    }

    std::vector<std::string> Raw_Name;

    void setup_Raw_Tier_Constructs()
    {
        Range_Low.resize(Raw_Depth);
        Range_High.resize(Raw_Depth);
        for (int cou_Index = 0; cou_Index < Raw_Depth; cou_Index++)
        {
            std::string tmp_Name = "Raw_" + std::to_string(cou_Index);
            Raw_Name.push_back(tmp_Name);

            NT4_Core.register_Construct("Many_To_One", Raw_Name[cou_Index]);

            Range_Low[cou_Index] = 9999;
            Range_High[cou_Index] = 0;
        }
        NT4_Core.output_Constructs();
    }

    //Sets the Chrono depth.
    void set_Chrono_Depth(int p_Depth)
    {
        Chrono_Depth = p_Depth;

        resize_IO_To_Chrono();
    }

    void set_MSC_APT(int p_RF, float p_APT)
    {
        RF[p_RF].set_MSC_APT(p_APT);
    }

    void set_Chrono_APT(int p_RF, float p_APT)
    {
        RF[p_RF].set_Chrono_APT(p_APT);
    }

    void set_MSC_MC(int p_RF, float p_MC)
    {
        RF[p_RF].set_MSC_MC(p_MC);
    }

    void set_Chrono_MC(int p_RF, float p_MC)
    {
        RF[p_RF].set_Chrono_MC(p_MC);
    }

    //This sets the first axis of the I/O tables to the depth of Chrono. 
    //You should use the shift_Chrono to read in input you plan on encoding.
    //This is just for initialization in most cases.
    void resize_IO_To_Chrono()
    {
        for (int cou_S = 0; cou_S < RF.size(); cou_S++)
        {
            RF[cou_S].resize_IO_To_Chrono(Chrono_Depth);
        }

        std::vector<uint64_t> tmp_Gathered_Chrono(Chrono_Depth);

        NT4_Core.set_Input_uint("Chrono", Chrono_Depth, (tmp_Gathered_Chrono.data()));
    }

    void resize_Raw_Frames()
    {
        for (int cou_S = 0; cou_S < RF.size(); cou_S++)
        {
            RF[cou_S].resize_Raw_Frames(Raw_Depth);
        }
    }

    void set_Raw_Depth(int p_Raw_Depth)
    {
        Raw_Depth = p_Raw_Depth;

        resize_Raw_Frames();
    }

    void shift_Data(int p_RF = 0, float p_Init_Value = 0)
    {
        //---validate_RF(p_RF);

        for (int cou_Chrono = 0; cou_Chrono < (Chrono_Depth - 1); cou_Chrono++)
        {
            RF[p_RF].Input[cou_Chrono] = RF[p_RF].Input[cou_Chrono + 1];
            RF[p_RF].Input_Mask[cou_Chrono] = RF[p_RF].Input_Mask[cou_Chrono + 1];
            RF[p_RF].Output[cou_Chrono] = RF[p_RF].Output[cou_Chrono + 1];
        }
        RF[p_RF].Input[(Chrono_Depth - 1)].clear();
        RF[p_RF].Input[(Chrono_Depth - 1)].resize(Raw_Depth);

        RF[p_RF].Input_Mask[(Chrono_Depth - 1)].clear();
        RF[p_RF].Input_Mask[(Chrono_Depth - 1)].resize(Raw_Depth);

        RF[p_RF].Output[(Chrono_Depth - 1)].clear();
        RF[p_RF].Output[(Chrono_Depth - 1)].resize(Raw_Depth);

        if (p_Init_Value != 0)
        {
            for (int cou_R = 0; cou_R < Raw_Depth; cou_R++)
            {
                RF[p_RF].Input[(Chrono_Depth - 1)][cou_R].D = p_Init_Value;
            }
        }
    }

    void set_Input_Index(int p_RF, int p_Index, uint64_t p_Data)
    {
        //---validate_RF(p_RF);

        RF[p_RF].Input[Chrono_Depth - 1][p_Index].U = p_Data;
        RF[p_RF].Input_Mask[Chrono_Depth - 1][p_Index] = 1;

        u_Data tmp_Bit;
        tmp_Bit.U = 0;
        tmp_Bit.U = p_Data;

        if (tmp_Bit.D > Range_High[p_Index]) { Range_High[p_Index] = tmp_Bit.D; }
        if (tmp_Bit.D < Range_Low[p_Index]) { Range_Low[p_Index] = tmp_Bit.D; }
    }

    void set_Input_Index(int p_RF, int p_Index, double p_Data)
    {
        //---validate_RF(p_RF);

        RF[p_RF].Input[Chrono_Depth - 1][p_Index].D = p_Data;
        RF[p_RF].Input_Mask[Chrono_Depth - 1][p_Index] = 1;

        if (p_Data > Range_High[p_Index]) { Range_High[p_Index] = p_Data; }
        if (p_Data < Range_Low[p_Index]) { Range_Low[p_Index] = p_Data; }

        //std::cout << "\n set_Input_Index(p_RF:" << p_RF << ", p_Index: " << p_Index << ", p_Data: " << p_Data;
    }

    u_Data get_Output_Index(int p_RF, int p_Index)
    {
        //---validate_RF(p_RF);

        return RF[p_RF].Output[0][p_Index];
    }

    std::vector<std::vector<std::vector<NT4::s_Out>>> get_Bulk(int p_RF)
    {
        return RF[p_RF].Bulk;
    }



    void update_MSC_Depth()
    {
        std::vector<uint64_t> tmp_Gathered_MSC(Raw_Depth);
        MSC_Depth = Raw_Depth;
        NT4_Core.set_Input_uint("MSC", Raw_Depth, (tmp_Gathered_MSC.data()));
    }

    std::vector<uint64_t> get_uint_Input(int p_RF, int p_Chrono)
    {
        //---validate_RF(p_RF);

        return RF[p_RF].get_uint_Input(p_Chrono);
    }

    //First we do the lower ones, then from those we gather the treetops to bind together into the MSC, which then feeds into the Chrono.
    void encode(int p_RF)
    {
        //---validate_RF(p_RF);

        for (int cou_Chrono = 0; cou_Chrono < (Chrono_Depth); cou_Chrono++)
        {
            //---std::cout << "\n _~_~_ Chrono[ " << cou_Chrono << "] _~_~_";
            for (int cou_Index = 0; cou_Index < Raw_Depth; cou_Index++)
            {
                NT4_Core.set_Input_uint(Raw_Name[cou_Index], 1, &(RF[p_RF].Input[cou_Chrono][cou_Index].U));
                NT4_Core.encode(Raw_Name[cou_Index]);
                //---std::cout << "\n Raw[" << Raw_Name[cou_Index] << "] ";
                //---NT4_Core.output_Scaffold(Raw_Name[cou_Index]);
                //---NT4_Core.output_Scaffold_Symbols_Float(Raw_Name[cou_Index]);
            }
            NT4_Core.round_Up_Input("MSC");
            //---std::cout << "\n MSC Input: ";
            //---NT4_Core.output_Input_uint("MSC");
            NT4_Core.encode("MSC");
            //---std::cout << "\n MSC Scaffold: ";
            //---NT4_Core.output_Scaffold_Symbols_uint("MSC");
            NT4_Core.pull_Chrono_From_Lower_Connection("Chrono");
        }
        NT4_Core.encode("Chrono");
        //---std::cout << "\n Chrono Scaffold: ";
        //---NT4_Core.output_Scaffold("Chrono");
    }

    void output_Scaffolds()
    {
        std::cout << "\n\n There are [" << Chrono_Depth << "] frames in the time series. Each frame has [" << Raw_Depth << "] raw tier constructs, one multi-sensory-construct (MSC), and one Chrono construct on top to handle the time series. This shows the most recent frame as it is the only one with a scaffold built.";
        
        std::cout << "\n\n";
        std::cout << "\n _ __  ___   ____    _____    ____   ___  __ _";
        std::cout << "\n _ __  ___   ____    _____    ____   ___  __ _";
        std::cout << "\n _ __  ___   ____    _____    ____   ___  __ _";
        for (int cou_Index = 0; cou_Index < Raw_Depth; cou_Index++)
        {
            std::cout << "\n\n -Raw_Tier_Scaffold[" << cou_Index << "] in Chrono[0]";
            std::cout << "\n\n --- Scaffold as adresses:";
            NT4_Core.output_Scaffold(Raw_Name[cou_Index]);
            std::cout << "\n\n --- Scaffold as floats:";
            NT4_Core.output_Scaffold_Symbols_Float(Raw_Name[cou_Index]);
            //std::cout << Raw_Name[cou_Index];
        }

        std::cout << "\n\n - MSC Scaffold:";
        NT4_Core.output_Scaffold("MSC");

        std::cout << "\n\n - Chrono Scaffold: ";
        NT4_Core.output_Scaffold("Chrono");
        std::cout << "\n\n";
    }

    void copy_Input(int p_RF)
    {
        //---validate_RF(p_RF);

        RF[p_RF].copy_Input();
    }

    void output_Interm(int p_RF)
    {
        //---validate_RF(p_RF);

        RF[p_RF].output_Interm();
    }

    void  move_Interm_To_Output(int p_RF)
    {
        //---validate_RF(p_RF);

        RF[p_RF].move_Interm_To_Output();
    }


    //Encodes an input set.
    void eval(int p_RF)
    {
        //---validate_RF(p_RF);
        NT4_Core.set_Action_Potential_Threshold("Chrono", float(RF[p_RF].Chrono_APT));
        NT4_Core.set_Action_Potential_Threshold("MSC", float(RF[p_RF].MSC_APT));
        NT4_Core.set_Modifier_Charge("Chrono", float(RF[p_RF].Chrono_MC));
        NT4_Core.set_Modifier_Charge("MSC", float(RF[p_RF].MSC_MC));

        copy_Input(p_RF);

        //---output_IO();

        query_Arrays(p_RF);

        //system("PAUSE");

        //---output_Interm();

        //drawdown_Arrays();

        //generate_Avg_Output();

        //record_Current_Projection();
        //record_Current_IO();

        //---std::cout << "\n\n\n [[[ Historical_Prediction ]]]:\n\n";

        //output_Historical_Projections();
    }

    double get_Input(int p_RF, int p_Chrono, int p_Index)
    {
        return RF[p_RF].Input[p_Chrono][p_Index].D;
    }

    void query_Arrays(int p_RF)
    {
        std::vector<uint64_t> tmp_Chron(Chrono_Depth);
        NT4_Core.set_Input_uint("Chrono", Chrono_Depth, tmp_Chron.data());

        //---std::cout << "\n\n\n query_Array()"; std::cout.flush();
        //---std::cout << "\n Chrono_Depth: " << Chrono_Depth; std::cout.flush();
        for (int cou_Step = 0; cou_Step < Chrono_Depth; cou_Step++)
        {
            //---output_Interm(p_RF); std::cout.flush();

            NT4_Core.reset_Output("Chrono");
            NT4_Core.gather_Treetops("Chrono");

            Chrono_Current = cou_Step;
            RF[p_RF].Chrono_Current = cou_Step;

            //---std::cout << "\n -+- Step[" << cou_Step << "]"; std::cout.flush();
            //[0] is the newest so we read the chrono in the same way it appears, oldest to newest.
            for (int cou_Chrono = 0; cou_Chrono < (Chrono_Depth - 1); cou_Chrono++)
            {
                //---std::cout << "\n -+- -+- Chrono[" << cou_Chrono << "]"; std::cout.flush();
                for (int cou_Index = 0; cou_Index < Raw_Depth; cou_Index++)
                {
                    //---std::cout << "\n -+- -+- -+- Index[" << cou_Index << "]"; std::cout.flush();
                    //---std::cout << "\n -+- -+- -+- -+- Input_Interm[" << (cou_Step + cou_Chrono) << "][" << cou_Index << "]: " << (RF[p_RF].Input_Interm[cou_Step + cou_Chrono][cou_Index].D); std::cout.flush();
                    u_Data tmp_Bit;
                    tmp_Bit.U = 0;
                    tmp_Bit.U = RF[p_RF].Input_Interm[cou_Step + cou_Chrono][cou_Index].U;
                    
                    if ((tmp_Bit.D - int(tmp_Bit.D)) < 0.5)
                    {
                        tmp_Bit.D = int(tmp_Bit.D);
                    }
                    if ((tmp_Bit.D - int(tmp_Bit.D)) >= 0.5)
                    {
                        tmp_Bit.D = int(tmp_Bit.D) + 1;
                    }

                    NT4_Core.set_Input_uint(Raw_Name[cou_Index], 1, &(tmp_Bit.U));
                    NT4_Core.check_Symbol(Raw_Name[cou_Index]);
                }

                NT4_Core.reset_Output("MSC");
                NT4_Core.gather_Treetops("MSC");
                NT4_Core.round_Up_Input("MSC");
                //---std::cout << "\n MSC Input: ";
                //---NT4_Core.output_Input_uint("MSC");
                NT4_Core.query_Spacial("MSC");
                //---std::cout << "\n MSC Scaffold: ";
                //---NT4_Core.output_Scaffold("MSC");
                NT4_Core.gather_Treetops("MSC");
                //---std::cout << "\n MSC Output_uint: ";
                //---NT4_Core.output_Output_uint("MSC");

                NT4_Core.pull_From_Lower_Connections("Chrono");
                NT4_Core.query_Given_Index("Chrono", cou_Chrono);
                //---std::cout << "\n Chrono[" << cou_Chrono << "]: ";
                //---NT4_Core.output_Input_uint("Chrono");
                //---NT4_Core.output_Scaffold("Chrono");
            }
            NT4_Core.gather_Treetops("Chrono");

            //---std::cout << "\n Output Output_uint Chrono: ";
            //---NT4_Core.output_Output_uint("Chrono");

            drawdown_Arrays(p_RF);

            calculate_Match_Use(p_RF);

            generate_Avg_Output(p_RF, cou_Step, (cou_Step + Chrono_Depth));
        }
        //---output_Bulk(p_RF);

        move_Interm_To_Output(p_RF);
    }

    void drawdown_Arrays(int p_RF)
    {
        //---validate_RF(p_RF);

        //std::cout << "\n lkdsjflksjfpjpoijewopjwiojoi  eerwf hthjtr hrt t  jf kljfjejw;jo4ij93ufj043j0     0000";

        RF[p_RF].Bulk.resize(Chrono_Depth);

        for (int cou_Chrono = 0; cou_Chrono < Chrono_Depth; cou_Chrono++)
        {
            RF[p_RF].Bulk[cou_Chrono].resize(Raw_Depth);

            NT4_Core.reset_Output("MSC");
            NT4_Core.pull_From_Upper_Index("MSC", "Chrono", cou_Chrono);


            //std::cout << "\n lkdsjflksjfpjpoijewopjwiojoi  eerwf hthjtr hrt t  jf kljfjejw;jo4ij93ufj043j0     1111";

            for (int cou_Raw = 0; cou_Raw < Raw_Depth; cou_Raw++)
            {
                NT4_Core.reset_Output(Raw_Name[cou_Raw]);
                NT4_Core.pull_From_Upper_Index(Raw_Name[cou_Raw], "MSC", cou_Raw);

                RF[p_RF].Bulk[cou_Chrono][cou_Raw].resize(NT4_Core.get_Output_Depth(Raw_Name[cou_Raw]));

                for (int cou_O = 0; cou_O < NT4_Core.get_Output_Depth(Raw_Name[cou_Raw]); cou_O++)
                {
                    RF[p_RF].Bulk[cou_Chrono][cou_Raw][cou_O].Data.U = 0;
                    RF[p_RF].Bulk[cou_Chrono][cou_Raw][cou_O].Data.U = NT4_Core.get_Output_Primitive_uint(Raw_Name[cou_Raw], cou_O);

                    RF[p_RF].Bulk[cou_Chrono][cou_Raw][cou_O].Match.D = 0.0;
                    if (RF[p_RF].Bulk[cou_Chrono][cou_Raw][cou_O].Data.D == RF[p_RF].Input_Interm[Chrono_Current + cou_Chrono][cou_Raw].D)
                    {
                        //---std::cout << "  << Match >>";
                        RF[p_RF].Bulk[cou_Chrono][cou_Raw][cou_O].Match.D = 1.0;
                    }

                    RF[p_RF].Bulk[cou_Chrono][cou_Raw][cou_O].Charge = 0.0;
                    RF[p_RF].Bulk[cou_Chrono][cou_Raw][cou_O].Charge = NT4_Core.get_Output_Charge(Raw_Name[cou_Raw], cou_O);

                    RF[p_RF].Bulk[cou_Chrono][cou_Raw][cou_O].flg_Use = 1;
                    RF[p_RF].Bulk[cou_Chrono][cou_Raw][cou_O].RC = NT4_Core.get_Output_RC(Raw_Name[cou_Raw], cou_O);
                }
                //---std::cout << "\n\n Raw[" << cou_Raw << "]: ";
                //---NT4_Core.output_Output_Double(Raw_Name[cou_Raw]);
            }
        }

        //std::cout << "\n lkdsjflksjfpjpoijewopjwiojoi  eerwf hthjtr hrt t  jf kljfjejw;jo4ij93ufj043j0     3333";
    }

    //WIP
    void generate_Avg_Output(int p_RF, int p_Chrono, int p_Interm)
    {
        std::vector<uint64_t> tmp_Pattern;
        u_Data tmp_Bit;

        double tmp_Total = 0.0;
        float tmp_Count = 0.0;

        //---std::cout << "\n\n\n  --==<<                                >>==-- ";
        //---std::cout << "\n  --==<<      Generating Avg Output     >>==-- ";
        //---std::cout << "\n  --==<<                                >>==-- \n\n\n\n";

        //---std::cout << "\n\n #Outputs: " << NT4_Core.get_Output_Depth("Chrono");

        for (int cou_Raw = 0; cou_Raw < Raw_Depth; cou_Raw++)
        {
            //if (!(cou_Raw % 5)) { std::cout << "\n"; }

            //---std::cout << "\n    <[R " << cou_Raw << " ";
            //NT4_Core.output_Output_Double(Raw_Name[cou_Raw]);

            tmp_Total = 0.0;
            tmp_Count = 0.0;

            //---std::cout << " CBits: ";
            for (int cou_O = 0; cou_O < NT4_Core.get_Output_Depth(Raw_Name[cou_Raw]); cou_O++)
            {
                tmp_Pattern = NT4_Core.get_Output_Pattern_uint(Raw_Name[cou_Raw], cou_O);
                tmp_Bit.U = 0;
                tmp_Bit.U = tmp_Pattern[0];
                tmp_Total += tmp_Bit.D;
                tmp_Count++;
                //---std::cout << " " << cou_O << "{" << tmp_Bit.D;

            }

            //---std::cout << "\n BEFORE::::::::::::::::::::::::::::::::::::::: tmp_Total: " << tmp_Total << " tmp_Count: " << tmp_Count;
            if ((tmp_Count == 0) || (tmp_Total == 0))
            {
                tmp_Total = 0;
            }
            else
            {
                tmp_Total = tmp_Total / tmp_Count;
            }

            double tmp_Remainder = (tmp_Total - int(tmp_Total));

            int tmp_Total_Rounded = int(tmp_Total);
            if (tmp_Remainder > 0.5) { tmp_Total_Rounded++; }

            //---std::cout << "\n AFTER::::::::::::::::::::::::::::::::::::::: tmp_Total: " << tmp_Total << " tmp_Count: " << tmp_Count;
            RF[p_RF].Output[Chrono_Depth - 1][cou_Raw].D = tmp_Total_Rounded;

            if (p_Interm != -1)
            {
                RF[p_RF].Input_Interm[p_Interm][cou_Raw].D = tmp_Total_Rounded;
            }

            //---std::cout << " Ttl: " << tmp_Total;
            //---std::cout << " TtlR: " << tmp_Total_Rounded;
            //---std::cout << " ]> ";
        }
    }

    void output_Bulk(int p_RF)
    {
        //---validate_RF(p_RF);

        RF[p_RF].output_Bulk();
    }

    void calculate_Match_Use(int p_RF)
    {
        //---validate_RF(p_RF);

        RF[p_RF].calculate_Match_Use();
    }

    std::vector<u_Data> get_Random_Raw_Projection(int p_Raw)
    {
        std::vector<u_Data> tmp_Data;
        tmp_Data.resize(Chrono_Depth);

        //std::cout << "\n Random Projection[" << p_Raw << "] Low: " << Range_Low[p_Raw] << " High: " << Range_High[p_Raw];

        int tmp_Diff = int(Range_High[p_Raw] - Range_Low[p_Raw]);

        for (int cou_Chrono = 0; cou_Chrono < Chrono_Depth; cou_Chrono++)
        {
            if (tmp_Diff == 0)
            {
                tmp_Data[cou_Chrono].D = Range_High[p_Raw];
            }
            else
            {
                tmp_Data[cou_Chrono].D = (rand() % tmp_Diff) + Range_Low[p_Raw];
            }
        }
        return tmp_Data;
    }

    void output_IO(int p_RF)
    { 
        //---validate_RF(p_RF);

        RF[p_RF].output_IO();
    }

    void output_IO_Stats(int p_RF)
    {
        //---validate_RF(p_RF);

        RF[p_RF].output_IO_Stats();
    }

    void output_Everything()
    {
        NT4_Core.output_Constructs();

        for (int cou_RF = 0; cou_RF < RF.size(); cou_RF++)
        {
            //output_IO(cou_RF);
            output_IO_Stats(cou_RF);
        }
    }
};
